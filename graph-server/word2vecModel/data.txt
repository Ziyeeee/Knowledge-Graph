 第 18 章   关联 规则 挖掘 
为什么 是 什么 怎么 做 
18.1   关联 规则 挖掘 概述 
关联 就是 反映 某个 事物 与 其他 事物 之间 相互依存 关系 而 关联 分析 是 指 在 交易 数据 中 找出 存在 于 项目 集合 之间 的 关联 模式 即 如果 两个 或 多个 事物 之间 存在 一定 的 关联性 则 其中 一个 事物 就 能 通过 其他 事物 进行 预测 通常 的 做法 是 挖掘 隐藏 在 数据 中 的 相互 关系 当 两个 或 多个 数据项 的 取值 相互间 高 概率 的 重复 出现 时 那么 就 会 认为 它们 之间 存在 一定 的 关联 

18.1 . 1 一个 简单 的 关联 规则 应用 案例 
网络 购物 越来越 受欢迎 电商 平台 的 卖家 同样 竞争 激烈 作为 电商 店铺 管理员 我们 能够 获得 每个 用户 在 本店 的 购买 记录 通过 利用 这些 购买 记录 采取 合适 的 销售策略 能 在 一定 程度 上 提高 店铺 的 商品 销量 那么 如何 利用 这些 购买 记录 呢 下面 我们 将 一起 探索 这个 问题 
表 18 - 2 中 给出 了 某 电商 店铺 的 部分 事务 数据 其中 包含 10 个 事务 即 10 条 购买 记录 我们 期望 从中 发现 一些 关联 规则 从而 合理 地 设置 商品 组合 
表 18 - 1   某 电商 店铺 的 事务 数据 
TID 事务 ID 
商品 列表 
T100 
暂略 
T101 

T102 

T103 

T104 

T105 

T106 

T107 

T108 

T109 

	 
通过 关联 规则 分析 我们 发现 了 如下 几条 关联 规则 
笔记本 保护套 → 机械 键盘                                                     1 
钢笔 → 保温杯 	 	 	 	 	 	           2 
手机 壳 → 键盘 清洁 工具       	 	 	               	       3   
对于 关联 规则 1 这个 推论 是 可以 接受 的 购买 笔记本 保护套 的 顾客 通常 是 刚 买 了 笔记本 而 为了 代替 笔记本电脑 的 键盘 这些 顾客 可能 就 会 再 买 一个 机械 键盘 根据 这 条 关联 规则 我们 可以 设置 销售策略 顾客 在 购买 机械 键盘 后 少量 加价 即可 赠送 笔记本 保护套 从而 提高 销量 
对于 关联 规则 2 这个 推论 较难 直接 看出 因果关系 但 我们 可以 试着 推出 钢笔 和 保温杯 的 优惠 购买 套餐 再 根据 销售 情况 适时 调整 
对于 关联 规则 3 我们 可以 认为 购买 手机 壳 的 用户 爱好 干净 整洁 所以 会 同时 购买 键盘 清洁 工具 所以 可以 在 用户 挑选 手机 壳 的 界面 放入 键盘 清洁 工具 的 相关 图片 和 链接 刺激 消费 
	 在 下 一 小节 我们 会 更 详细 地 介绍 关联 规则 分析 所 涉及 的 基本概念 同时 也 会 介绍 关联 规则 的 分类 使 你 对 关联 规则 有 更 清晰 且 全面 的 认识 
	 
18.1 . 2 关联 规则 的 定义 与 分类 
我们 首先 需要 介绍 一些 关联 规则 分析 所 涉及 的 基本概念 
数据 通常 以 二维 表 的 形式 展示 如表 18 - 1 所示 每 一行 都 对应 一个 事务 令 T = { t _ 1 , t _ 2 , , t _ N } 是 所有 事务 的 集合 对于 每行 事务 其中 包含 的 每个 商品 都 称为 项 在 关联 分析 中 包含 零个 或 多个 项 的 集合 称为 项集 如果 一个 项集 包含 k 个项 则 称 它 为 k - 项集 例如 { I1 I2 I4 } 是 一个 三项 集 空集 则 是 不 包含 任何 项 的 项集 项集 有 一个 重要 的 属性 称为 支持 度 计数 是 指 在 数据库 中 包含 该项 集 的 事务 个数 也 称为 出现 频度 我们 用 σ ( X ) 表示 具体 定义 为 
σ ( X ) = | { t _ i   | X ⊑ t _ i , t _ i ∈ T } | 
其中 符号 | • | 表示 集合 中 元素 的 个数 
关联 规则 是 形如 X → Y 的 蕴涵 表达式 其中 X 和 Y 是 不 相交 的 两个 项集 
以 上述 关联 规则 1 为例 购买 笔记本 保护套 的 顾客 也 倾向 于 购买 机械 键盘 则 可以 表示 如下 
I3 = > I1 [ support = 40% ; confidence = 80% ] 
其中 support 是 支持 度 可以 用于 给定 数据 集 的 频繁 程度 表示 所有 事务 的 40% 显示 机械 键盘 和 笔记本 保护套 被 同时 购买 confidence 是 置信度 可以 用于 确定 后者 在 包含 前者 的 事务 中 出现 的 频繁 程度 表示 购买 笔记本 保护套 的 顾客 中 80% 也 购买 了 机械 键盘 
对于 关联 规则 X → Y 令 N 是 事务 个数 给出 支持 度 s 和 置信度 c 的 形式 定义 如下 
s ( X → Y ) = ( σ ( X ∪ Y ) ) / N 
c ( X → Y ) = ( σ ( X ∪ Y ) ) / ( σ ( X ) ) [ l1 ] 
为了 筛选 出 有用 的 关联 规则 我们 需要 根据 应用 场景 设定 相应 的 阈值 分别 是 最小 支持 度 阈值 minsup 和 最小 置信度 阈值 minconf 对于 项集 来说 如果 它 的 支持 度 满足 最小 支持 度 阈值 则 称 它 为 频繁 项集 频繁 k 项集 的 集合 通常 记为 L _ k 而 对于 规则 来说 如果 它 同时 满足 最小 支持 度 阈值 和 最小 置信度 阈值 则 称 它 为 强 规则 
由于 在 不同 的 应用 场景 下 数据 形式 也 会 有所不同 挖掘 得到 的 关联 规则 也 会 不同 我们 基于 不同 的 考量 给出 三种 常用 的 关联 规则 分类 具体 如下 
  基于 规则 所 涉及 的 维数 
  单维 关联 规则 若 关联 规则 中 的 项 或 属性 只 涉及 一个 维 1 则 称 它 为 单维 关联 规则 单维 关联 规则 展示 了 同一个 属性 或维内 的 联系 例如 
buys ( X ,   " laptop " ) → buys ( X ,   " keyboard " )                             18 - 3 
其中 X 指代 顾客 在 该 关联 规则 中 只 涉及 了 buys 这 一个 维 
  多维 关联 规则 若 关联 规则 中 的 项 或 属性 涉及 两个 及 以上 的 维 则 称 它 为 多维 关联 规则 多维 关联 规则 展示 了 不同 属性 或维 之间 的 关联 例如   
age ( X ,   " " 20 "   - " 29 \ " "   )         income ( X ,   30K - 50K " ) → buys ( X ,   " laptop " )   18 - 4 
其中 X 同样 指代 顾客 该 规则 涉及 三个 维 分别 是 age income 和 buys 
  基于 规则 所 处理 的 值 类型 
  布尔 关联 规则 若 关联 规则 只 考虑 项 是否 出现 而 不 涉及 具体 的 取值 则 它 是 布尔 关联 规则 例如 在 关联 规则 18 - 3 中 它 只 考虑 顾客 是否 购买 laptop 和 keyboard 而 不 考虑 顾客 购买 的 laptop 的 价格 等 属性 所以 它 是 布尔 关联 规则 
  量化 关联 规则 若 关联 规则 中 还 考虑 了 量化 的 项 或 属性 之间 的 关联 则 它 是 量化 关联 规则 在 量化 关联 规则 中 部分 项 或 属性 的 值 被 划分 为 区间 这些 属性 被 称为 量化 属性 例如 在 关联 规则 18 - 4 中 age 和 income 都 是 量化 属性 所以 该 规则 是 量化 关联 规则 注意 量化 关联 规则 中 也 能 包含 非 量化 的 项 或 属性 例如 规则 18 - 4 中 的 buys 
  基于 所 挖掘 的 数据类型 和 特征 
  时序 模式 关联 规则 在 一些 应用 场景 中 关联 规则 可能 涉及 到 序列 特征 即 存在 基于 时间 或 空间 的 先后 次序 例如 通过 店铺 订单 数据 我们 可能 发现 顾客 会先 购买 PC 再 购买 机械 键盘 显示器 等 外设 接着 购买 电脑 保护套 键盘 清洁 泥 等 小 工具 这 就是 一种 序列 模式 时序 模式 关联 规则 就是 包含 序列 模式 信息 的 关联 规则 
  结构 模式 关联 规则 结构 模式 是 指 结构 数据 集中 的 频繁 子结构 与 序列 相比 结构 是 一个 更 一般 的 概念 包括 有向图 无向 图 格 树 序列 集合 等 单个 项 可以 看作 是 最 简单 的 结构 模式 结构 模式 关联 规则 就是 挖掘 结构 模式 得到 的 关联 规则 
除了 上述 分类 还有 对闭 模式 极大 模式 不 频繁 模式 稀有 模式 负 模式 压缩 模式 等 模式 的 挖掘 而 产生 的 关联 规则 我们 会 在 18.6 节作 简单 的 介绍 有 兴趣 的 同学 也 可以 自行 搜索 资料 了解 下 一 小节 我们 会 向 你 介绍 频繁 模式 的 关联 规则 挖掘 的 基本 框架 使 你 对 关联 规则 挖掘 的 流程 有 全面 的 了解 
18.1 . 3 关联 规则 挖掘 的 基本 框架 
表 18 - 1   商品 ID 与 商品名称 对应 关系 
暂略 

表 18 - 2   某 电商 店铺 的 事务 数据 

关联 规则 挖掘 任务 通常 分为 两个 子 任务 
1 频繁 项集 发现 目标 是 找出 所有 满足 最小 支持 度 阈值 的 项集 这些 项集 被 称为 频繁 项集 
2 关联 规则 产生 目标 是从 发现 的 频繁 项 集中 提取 出 所有 满足 最小 置信度 阈值 的 规则 这些 规则 被 称为 强 规则 
在 上述 例子 中 I = { I1 ,   I2 ,   I3 ,   I4 ,   I5 ,   I6 ,   I7 } 是 所有 项 的 集合 其中 能 产生 2 ^ 7 种 项集 组合 其中 包括 1 个 空集 7 个 1 - 项集 21 个 2 - 项集 35 个 3 - 项集 35 个 4 - 项集 21 个 5 - 项集 7 个 6 - 项集 1 个 7 - 项集 我们 称 这些 项集 为 候选 项集 
那么 怎么 判断 哪些 是 频繁 项集 呢 从 频繁 项集 的 定义 出发 我们 只 需要 计算 出 每个 项集 的 支持 度 再 将 其 与 最小 支持 度 阈值 比较 满足 的 即 为 频繁 项集 要 计算 候选 项集 的 支持 度 我们 需要 确定 候选 项集 的 支持 度 计数 而 确定 支持 度 计数 的 方法 很 简单 只 需要 将 候选 项集 与 每个 事务 进行 比较 如果 候选 项集 包含 在 事务 中 就 增加 它 的 支持 度 计数 例如 候选 项集 { I2 ,   I3 } 出现 在 事务 T002 和 T009 中 其 支持 度 计数 即为 2 再 根据 支持 度 计算公式 其 支持 度为 0.2 
按 上述 方法 计算 每个 候选 项集 的 支持 度 并 与 最小 支持 度 阈值 本例 设为 0.3 比较 最后 得到 14 个 频繁 项集 具体 如下 

这种 频繁 项集 挖掘 方法 虽然 容易 理解 但是 计算 开销 大 需要 进行 O ( NMw ) 次 比较 其中 N 是 事务 数 M = 2 ^ k - 1 是 候选 项 集数 不 含 空集 而 w 是 事务 的 最大 宽度 在 本例 中 N = 10 M = 127 w = 4 而 在 实际 应用 中 这 几个 值 可能 很大 所以 在 下 一节 我们 会 介绍 更好 的 算法 降低 发现 频繁 项集 的 计算 复杂度 

得到 频繁 项集 后 我们 需要 从 这些 频繁 项 集中 提取 出 关联 规则 强 规则 提取 的 方式 可以 简要地 概括 如下 将 频繁 项集 Y 划分 成 两个 非 空子 集 X 和 Y - X 得到 候选 关联 规则 X → Y - X 然后 计算 该 候选 关联 规则 的 置信度 若 满足 最小 置信度 阈值 则 该 关联 规则 就是 强 规则 否则 舍弃 注意 X 和 Y - X 必须 是非 空子 集 因为 ∅ → Y 和 Y → ∅ 没有 实际意义 
以 Y = { I1 ,   I3 } 这个 频繁 项集 为例 从中 能够 产生 2 个 候选 关联 规则 { I1 } → { I3 } { I3 } → { I1 } 由于 它们 的 支持 度 都 等于 Y 的 支持 度 所以 这些 候选 关联 规则 必定 满足 最小 支持 度 阈值 我们 需要 计算 这 2 个 候选 关联 规则 的 置信度 根据 置信度 计算公式 { I3 } → { I5 } 的 置信度 为 ( σ ( { I3 ,     I5 } ) ) / ( σ ( I3 ) ) = 3 / 6 = 0.5 而 { I3 } → { I1 } 的 置信度 则 为 ( σ ( { I3 ,     I5 } ) ) / ( σ ( I5 ) ) = 3 / 5 = 0.6 最后 将 计算 得到 的 置信度 与 最小 置信度 阈值 比较 即可 得到 我们 的 目标 强 规则 
每个 频繁 k - 项集 能够 产生 2 ^ k - 2 个 候选 关联 规则 除去 两个 包含 空集 的 关联 规则 我们 首先 从 上 一步 得到 的 频繁 项 集中 产生 候选 关联 规则 然后 一一 计算 它们 的 置信度 并 与 最小 置信度 阈值 本例 设为 0.7 比较 最终 就 能 得到 该例 下 的 全部 强 规则 即 我们 期望 发现 的 关联 规则 在 本例 中 我们 最后 能 得到 6 条强 规则 具体 如下 
{ I5 }   →   { I6 } ,     confidence = 1.0 
{ I6 }   →   { I5 } ,     confidence = 1.0 
{ I1 ,   I5 }   →   { I6 } ,     confidence = 1.0 
{ I1 ,   I6 }   →   { I5 } ,     confidence = 1.0 
{ I3 ,   I5 }   →   { I6 } ,     confidence = 1.0 
{ I3 ,   I6 }   →   { I5 } ,     confidence = 1.0 

同样 此处 介绍 的 关联 规则 产生 方法 虽然 容易 理解 但是 计算 开销 较大 我们 会 在 18.3 节 介绍 更好 的 算法 降低 计算 复杂度 



18.2   频繁 项集 发现 
要 降低 频繁 项集 挖掘 的 计算 复杂度 我们 可以 从 以下 三个 方面 进行 优化 
  减少 候选 项集 的 数目 
  减少 候选 项集 与 事务 的 比较 次数 
  减少 事务 数目 
下面 我们 将 介绍 Apriori 算法 FP - Tree 算法 Eclat 算法 并 在 18.2 . 4 小节 中 对 这 几种 算法 进行 比较 

18.2 . 1   Apriori 类 算法 
Apriori 算法 是 第一个 关联 规则 挖掘 算法 由 Agrawal 和 R . Srikant 于 1994 年 提出 它 利用 先验 原理 开创性 地 使用 了 基于 支持 度 的 剪枝 技术 系统地 控制 候选 项集 指数 增长 [ l2 ] 
在 介绍 Apriori 算法 之前 我们 需要 先 理解 先验 原理 它 能 帮助 我们 利用 支持 度 度量 减少 产生 频繁 项集 时 所 需 扫描 的 候选 项集 个数 
定理   18.1   先验 原理   如果 一个 项集 是 频繁 的 则 它 的 所有 子集 一定 也 是 频繁 的 
为了 更好 地 理解 先验 原理 我们 从 一个 例子 出发 假设 项集 { I1 ,   I3 ,   I4 } 是 频繁 项集 而 任何 包含 项集 { I1 ,   I3 ,   I4 } 的 事务 一定 包含 它 的 子集 { I1 } { I3 } { I4 } { I1 ,   I3 } { I1 ,   I4 } { I3 ,   I4 } 所以 如果 项集 { I1 ,   I3 ,   I4 } 是 频繁 的 则 它 的 子集 的 支持 度 一定 大于 或 等于 它 本身 的 支持 度 所以 它 的 子集 也 都 是 频繁 的 
相反 如果 一个 项集 是非 频繁 的 那么 它 的 所有 超集 也 都 是非 频繁 的 例如 假设 项集 { I1 ,   I3 } 是非 频繁 的 则 如 { I1 ,   I3 ,   I4 } { I1 ,   I3 ,   I5 ,   I6 } 等 { I1 ,   I3 } 的 超集 的 支持 度 一定 小于 或 等于 { I1 ,   I3 } 的 支持 度 所以 它 的 所有 超集 都 是非 频繁 的 利用 这 一点 我们 就 能 有效 减少 候选 项集 的 数目 这种 基于 支持 度 度量 修剪 指数 搜索 空间 的 策略 称为 基于 支持 度 的 剪枝 而 这种 剪枝 策略 依赖于 支持 度 度量 的 一个 重要 性质 反 单调 性 
定义   18.1   反 单调 性   如果 对于 项集 Y 的 每个 真 子集 X 即 X ⊏ Y 有 f ( Y ) ≤ f ( X ) 那么 称 度量 f 具有 反 单调 性 
对于 支持 度 度量 来说 即 一个 项集 的 支持 度 绝不会 超过 它 的 子集 的 支持 度 而 除了 支持 度 度量 一些 其它 度量 也 具有 反 单调 性 同样 能够 应用 在 挖掘 算法 中 以 有效 地 修剪 候选 项集 的 指数 搜索 空间 [ l3 ] 
了解 了 先验 原理 下面 我们 将 结合 具体 实例 来 介绍 Apriori 算法 
Apriori 算法 的 基本 思想 是 通过 逐层 搜索 迭代 用 上 一轮 迭代 得到 的 k 项集来 探索 下 一轮 迭代 的 k + 1 项集 初始 时 我们 将 每个 项 都 看作 候选 1 - 项集 其 集合 记为 C _ 1 对 它们 进行 支持 度 计数 后 满足 最小 支持 度 阈值 的 项集 被 留下 构成 频繁 1 - 项集 其 集合 记为 L _ 1 在 第二轮 迭代 中 利用 L _ 1 来 生成 候选 2 - 项集 的 集合 C _ 2 然后 利用 先验 原理 进行 剪枝 只 保留 那些 所有 子集 都 频繁 的 候选 2 - 项集 再 对 这些 候选 2 - 项集 进行 支持 度 计数 与 最小 支持 度 阈值 比较 得到 频繁 2 - 项集 的 集合 L _ 2 在 下 一轮 迭代 再 以 同样 方法 找出 L _ 3 如此 迭代 下去 直到 不能 再 发现 频繁 k 项集 为止 
表 18 - 2   某 电商 店铺 的 事务 数据 

以 18.1 . 3 小节 中 的 数据 为例 共有 10 个 事务 设定 最小 支持 度 阈值 为 0.3 即 最小 支持 度 计数 为 3 
第一轮 迭代 每个 项 都 是 候选 1 - 项集 的 集合 C _ 1 的 成员 算法 扫描 全部 事务 对 每个 候选 1 - 项集 的 出现 次数 计数 将 每个 候选 项集 的 支持 度 计数 与 最小 支持 度 计数 比较 得到 频繁 1 - 项集 的 集合 L _ 1 在 本例 中 { I4 } 的 支持 度 计数 不 满足 最小 支持 度 计数 被 剪 去 

图 18 - 1   第一轮 迭代 过程 
第二轮 迭代 通过 L _ 1 ⋈ L _ 1 来 产生 候选 2 - 项集 的 集合 C _ 2 共有 15 个 2 - 项集 由于 它们 的 所有 子集 都 是 频繁 的 所以 没有 候选 被 删除 然后 对 C _ 2 中 的 每个 候选 进行 支持 度 计数 将 每个 候选 项集 的 支持 度 计数 与 最小 支持 度 计数 比较 得到 L _ 2 

图 18 - 2   第二轮 迭代 过程 
第三轮 迭代 通过 L _ 2 ⋈ L _ 2 来 产生 候选 3 - 项集 的 集合 C _ 3 共有 4 个 3 - 项集 具体 为 C _ 3 = L _ 2 ⋈ L _ 2 = { { I1 ,   I3 ,   I5 } ,   { I1 ,   I3 ,   I6 } ,   { I1 ,   I5 ,   I6 } ,   { I3 ,   I5 ,   I6 } } 根据 先验 原理 这 四个 候选 项集 的 所有 子集 都 是 频繁 的 所以 这 四个 项集 的 集合 构成 C _ 2 然后 对 C _ 2 中 的 每个 候选 进行 支持 度 计数 将 每个 候选 项集 的 支持 度 计数 与 最小 支持 度 计数 比较 得到 L _ 3 

图 18 - 3   第三轮 迭代 过程 
第四轮 迭代 通过 L _ 3 ⋈ L _ 3 来 产生 候选 4 - 项集 的 集合 C _ 4 其中 只有 一个 候选 4 - 项集 { I1 ,   I3 ,   I5 ,   I6 } 而 根据 先验 原理 它 不 满足 所有 的 子集 都 是 频繁 的 条件 所以 C _ 4 = ∅ 因此 算法 终止 我们 成功 得到 了 全部 频繁 项集 

下面 给出 Apriori 算法 产生 频繁 项集 的 伪 代码 

下面 分析 该 算法 的 复杂度 与 穷举法 比较 [ l4 ] 

那么 如何 才能 进一步提高 Apriori 算法 的 效率 呢 下面 我们 将 简单 介绍 一些 经过 实践 验证 且 比较 有效 的 优化 方法 
基于 散列 优化 支持 度 计数   首先 需要 设置 一个 合理 的 散列 函数 当散列 k - 项集时 散列 函数 就 有 k 个 自变量 如散列 2 - 项集时 可以 设散列 函数 如下 
h ( x ,   y ) = ( f ( x ) * 10 + f ( y ) )     mod   7 
其中 x 是 项 f ( x ) 是 一个 自定义 的 映射 将 项 映射 到 一个 数值 比如 f ( I _ k   ) =   k 当 需要 从 L _ ( k - 1 ) 生成 C _ k 时 我们 可以 扫描 一次 全部 事务 然后 生成 全部 候选 k - 项集 将 它们 按照 散列 函数 散列 到 不同 的 桶 中 统计 每个 桶 的 项集 个数 如果 一个桶 的 项集 个数 低于 最小 支持 度 阈值 则 这个 桶 内 的 全部 项集 都 可以 排除 从而 减少 了 候选 k - 项集 的 数量 经过 实践 当 k = 2 时 优化 效果 尤为 明显 
压缩 迭代 时 扫描 的 事务 数   如果 一个 事务 不 包含 任何 一个 频繁 k - 项集 那么 这个 事务 也 一定 不 包含 任何 一个 频繁 k + 1 - 项集 因此 在 产生 频繁 k - 项集 的 集合 L _ k 后 如果 一个 事务 满足 这 一点 就 可以 将 其 删除 或 标记 在 之后 的 迭代 中 不再 需要 考虑 
基于 划分 快速 寻找 频繁 项集   划分 技术 是 分治 思想 的 体现 首先 我们 将 全部 事务 尽量 均匀 地 划分 为 n 个 分组 然后 根据 最小 支持 度 阈值 找出 每个 分组 中 的 频繁 项集 称为 局部 频繁 项集 接着 我们 将 全体 局部 频繁 项集 作为 候选 项集 再次 扫描 全部 事务 计算 每个 候选 项集 的 实际 支持 度 与 最小 支持 度 阈值 比较 后 得到 全局 频繁 项集 值得一提的是 如果 每个 分组 的 大小 都 能 放入 内存 那么 运行 效率 就 会 较 快 我们 可以 依次 确定 分组 的 数量 
抽样 搜索 频繁 项集   首先 我们 从 全部 事务 中 随机 抽取 部分 事务 集合 S 然后 在 S 中 寻找 频繁 项集 通常 会 控制 S 的 大小 使 其能 装入 主存 使得 扫描 一遍 即可 完成 计算 显而易见 这种 方法 虽然 减少 了 事务 数 但是 会 遗漏 部分 频繁 项集 为了 降低 这种 可能性 我们 在 S 中 寻找 频繁 项集时 设定 更 小 的 最小 支持 度 阈值 找到 S 中 的 频繁 项集 后 我们 使用 一种 机制 来 确定 是否 有 遗漏 若有 遗漏 则 需要 对 全部 事务 进行 第二次 扫描 反之 就 结束 搜索 这种 方法 通常 应用 在 效率 优先 的 场合 

18.2 . 2   FP - tree 算法 
这一 小节 我们 将 介绍 一种 完全 不同于 Apriori 算法 的 频繁 项集 挖掘 方法 这种 方法 由 韩嘉炜 等 人于 2000 年 提出 名为 频繁 模式 增长 Frequent - Pattern   Growth 它 通过 使用 一种 紧凑 的 数据结构 FP 树 FP - tree 来 组织 数据 并 从中 发现 频繁 项集 所以 也 被 称为 FP - tree 算法 
FP - tree 算法 的 基本 思想 是 依次 读入 每个 事务 构造 出 FP - tree 然后 自 底向上 探索 FP - tree 的 全部 路径 查找 出 全部 频繁 项集 这个 方法 也 可以 分为 两步 首先 是 构造 出 FP - tree 然后 是 由 FP - tree 产生 频繁 项集 
同样 以 18.1 . 3 节中 的 数据 为例 设定 最小 支持 度 阈值 为 0.2 即 最小 支持 度 计数 为 2 
第一次 扫描 全部 事务 得到 每个 1 - 项集 的 支持 度 计数 与 最小 支持 度 计数 比较 后 { I4 } 被 剪枝 剩余 的 构成 频繁 1 - 项集 的 集合 并 将 它们 按 支持 度 递减 排序 
第二次 扫描 就 开始 构建 FP - tree 第一步 创建 根 结点 标记 为 null 然后 读入 第一个 事务 { I1 I2 } 构造 这 两个 项 的 结点 并 按照 支持 度 递减 的 次序 处理 形成 null → I1 → I2 的 路径 路径 上 结点 的 计数 增加 1 初始 为 0 接着 读入 第二个 事务 { I2 I3 I5 I6 } 需要 创建 I2 I3 I5 I6 的 结点 形成 null → I3 → I5 → I6 → I2 的 路径 这 四个 结点 的 计数 增加 1 同理 读入 第三个 事务 { I3 I5 I6 } 再 读入 第四个 事务 { I1 I3 I7 } 由于 该 事务 的 第一个 项 也 是 I1 所以 只 需 创建 I3 和 I7 的 结点 该 事务 的 路径 null → I1 → I3 → I7 与 第一个 事务 的 路径 null → I1 → I2 部分 重叠 读入 前 4 个 事务 的 FP - tree 的 构建 过程 如图 18 - 4 所示 
继续 读入 剩余 的 6 个 事务 按 上述 步骤 依次 处理 最后 便 能 得到 完整 的 FP - tree 为了 使 遍历 FP - tree 更加 快捷 我们 将 频繁 1 - 项集 的 集合 与 FP - tree 链接 通过 结点 链 使 每个 项 都 能 在 FP - tree 中 快速 定位 最后 得到 的 FP - tree 如图 18 - 5 所示 建议 同学 们 自己 动手 尝试 一下 从而 更好 地 理解 FP - tree 的 构建 过程 

图 18 - 4   依次 读入 前 4 个 事务 的 FP - tree 


图 18 - 5   读入 全部 事务 的 FP - tree 

得到 FP - tree 后 我们 就 可以 在 其中 进行 频繁 模式 挖掘 了 首先 从 全局 来看 我们 可以 将 全体 频繁 项集 的 集合 分为 多个 小 集合 在 本例 中 可以 将 全体 频繁 项集 的 集合 划分 为 分别 以 I1 I2 I3 I5 I6 I7 结尾 的 频繁 项集 集合 其中 每个 频繁 项 集中 的 项 都 按照 支持 度 递减 排序 从而 避免 重复 在 这里 我们 利用 了 分治 的 思想 将 一个 规模 较大 的 问题 转化 为了 6 个 规模较 小 的 问题 下面 我们 就 来 解决 挖掘 以 某个 项 结尾 的 频繁 项集 的 子 问题 
我们 首先 考虑 挖掘 以 I7 结尾 的 频繁 项集 集合 因为 I7 的 支持 度 最低 按 支持 度 由 低 到 高来 解决 这 6 个子 问题 是 有 理由 的 我们 之后 会 进行 解释 暂且 先 将 注意力 集中 到 这个 子 问题 上 观察 图 18 - 5 中 的 FP - tree 根据 结点 链 我们 发现 I7 出现 在 3 个 分枝 中 对应 的 路径 分别 是 null → I1 : 6 → I3 : 3 → I7 : 1 null → I3 : 3 → I2 : 1 → I7 : 1 和 null → I2 : 1 → I7 : 1 { I7 } 本身 是 频繁 项集 再 考虑 以 I7 为 结尾 有 I1 : 6 → I3 : 3 I3 : 3 → I2 : 1 和 I2 : 1 三条 前缀 路径 由于 这些 路径 中 存在 某些 事务 并 不 包含 I6 所以 我们 要 将 那些 事务 去除 更新 前缀 路径 上 的 支持 度 计数 即 得到 I1 : 1 → I3 : 1 I3 : 1 → I2 : 1 和 I2 : 1 三条 前缀 路径 将 这三条 前缀 路径 上 的 项 以及 它们 的 支持 度 计数 看作 事务 数据库 中 的 数据 可以 得到 子 事务 数据库 也 称为 I6 的 条件 模式 基 再 根据 条件 模式 基来 构造 FP - tree 将 其 称为 I6 的 条件 FP - tree 如图 18 - 6 所示 

图 18 - 6     I7 的 条件 FP - tree 
由于 I7 的 条件 FP - tree 中 所有 可能 的 前缀 项集 的 支持 度 计数 都 小于 最小 支持 度 阈值 3 所以 我们 不必 继续 探索 可以 得出结论 除去 { I7 } 本身 外 不 存在 以 I7 结尾 的 频繁 项集 此后 我们 不再 指出 除去 结尾 本身 的 频繁 项集 这 一点 
然后 我们 要 解决 下 一个 子 问题 即 挖掘 以 I2 结尾 的 频繁 项集 因为 I2 的 支持 度次 低 以 同样 的 步骤 得到 I2 的 条件 模式 基 并 构建 I2 的 条件 FP - tree 如图 18 - 7 所示 

图 18 - 7     I2 的 条件 FP - tree 
同样 I2 的 所有 可能 前缀 项集 的 支持 度 计数 也 都 小于 3 所以 可以 得出结论 不 存在 以 I2 结尾 的 频繁 项集 
接着 我们 挖掘 以 I6 结尾 的 频繁 项集 以 同样 的 步骤 可以 得到 I6 的 条件 FP - tree 如图 18 - 8 所示 

图 18 - 8     I6 的 条件 FP - tree 
此时 我们 发现 有 3 个 前缀 项集 的 支持 度 满足 最小 支持 度 阈值 所以 我们 需要 继续 探索 让 我们 再次 利用 分治 思想 挖掘 以 I6 结尾 的 频繁 项集 的 问题 可以 再次 分解 为 3 个子 问题 分别 是 挖掘 以 { I1 ,   I6 } { I3 ,   I6 } { I5 ,   I6 } 结尾 的 频繁 项集 同样 以 支持 度 从 低 到 高 依次 解决 每个 子 问题 首先 是 挖掘 以 { I3 ,   I6 } 结尾 的 频繁 项集 { I3 ,   I6 } 的 支持 度 计数 为 3 满足 最小 支持 度 计数 所以 是 频繁 2 - 项集 然后 我们 按照 与 之前 相同 的 方式 寻找 出 { I3 ,   I6 } 的 条件 模式 基 并 构建 对应 的 条件 FP - tree 如图 18 - 9 1 所示 由于 其 前缀 项集 支持 度 计数 小于 3 所以 不 存在 以 { I3 ,   I6 } 结尾 的 频繁 项集 接着 是 挖掘 以 { I1 ,   I6 } 结尾 的 频繁 项集 { I1 ,   I6 } 的 支持 度 计数 为 3 所以 是 频繁 2 - 项集 而 由于 其 条件 FP - tree 为空 所以 并未 画出 结论 是 不 存在 以 { I1 ,   I6 } 结尾 的 频繁 项集 
最后 是 挖掘 以 { I5 ,   I6 } 结尾 的 频繁 项集 { I5 ,   I6 } 的 支持 度 计数 为 5 所以 是 频繁 2 - 项集 其 条件 FP - tree 如图 18 - 9 2 所示 由于 其 前缀 项集 { I1 } 和 { I3 } 的 支持 度 计数 都 满足 最小 支持 度 计数 所以 我们 可以 再 将 问题 分解 为 两个 子 问题 分别 是 挖掘 以 { I1 ,   I5 ,   I6 } 和 { I3 ,   I5 ,   I6 } 为 结尾 的 频繁 项集 这 两个 子 问题 已经 十分 清晰 我们 便 不再 画出 其 条件 FP - tree 而是 直接 给出 结果 { I1 ,   I5 ,   I6 } 和 { I3 ,   I5 ,   I6 } 的 支持 度 计数 都 是 3 所以 都 是 频繁 3 - 项集 而 以 { I3 ,   I5 ,   I6 } 结尾 的 候选 4 - 项集 只有 { I1 ,   I3 ,   I5 ,   I6 } 其 支持 度 计数 为 1 不 满足 最小 支持 度 计数 以 { I1 ,   I5 ,   I6 } 结尾 的 4 - 项集 不 存在 至此 挖掘 以 I6 结尾 的 频繁 项集 该子 问题 求解 结束 

图 18 - 9     左为 I3 ,   I6 的 条件 FP - tree 右为 I5 ,   I6 的 条件 FP - tree 
当然 我们 还 需要 将 三个 子 问题 的 求解 结果 合并 得到 集合 { { I1 ,   I5 ,   I6 } { I3 ,   I5 ,   I6 } { I5 ,   I6 } { I3 ,   I6 } { I1 ,   I6 } } 这 就是 通过 FP - tree 挖掘 得到 的 以 I6 结尾 的 所有 频繁 项集 不 包括 { I6 } 这个 频繁 1 - 项集 
接着 按照 算法 思想 我们 继续 依次 求解 以 I5 I3 I1 结尾 的 频繁 项集 集合 结果 如表 18 - 3 所示 最后 将 FP - tree 挖掘 结果 与 频繁 1 - 项集 的 集合 L _ 1 合并 就 得到 了 我们 所 要 挖掘 的 全体 频繁 项集 不难 发现 这 与 18.2 . 1 节中 Apriori 算法 的 挖掘 结果 是 相同 的 
表 18 - 3   FP - tree 挖掘 结果 

下面 我们 给出 FP - tree 算法 产生 频繁 项集 的 伪 代码 建议 同学 们 结合 伪 代码 再次 体会 FP - tree 算法 的 思想 










现在 我们 来 解释一下 为什么 按 支持 度 由 低 到 高来 解决 子 问题 由于 每次 选择 的 是 最 不 频繁 的 项 作为 结尾 在 搜索 频繁 模式 时 能够 拥有 较 好 的 选择性 即 有 较 多 的 条件 模式 基 相应 的 条件 FP - tree 也 更 茂盛 我们 观察 表 18 - 3 可以 发现 由上至下 结尾 项 的 支持 度 是 递减 的 但是 条件 模式 基的 数量 却是 递增 的 这 就是 较 好 的 选择性 的 含义 FP - tree 算法 的 有趣 之 处 在于 压缩 事务 数据库 递归 生成 子 问题 从而 快速 搜寻 频繁 项集 不过 当 事务 数据库 较大 时 FP - tree 也 会 较大 无法 一次性 放入 主存 导致 效率 降低 这时 我们 可以 将 事务 数据库 划分 成 多个 投影 数据库 并 在 每个 投影 数据库 上 应用 FP - tree 算法 提高 挖掘 效率 
下面 我们 就 来 介绍 一下 如何 得到 投影 数据库 并 应用 FP - tree 算法 
让 我们 从 数据库 投影 的 过程 开始 介绍 首先 按照 支持 度 从小到大 的 顺序 从 频繁 1 - 项集 取出 支持 度 最小 的 项 t 然后 将 原来 的 事务 数据库 中 包含 t 的 事务 取出 去除 这些 事务 中 的 t 和 非 频繁 项 就 得到 了 原 数据库 到 项 t 的 投影 数据库 然后 从 频繁 1 - 项 集中 取出 下 一个 项 p 同样 将 原来 的 事务 数据库 中 包含 p 的 事务 取出 并 去除 这些 事务 中 的 p t 和 非 频繁 项 从而 得到 了 原 数据库 到 项 p 的 投影 数据库 注意 某 一项 的 投影 数据库 中 不会 包含 非 频繁 项 该项 自身 以及 按 支持 度 从 大到 小 排序 好 的 频繁 1 - 项 集中 位序 比 该项 靠 后 的 项 之后 只要 以 相同 的 方式 处理 频繁 1 - 项 集中 的 每个 项 我们 就 将 原本 的 事务 数据库 划分 为了 多个 投影 数据库 
以 18.1 . 3 节中 的 数据 为例 假设 频繁 1 - 项集 的 排序 为 I1 - I3 - I5 - I6 - I2 - I7 我们 得到 6 个 投影 数据库 如下 
表 18 - 3   投影 数据库 

可以 发现 对 频繁 项 t 其 投影 数据库 中 都 不 包含 支持 度 排序 在 其 之后 的 项 和 它 自身 表中 第三 列为 按 支持 度 计数 筛选 后 的 条件 模式 基 得到 全部 投影 数据库 后 我们 只 需要 在 其中 条件 模式 基不为 空 的 投影 数据库 应用 FP - tree 算法 找到 每个 投影 数据库 上 的 频繁 项集 最后 将 结果 合并 即可 得到 全部 频繁 项集 细心 的 同学 可能 已经 发现 投影 数据库 生成 的 FP - tree 和 之前 原 算法 生成 的 条件 FP - tree 十分相似 实际上 这 两个 过程 本 就是 同源 的 
该 投影 过程 只 需要 扫描 一遍 数据库 虽然 在 介绍 的 时候 我们 是 依次 投影 得到 各个 投影 数据库 但 实际上 这些 投影 数据库 可以 并行 生成 并 不会 互相 影响 因此 这个 投影 方法 也 被 称为 并行 投影 parallel   projection 
研究 证明 投影 后 的 子 数据库 所 生成 的 FP - tree 在 大小 上 通常 比原 数据库 所 生成 的 FP - tree 小 几个 数量级 因此 通过 构造 投影 数据库 能够 使 FP - tree 算法 有效 地 应对 大型 数据库 的 应用 场景 此时 你 可能 还会 问 那 如果 投影 数据库 依旧 不能 一次性 放入 主存 该 怎么办 一个 不难 想到 的 解决方案 是 继续 投影 递归 地 执行 这一 过程 直到 最终 得到 的 投影 数据库 能够 一次性 放入 主存 为止 
不过 并行 投影 在 实际 应用 中 依旧 可能 遇到 一些 问题 假设 一个 事务 数据库 中 的 某个 事务 长度 很大 且 包含 很多 频繁 项 那么 在 构造 到 每个 频繁 项 的 投影 数据库 的 过程 中 这个 事务 就 会 被 重复 投影 多次 如果 该 事务 中含 m 个 频繁 项 那么 就 会 被 投影 到 m - 1 个 投影 数据库 该 事务 就 会 占据 大小 约 为 ∑ _ ( i = 0 ) ^ ( m - 1 ) ▒ i = ( m ( m - 1 ) ) / 2 的 空间 而 原先 该 事务 只 需要 占据 大小 约 为 m 的 空间 投影 后 所 占据 的 空间 是 原先 的 ( m - 1 ) / 2 倍 这 在 许多 时候 是 十分 浪费 且 难以 接受 的 
为了 克服 这个 缺点 我们 可以 使用 另 一种 投影 方法 分区 投影 partition   projection 分区 投影 的 执行 过程 和 并行 投影 略有不同 下面 我们 进行 介绍 对于 事务 数据库 中 的 每个 事务 都 只 投影 到 项 t 的 投影 数据库 其中 项 t 是 该条 事务 中 支持 度 排序 最靠 后 的 频繁 项 而 具体 的 投影 规则 和 并行 投影 一样 即当 投影 到 项 t 时 不 包含 非 频繁 项 支持 度 排序 在 项 t 之后 的 频繁 项和项 t 自身 这样 扫描 一遍 事务 数据库 后 我们 得到 了 初始 的 投影 数据库 接着 我们 先 在 支持 度 最小 的 投影 数据库 上 应用 FP - tree 算法 在 本例 中 即先 处理 到 I7 的 投影 数据库 因为 其 初始 数据 信息 是 完整 的 处理 完到 I7 的 投影 数据库 后 我们 需要 将 该 投影 数据库 中 的 每个 事务 继续 按 上述 规则 进行 投影 以 确保 下 一个 被 处理 的 投影 数据库 也 拥有 完整 的 数据 信息 从而 避免 遗漏 如图所示 处理 完到 I7 的 投影 数据库 后 需要 将 第一个 事务 { I1 ,   I3 } 继续 投影 投影 到 该 事务 中 支持 度 最小 的 I3 的 投影 数据库 上 得到 { I1 } 第二个 事务 { I2 } 只有 一个 项 无需 投影 因为 投影 到 I2 上 也 只是 空集 第三个 事务 { I2 ,   I3 } 则 需要 投影 到 I2 的 投影 数据库 上 得到 { I3 } 然后 我们 便 可以 处理 到 I2 的 投影 数据库 挖掘 结束 后 同样 需要 将 每个 事务 继续 投影 以 确保 之后 处理 的 数据库 拥有 完整 的 数据 信息 具体 过程 不再 赘述 当 全部 投影 数据库 处理 完后 合并 挖掘 结果 便 得到 所有 的 频繁 项集 

图 18 - 10     分区 投影 过程 
在 分区 投影 中 投影 数据库 的 总 大小 小于 原始 数据库 克服 了 并行 投影 中 空间 浪费 的 缺点 并且 它 通常 只 需要 较少 的 内存 和 I / O 操作 不过 分区 投影 必须 以 特定 的 顺序 依次 处理 这些 投影 数据库 并且 需要 进行 多次 投影 但 总体 来说 分区 投影 的 内存 需求 较 低 更 适合 在 实际 应用 中 使用 

18.2 . 3   Eclat 算法 
这 一节 我们 将 介绍 Eclat Equivalence   CLAss   Transformation 算法 也 叫做 等价 类 变换 算法 它 与 前面 介绍 的 两个 算法 不同 它 使用 垂直 数据格式 来 挖掘 频繁 项集 而 Apriori 算法 和 FP - tree 算法 都 是 使用 水平 数据格式 来 挖掘 频繁 项集 那么 什么 是 水平 数据格式 和 垂直 数据格式 呢 下面 我们 以 具体 的 例子 来 表述 
如表 18 - 2 所示 的 数据格式 为 水平 数据格式 即形 如 { TID itemset } 的 数据格式 其中 第一 列为 事务 标识号 第二 列为 事务 涉及 的 项集 而 如下 表 18 - 4 所示 形 如 { itemset TID } 的 数据格式 被 称为 垂直 数据格式 即 第一 列为 项集 第二 列为 包含 该项 集 的 事务 标识号 的 集合 
表 18 - 4   垂直 数据格式 表示 的 事务 数据库 


理解 了 垂直 数据格式 我们 来 介绍 Eclat 算法 的 基本 思想 和 Apriori 算法 类似 Eclat 算法 也 是 通过 逐层 迭代 来 产生 频繁 项集 即 通过 频繁 k - 项集 的 集合 L _ k 来 生成 L _ ( k + 1 ) 其中 同样 利用 了 18.2 . 1 小节 中 介绍 的 先验 原理 但是 挖掘 的 数据格式 不同 每次 迭代 产生 频繁 项集 的 过程 自然 也 不同 在 垂直 数据格式 中 项集 的 支持 度 很 容易 得到 即 TID 集 的 长度 得到 频繁 k - 项集 后 我们 对 TID 集取 交集 对项 集取 并 集 再 计算 对应 的 k + 1 项集 的 支持 度 与 最小 支持 度 阈值 比较 就 可以 得到 频繁 k + 1 - 项集 的 集合 L _ ( k + 1 ) 如此 继续下去 k 逐渐 递增 直到 不再 产生 频繁 项集 为止 
下面 我们 就 以表 18.2 的 数据 为例 设定 最小 支持 度 计数 为 3 来 介绍 Eclat 算法 的 执行 流程 第一步 扫描 一次 事务 数据库 将 水平 格式 数据 转换 为 垂直 格式 得到 表 18 - 4 所示 数据 对 每行 项集 计算 TID 长度 即 为 相应 的 支持 度 计数 与 最小 支持 度 计数 比较 得到 频繁 1 - 项集 的 集合 L _ 1 然后 对 全部 频繁 项集 两 两求 并 集 同时 对 它们 的 TID 集两 两求 交集 得到 垂直 数据格式 的 2 - 项集 
表 18 - 5   垂直 数据格式 表示 的 2 - 项集 

根据 表 18 - 5 很 容易 得到 每个 2 - 项集 的 支持 度 然后 与 最小 支持 度 计数 比较 后 得到 频繁 2 - 项集 如表 18 - 6 所示 接着 我们 要 通过 L _ 2 来 生成 L _ 3 由于 并非 所有 的 2 - 项集 都 是 频繁 项集 这时 先验 原理 就 派上用场 了 根据 先验 原理 只有 每个 2 - 项集 子集 都 是 频繁 项集 的 3 - 项集 才 可能 是 频繁 3 - 项集 这样 我们 得到 四个 候选 3 - 项集 即 { I1 ,   I3 ,   I5 } ,   { I1 ,   I3 ,   I6 } ,   { I1 ,   I5 ,   I6 } ,   { I3 ,   I5 ,   I6 } 对 每个 候选 3 - 项集 取 它 的 任意 两个 2 - 项集 对项 集作 并 运算 对 TID 集作交 运算 结果 如表 18 - 7 所示 
表 18 - 6   垂直 数据格式 表示 的 频繁 2 - 项集 

表 18 - 7   垂直 数据格式 表示 的 3 - 项集 

其中 项集 { I1 ,   I5 ,   I6 } 和 { I3 ,   I5 ,   I6 } 满足 最小 支持 度 计数 所以 是 频繁 3 - 项集 它们 构成 了 L _ 3 然后 我们 要 通过 L _ 3 来 生成 L _ 4 其中 只有 一个 候选 4 - 项集 即 { I1 ,   I3 ,   I5 ,   I6 } 其 支持 度 计数 为 1 故剪 去 最后 由于 L _ 4 为 空集 所以 无法 再 构造 5 - 项集 算法 执行 结束 我们 也 找到 了 全部 的 频繁 项集 和 前 两个 算法 得到 的 结果 相同 
下面 我们 给出 Eclat 算法 的 伪 代码 实现 如下 

使用 垂直 数据格式 的 优点 很 明显 在 计算 项集 的 支持 度时 不 需要 扫描 事务 数据库 只 需要 计算 TID 集 的 长度 即可 而且 在 由 L _ k 计算 L _ ( k + 1 ) 时 利用 先验 原理 剪枝 效果 很 好 能 有效 降低 候选 项集 数量 但是 当 TID 集 长度 较大 时 其交 运算 的 开销 较大 且会 占用 大量 内存空间 
想要 对 Eclat 算法 的 上述 缺点 进行 优化 我们 可以 采用 差集 技术 差集 顾名思义 就是 两个 集合 之差 而 我们 可以 通过 记录 k + 1 - 项集 与 相对 应 的 k - 项集 之间 的 TID 集 的 差集 如上 例中 { I1 } 的 TID 集为 { T001 ,   T004 ,   T005 ,   T007 ,   T008 ,   T010 } ,   { I1 ,   I3 } 的 TID 集为 {   T004 ,   T007 ,   T008 } 两者 的 差集 即 为 { T001 ,   T005 ,   T010 } 这样 只 需 记录 差集 而 不必 完全 存储 两个 TID 集 相关 的 优化 算法 有 GenMax 算法 它 利用 差集 进行 快速 频繁 项集 检验 降低 TID 集 的 存储 开销 和 交 运算 的 计算 开销 当 数据 集较 稠密 或 数据 集中 包含 较 多长 模式 时 差集 技术 的 作用 尤为 明显 [ l5 ] 
18.2 . 4 优缺点 讨论 
现在 相信 你 对 Apriori 算法 FP - tree 算法 和 Eclat 算法 的 原理 已经 比较 熟悉 了 下面 我们 将 从 不同 角度 对 这 三种 算法 的 标准 实现 不 考虑 各种 优化 技术 进行 比较 带 你 一起 梳理 它们 各自 的 优势 和 缺陷 以及 适合 的 应用 场景 使 你 对 它们 的 了解 更加 全面 清晰 
Apriori 算法 原理 简洁 易于 实现 十分 适合 稀疏 数据 集中 的 频繁 模式 挖掘 而 当待 挖掘 的 数据量 较大 时 虽然 与 穷举法 相比 Apriori 算法 有 显著 的 性能 提高 但是 其 速度 仍 不能 令人满意 且 其 空间 复杂度 较 高 尤其 是 当 L _ 1 较大 时 L _ 2 的 数量 也 会 很大 每次 迭代 搜索 下 一层 频繁 项集时 它 都 重新 需要 扫描 一遍 数据 集 从而 产生 不可 忽视 的 I / O 开销 
FP - tree 算法 使用 一个 高度 压缩 的 数据结构 存储 了 事务 数据库 的 信息 整个 过程 只 需 扫描 两次 数据 集 相关 研究 表明 在 挖掘 某些 事务 数据 集时 FP - tree 算法 比 Apriori 算法 快 多个 数量级 不过 由于 FP - tree 算法 在 执行 过程 中 需要 递归 生成 条件 数据库 和 条件 FP - tree 所以 内存 开销 也 较大 且 当 生成 的 FP - tree 十分 茂盛 时 如满 前缀 树 算法 产生 的 子 问题 数量 会 剧增 导致 性能 显著 下降 需要 注意 的 是 FP - tree 算法 和 Apriori 算法 都 只能 用于 挖掘 单维 的 布尔 型 关联 规则 
Eclat 算法 是 一种 深度 优先 算法 利用 了 倒排 思想 只 需要 扫描 一次 原始数据 集 它 的 性能 主要 取决于 垂直 数据格式 表示 下 的 TID 集 长度 当 TID 集较 短时 算法 性能 不逊于 FP - tree 算法 而 当 TID 集 很 长时 不仅 需要 大量 存储空间 其交 运算 耗时 也 会 随之 增加 导致 算法 效率 下降 
随着 数据 环境 日益 复杂 上述 算法 很难 直接 应用 但 它们 背后 的 思想 仍然 值得 我们 学习 对 我们 理解 频繁 项集 挖掘 问题 有 重要 的 帮助 

18.3   关联 规则 生成 及 相关性 评价 
从 频繁 项集里 提取 关联 规则 的 过程 中 可能 产生 大量 关联 规则 而 其中 很大 一部分 是 人们 所 不感兴趣 的 且 某项 关联 规则 是否 有趣 也 会 因人而异 如何 建立 有效 且 广泛 适用 的 关联 规则 评估 标准 是 一个 重要 且 有趣 的 问题 
下面 我们 将 介绍 从 频繁 项集 产生 关联 规则 的 过程 并 对 现有 的 多种 关联 规则 评估 方法 进行 阐释 和 比较 
18.3 . 1 候选 关联 规则 生成 
前面 我们 介绍 了 三种 频繁 项集 挖掘 方法 而 得到 频繁 项集 后 下 一步 就是 根据 这些 频繁 项集来 产生 关联 规则 并 从中 筛选 出强 关联 规则 即 满足 最小 支持 度 阈值 和 最小 置信度 阈值 的 关联 规则 在 18.1 . 3 小节 中 我们 使用 了 枚举法 来 产生 关联 规则 介绍 了 产生 关联 规则 的 基本 过程 下面 我们 将 更 详细 地 介绍 这一 过程 及 相关 改进 
让 我们 回忆 一下 从 频繁 项集 产生 关联 规则 的 原理 首先 将 频繁 项集 Y 划分 成 两个 非 空子 集 X 和 Y - X 得到 候选 关联 规则 X → Y - X 然后 计算 该 候选 关联 规则 的 置信度 若 满足 最小 置信度 阈值 则 该 关联 规则 就是 强 关联 规则 否则 舍弃 其中 X 和 Y - X 必须 是非 空子 集 因为 ∅ → Y 和 Y → ∅ 没有 实际意义 
以 从表 18 - 2 数据 中 挖掘 到 的 频繁 3 - 项集 为例 令 Y = { I3 ,   I5 ,   I6 } 我们 可以 得到 如表 18 - 8 前 三列 所示 6 种 不同 的 划分 
表 18 - 8   由 频繁 项集 Y 产生 的 候选 关联 规则 

然后 依次 计算 每个 候选 关联 规则 的 置信度 如表 18 - 8 所示 而 我们 设定 的 最小 置信度 阈值 为 0.70 所以 我们 能 从 该 频繁 3 - 项 集中 得到 2 条强 关联 规则 分别 是 { I3 ,   I5 } → { I6 } 和 { I3 ,   I6 } → { I5 } 
对 每个 频繁 k - 项集 k ≥ 2 执行 上述 过程 就 能 得到 全部 强 关联 规则 而 每个 频繁 k - 项集 能 产生 2 ^ k - 2 个 候选 关联 规则 不仅 占用 大量 内存空间 也 会 导致 计算 过程 耗时 较长 下面 我们 来 介绍 一种 有效 的 剪枝 方法 从而 减少 候选 关联 规则 数量 提高效率 
18.3 . 2 候选 关联 规则 的 剪枝 
在 生成 频繁 项集 的 过程 中 我们 利用 支持 度 度量 的 反 单调 性 即 先验 原理 有效 减少 了 候选 项集 的 数量 那么 在 候选 关联 规则 的 剪枝 中 能否 利用 置信度 度量 进行 类似 的 剪枝 呢 要 考察 这 一点 我们 首先 要 尝试 证明 置信度 度量 是否 同样 具有 反 单调 性 假设 存在 一条 规则 X → Y 其 置信度 为 c _ 1 则 令 x ⊑ X y ⊑ Y 从而 得到 规则 x → y 其 置信度 为 c _ 2 若 置信度 度量 满足 反 单调 性 则 c _ 2 ≥ c _ 1 须恒 成立 遗憾 的 是 c _ 2 与 c _ 1 之间 的 大小 关系 是 不 确定 的 大于 小于 和 等于 都 有 可能 
表 18 - 8   置信度 度量 不 满足 反 单调 性 的 案例 

幸运 的 是 置信度 度量 满足 定理 18.2 能够 帮助 我们 利用 它 进行 剪枝 具体 如下 
定理   18.2     令 Y 是 一个 项集 且 X ⊑ Y 如果 规则 X → Y - X 不 满足 置信度 阈值 则 形如 T → Y - T 的 规则 也 一定 不 满足 置信度 阈值 其中 T ⊑ X 
该 定理 很 容易 证明 由于 T ⊑ X 所以 σ ( T ) ≥ σ ( X ) 而 规则 T → Y - T 的 置信度 和 规则 X → Y - X 的 置信度 分别 是 ( σ ( Y ) ) / ( σ ( T ) ) 和 ( σ ( Y ) ) / ( σ ( X ) ) 故 前者 的 置信度 不 可能 大于 后者 
那么 下面 我们 就 来 介绍 如何 利用 置信度 度量 的 这个 性质 进行 候选 关联 规则 的 剪枝 
类似 于 Apriori 算法 我们 通过 逐层 迭代 来 产生 关联 规则 关联 规则 后件 中 的 项数 随 层数 递增 同样 以 频繁 3 - 项集 { I3 ,   I5 ,   I6 } 为例 如图 18 - 8 所示 该 频繁 3 - 项集 能 产生 6 条 候选 关联 规则 其中 三条 规则 的 后 件数 为 1 另外 三条 的 后 件数 为 2 

图 18 - 11     使用 置信度 度量 对 关联 规则 进行 剪枝 
其中 后 件数 为 1 的 三条 关联 规则 中 规则 { I5 ,   I6 } → { I1 } 的 置信度 不 满足 最小 置信度 阈值 则 剪 去 该 关联 规则 由 剩余 的 2 条强 关联 规则 生成 新 的 候选 规则 具体 过程 是 合并 这 两条 规则 的 后件 从而 产生 下 一层 的 关联 规则 { I3 } → { I5 ,   I6 } 在 图 18 - 8 中 我们 绘出 了 全部 的 关联 规则 实际上 当 规则 { I5 ,   I6 } → { I1 } 被 剪 去 时 就 不 需要 再 由 其 产生 下 一层 关联 规则 相当于 直接 剪掉 了 从 该 结点 生成 的 全部 子 关联 规则 即图 18 - 8 中虚 线圈 起来 的 部分 这样 原本 的 6 条 候选 关联 规则 就 剪 去 了 3 条 当 k 值 更 大时 对于 频繁 k - 项集 的 剪枝 效果 会 更 明显 能 有效 减少 候选 关联 规则 的 数目 
现在 我们 来 概括 一下 由 频繁 项集 生成 关联 规则 的 过程 首先 对 每个 频繁 k - 项集 k ≥ 2 按 上述 方式 逐层 构造 关联 规则 计算 它们 的 置信度 若 某条 关联 规则 不 满足 最小 置信度 阈值 则 在 下 一轮 迭代 中 不再 考虑 该 关联 规则 由 剩余 的 强 关联 规则 来 产生 下 一层 的 候选 关联 规则 直到 产生 的 规则 中后 件 的 项数 等于 k - 1 时 即可 停止 迭代 此时 我们 就 得到 了 全部 的 强 关联 规则 
到 此 我们 的 任务 还 没有 结束 并非 所有 的 强 关联 规则 都 是 有趣 的 甚至 有些 强 关联 规则 是 有 误导 的 下 一节 我们 将 介绍 更加 客观 实用 的 规则 评估 方法 以 帮助 我们 进一步 筛选 到 我们 所 需要 的 有 意义 的 强 关联 规则 
18.3 . 3 相关性 评价 指标 
对 关联 规则 是否 有趣 的 评估 方法 总体 可以 分为 两类 第一类 是 基于 数据 驱动 的 客观 兴趣 度 度量 第二类 则 是 通过 主观 论据 建立 的 主观 兴趣 度 度量 由于 主观 兴趣 度 度量 通常 因 用户 而异 若要 将 其 加入 规则 评估 方法 中 需要 来自 对应 领域 的 专家 经验 与 判断 比较 困难 所以 我们 这一 小节 的 重点 是 客观 兴趣 度 度量 它 能 利用 统计 方法 提供 有效 的 评估 手段 帮助 我们 去除 无趣 的 关联 规则 
在 频繁 项集 挖掘 和 关联 规则 生成 的 过程 中 我们 用到 了 支持 度 度量 和 置信度 度量 这 两者 都 是 客观 度量 通常 称为 支持 度 - 置信度 框架 它 能 帮助 我们 做出 一些 筛选 但是 它 同样 具有 不小 的 局限性 基于 该 框架 我们 可能 会 疏忽 一些 潜在 的 有 意义 的 关联 模式 也 可能 得到 一些 有 误导 的 强 关联 规则 下面 我们 举例说明 
表 18 - 9   关于 喝 绿茶 与 喝咖啡 的 千人 统计 
[ l6 ] 
假设 最小 支持 度 阈值 和 最小 置信度 阈值 分别 是 10% 和 70% 
令 I1 = 爱喝 绿茶 I2 = 爱 喝咖啡 考察 关联 规则 { I1 } → { I2 } 其 支持 度为 15% 置信度 为 75% 按照 支持 度 - 置信度 框架 评估 则 该 规则 是 强 关联 规则 然而 该 关联 规则 具有 误导性 在 全体 测试 人群 中 爱 喝咖啡 的 人 占 比达 80% 而 其中 同时 也 爱 喝茶 的 人 只 占 75% 即 若 一个 人爱 喝茶 则 他 爱 喝咖啡 的 可能性 反而 从 80% 下降 到 了 75% 这是 一个 有 误导性 的 强 规则 所以 我们 需要 寻找 更 可信 的 评估 度量 方法 
第一种 方法 是 使用 相关性 度量 对 基础 的 支持 度 - 置信度 框架 进行 扩充 即 在 原来 的 度量 基础 上 考虑 关联 规则 的 前件 和 后件 之间 的 相关性 所以 关联 规则 的 表示 形式 将 有所 变化 具体 如下 
X → Y   [   support ,   confidence ,   correlation   ] 
但 相关性 度量 有 多种 方式 这一 小节 我们 将 介绍 提升 度 和 和 和 ^ 2 两种 相关性 度量 方式 
首先 介绍 提升 度 令 P ( X ) 表示 事件 X 发生 的 概率 假设 有 前件 A 和 后件 B 若 满足 P ( A ∪ B ) = P ( A ) × P ( B ) 则 前件 A 和 后件 B 是 统计 独立 的 即 A 的 发生 和 B 的 发生 是 互不 影响 且 没有 联系 的 将 P ( A ) × P ( B ) 的 值 记为 P _ std 若 不 满足 则 称 A 与 B 是 依赖 的 或 相关 的 两者 同时 发生 的 概率 即为 P ( A ∪ B ) A 发生 和 B 发生 之间 的 提升 度 就 可以 定义 如下 
lift ( A ,   B ) = ( P ( A ∪ B ) ) / P _ std   = ( P ( A ∪ B ) ) / ( P ( A ) × P ( B ) ) 
该 定义 很 容易 推广 到 两项 以上 的 情况 如下 
lift ( X _ 1 ,   X _ 2 , , X _ n   ) = ( P ( X _ 1 ∪ X _ 2 ∪ ∪ X _ n ) ) / ( P ( X _ 1   ) × P ( X _ 2   ) × × P ( X _ n ) ) 
下面 对 提升 度 进行 简单 的 解释 
lift ( A ,   B ) { █ ( = 1 A 和 B 是 独立 的 @ > 1 A 和 B 呈 正 相关 @ < 1 A 和 B 呈 负相关 ) ┤ 
负相关 是 指 A 的 发生 可能 导致 B 不 发生 所以 提升 度 小于 1 的 关联 规则 通常 会 被 拒绝 让 我们 重新 考察 上述 咖啡 和 绿茶 的 案例 关联 规则 { I1 } → { I2 } 的 提升 度为 0.15 / ( 0.2 × 0.8 ) = 0.9375 说明 前件 和 后件 之间 呈 负相关 所以 该 关联 规则 会 被 拒绝 
回顾 置信度 的 计算公式 不难 发现 置信度 度量 只 考虑 了 P ( A ∪ B ) 和 P ( A ) 之间 的 偏差 而 提升 度则 考虑 的 是 P ( A ∪ B ) 和 P _ std 之间 的 偏差 所以 置信度 不能 解释 后件 的 支持 度 从而 会 导致 产生 出 有 误导性 的 关联 规则 的 情况 
下面 我们 将 介绍 使用 下 ^ 2 分析 来 度量 相关性 首先 对 关联 规则 X → Y 我们 假设 两者 统计 独立 从而 计算 出 期望值 而原 统计 值则 称为 观测 值 从而 计算 ^ 2 值 如下 
^ 2 = ∑ ▒ ( 观测 值 - 期望值 ) ^ 2 / 期望值 
^ 2 值 能够 反映 理论值 和 实际 观测 值 的 差异 程度 得到 得 ^ 2 值后 我们 不能 像 提升 度 那样 直接 与 1 比较 从而 得出结论 而是 需要 查询 比 ^ 2 分布 的 临界值 表 然后 再 根据 用户 设定 的 显著性 水平 α 通常 为 0.05 判断 是否 拒绝 该 关联 规则 在 此 我们 不 作 详细描述 有 兴趣 的 同学 可以 参考 [ l7 ] 
同样 重新 考察 上述 咖啡 与 绿茶 的 案例 如果 喝 绿茶 与 喝咖啡 是 统计 独立 的 那么 按照 表 18 - 9 中 的 数据 爱 喝咖啡 的 期望 人数 占 比 为 ( 650 + 150 ) / 1000 = 0.8 那么 爱喝 绿茶 的 人 中 还 爱 喝咖啡 的 人数 的 期望值 就是 200 × 0.8 = 160 同理 按照 期望 占 比 重新 计算 该 表格 数据 后 得到 对应 的 期望值 表格 如下 
表 18 - 9   关于 喝 绿茶 与 喝咖啡 的 千人 统计 

然后 按照 然 ^ 2 值 计算公式 计算 如下 
^ 2 = ( 150 - 160 ) ^ 2 / 160 + ( 50 - 40 ) ^ 2 / 40 + ( 650 - 640 ) ^ 2 / 640 + ( 150 - 160 ) ^ 2 / 160 = 3.90625 
查阅 查 ^ 2 分布 的 临界值 表 两者 以 95% 的 概率 不 相关 的 临界值 是 3.84 由于 ^ 2 值 大于 该 临界值 所以 爱喝 绿茶 和 爱 喝咖啡 之间 是 有 关联 的 且 爱喝 绿茶 爱 喝咖啡 处 的 观测 值 150 小于 期望值 160 说明 两者 是 负相关 的 与 使用 提升 度 得到 的 分析 结果 相同 
除此之外 还有 其他 的 评估 度量 方式 值得 我们 了解 下面 我们 将 介绍 四种 具有 零 不变性 的 度量 全 置信度 最大 置信度 Kulczynski 和 余弦 
首先 介绍 全 置信度 两个 项集 A 和 B 的 全 置信度 定义 如下 
all _ confidence ( A ,   B ) = ( sup ⁡ ( A ∪ B ) ) / ( max ⁡ { sup ⁡ ( A ) ,   sup ⁡ ( B ) } ) 
全 置信度 计算公式 的 分子 是 项集 A 和 B 同时 出现 的 支持 度 分母 则 是 项 集中 的 最大 支持 度 由于 支持 度 度量 具有 反 单调 性 所以 sup ⁡ ( A ∪ B ) ≤ min ⁡ { sup ⁡ ( A ) ,   sup ⁡ ( B ) } 即全 置信度 是 项集 { A ,   B } 产生 的 关联 规则 A → B 和 B → A 中 的 置信度 下界 这 也 是 全 置信度 的 特点 即 
all _ confidence ( A ,   B ) ≤ ( min ⁡ { sup ⁡ ( A ) ,   sup ⁡ ( B ) } ) / ( max ⁡ { sup ⁡ ( A ) ,   sup ⁡ ( B ) } ) 
值得注意 的 是 虽然 置信度 度量 不 具有 反 单调 性 但是 全 置信度 度量 是 具有 反 单调 性 的 所以 可以 直接 在 前述 的 挖掘 算法 中 用于 剪枝 策略 
然后 是 最大 置信度 两个 项集 A 和 B 的 最大 置信度 定义 如下 
max _ confidence ( A ,   B ) = ( sup ⁡ ( A ∪ B ) ) / ( min ⁡ { sup ⁡ ( A ) ,   sup ⁡ ( B ) } ) 
与 全 置信度 计算公式 略有不同 最大 置信度 计算公式 的 分母 是 项 集中 的 最小 支持 度 所以 它 的 含义 是 项集 { A ,   B } 产生 的 关联 规则 A → B 和 B → A 的 最大 置信度 
下 一个 是 Kulczynski Kulc 度量 由 波兰 数学家 S .   Kulczynski 于 1927 年 提出 项集 A 和 B 的 Kulc 度量 定义 如下 
Kulc ( A ,   B ) = 1 / 2 [ conf ( A → B ) + conf ( B → A ) ] = 1 / 2 [ sup ⁡ ( A ∪ B ) / sup ⁡ ( A )   + sup ⁡ ( A ∪ B ) / sup ⁡ ( B )   ] 
由 计算公式 不难看出 Kulc 度量 是 项集 { A ,   B } 产生 的 关联 规则 A → B 和 B → A 的 各自 置信度 的 平均值 
最后 是 余弦 度量 项集 A 和 B 的 余弦 度量 定义 如下 
consine ( A ,   B ) = ( sup ⁡ ( A ∪ B ) ) / √ ( sup ⁡ ( A ) × sup ⁡ ( B ) ) = ( P ( A ∪ B ) ) / √ ( P ( A ) × P ( B ) ) 
细心 的 同学 可能 注意 到 了 余弦 度量 和 提升 度 的 计算公式 十分 相近 只是 余弦 在 分母 处多 了 取 平方根 的 计算 所以 余弦 度量 也 称为 调和 提升 度 度量 而 通过 取 平方根 余弦 度量 消除 了 事务 总 个数 的 影响 而 只会 受到 A B A ∪ B 的 支持 度 的 影响 
实际上 上述 前 三种 度量 也 具备 余弦 度量 的 这个 性质 即 度量 值不受 事务 总 个数 的 影响 此外 这 四种 度量 的 取值 范围 都 是 [ 0 ,   1 ] 且 含义 都 如下 
度量 值 ( A ,   B ) { █ ( = 0.5 A 和 B 中性 关联 @ > 0.5 A 和 B 呈 正 相关 @ < 0.5 A 和 B 呈 负相关 ) ┤ 
至此 除了 支持 度 度量 和 置信度 度量 我们 已经 介绍 了 6 种新 的 评估 方法 那么 这些 方法 孰 优孰劣 呢 下面 我们 将 通过 特殊 的 案例 进行 说明 并 比较 这 6 种 评估 方法 的 性能 
让 我们 依旧 以 喝咖啡 和 喝 绿茶 为例 爱 喝咖啡 的 人群 以 c coffee 表示 不爱 喝咖啡 的 人群 则 以 c   ̅ 表示 同理 爱 喝茶 和 不 爱 喝茶 的 人群 分别 以 t tea 和 t   ̅ 表示 而 既 爱 喝咖啡 又 爱喝 绿茶 的 人群 就 可以 用 ct 表示 其他 情况 同理 
假设 我们 调查 得到 一个 数据 集 其中 ct = c   ̅ t = ct   ̅ = 100 ( ct )   ̅ = 10000 此时 可以 计算 得到 如下 表 所示 结果 
表 18 - 10   不同 评估 方法 的 度量 值 

不难 发现 对于 该 数据 提升 度 和 不 ^ 2 都 认为 爱 喝茶 和 爱 喝咖啡 之间 具有 强正 相关 而 另外 四种 评估 方法 都 认为 爱 喝茶 和 爱 喝咖啡 之间 是 中性 关联 那么 谁 的 判断 比较 正确 呢 让 我们 详细分析 一下 首先 观察 该 数据 集 样本 总数 为 10300 但是 其中 ( ct )   ̅ 的 样本 有 10000 显著 地 大于 另外 三类 样本数 而 提升 度 和 ^ 2 都 对 ( ct )   ̅ 样本 十分 敏感 所以 产生 了 不 稳定 的 结果 在 很多 实际 数据 中 类似 ( ct )   ̅ 这类 不 包含 任何 我们 感兴趣 的 项 的 样本 通常 都 远大于 其他 样本 所以 我们 期望 的 度量 应该 能不受 此类 样本 影响 从而 给出 稳定 且 符合 常理 的 结果 那 为何 全 置信度 最大 置信度 Kulc 度量 和 余弦 度量 的 结果 都 是 0.50 呢 因为 在 这个 数据 集中 ct = c   ̅ t = ct   ̅ = 100 即 ct / ( c   ̅ t ) = ct / ( ct   ̅   ) = 1 这 说明 如果 一个 人 喜欢 喝 绿茶 那 他 同时 还 喜欢 喝咖啡 的 概率 是 50% 如果 他 喜欢 喝咖啡 那 他 还 喜欢 喝 绿茶 的 概率 也 是 50% 而 这 四种 度量 都 没有 受到 ( ct )   ̅ 样本 的 影响 故 正确 地 显示 了 两者 呈 中性 关联 
让 我们 更 准确 地 阐述 后 四种 度量 都 具备 的 这种 实用 的 性质 如 ( ct )   ̅ 这 类 样本 我们 将 其 称为 零 事务 即 不 包含 任何 用户 感兴趣 的 项集 的 事务 许多 大型 事务 数据库 中 零 事务 的 个数 可能 远远 超过 其他 事务 的 总和 而 如果 一种 评估 方法 能不受 零 事务 个数 的 影响 即 度量 值 独立 于 零 事务 个数 那么 我们 称该 评估 方法 具有 零 不变性 由于 我们 探索 的 是 用户 感兴趣 的 项集 之间 的 关联 规则 所以 在 大型 数据 集中 我们 通常 更 倾向 于 使用 具有 零 不变性 的 评估 方法 相比 于 提升 度 和 ^ 2 这类 不 具有 零 不变性 的 度量 前者 对 识别 出 有 意义 的 关联 规则 更 有 帮助 
而 这些 零 不变性 度量 之间 又 是 孰 优孰劣 呢 [ l8 ] 

18.4   多维度 量化 关联 规则 挖掘 
前面 我们 所 介绍 的 是 单 维度 布尔 型 关联 规则 挖掘 而 在 实际 应用 中 我们 获得 的 大都 是 更加 复杂 的 数据 涉及 的 挖掘 方法 也 更 多样 在 这 一 小节 我们 将 向 你 介绍 多维度 关联 规则 挖掘 和 量化 关联 规则 挖掘 的 基本概念 和 常见 方法 使 你 对 高级 模式 挖掘 产生 基本 的 认识 

18.4 . 1 多维度 关联 规则 挖掘   
关于 什么 是 多维 关联 规则 这个 问题 我们 在 18.1 . 2 小节 中 已经 作 了 介绍 简单 来说 规则 中 涉及 的 谓词 多于 一个 便是 多维 关联 规则 例如 若 我们 想 表达 如下 关联 关系 深圳 的 35 岁 以上 的 教师 倾向 于 购买 茶壶 则 可以 书写 为 
location ( X ,   " Shenzhen "   )         age ( X ,   " " ≥ 35 \ " "   )         occupation ( X ,   " teacher " ) → buys ( X ,   " teapot " ) 
该 关联 规则 涉及 4 个 谓词 这 4 个 谓词 { location ,   age ,   occupation ,     buys } 则 构成 一个 4 - 谓词 集 更进一步 地说 这 4 个 谓词 都 是 不 重复 的 所以 该 关联 规则 是 维间 关联 规则 即 具有 不 重复 谓词 的 多维 关联 规则 而 包含 重复 谓词 的 多维 关联 规则 被 称为 混合 维 关联 规则 修改 上 例 关联 关系 深圳 的 35 岁 以上 的 人群 中 购买 了 茶叶 的 倾向 于 购买 茶壶 可 表示 如下 
location ( X ,   " Shenzhen "   )         age ( X ,   " " ≥ 35 \ " "   )         buys ( X ,   " tea " ) → buys ( X ,   " teapot " ) 
单维 关联 规则 的 挖掘 对象 是 事务 数据 而 多维 关联 规则 的 挖掘 对象 则 是 更加 复杂 庞大 的 数据仓库 或 关系数据库 等 在 数据库 中 一条 记录 的 属性 可能 是 标称 的 或 量化 的 标称 属性 的 取值 范围 是 有限 多个 可能 值 的 集合 且值 之间 是 无序 的 如 occupation location 就是 标称 属性 量化 属性 的 值 则 是 数值 的 且值 之间 存在 隐序 如 age income 等 属性 在 多维 关联 规则 挖掘 中 我们 搜寻 的 不再 是 频繁 项集 而是 频繁 谓词 集 频繁 k - 谓词 集 的 集合 同样 以 L _ k 表示 
多维 关联 规则 的 挖掘 方法 可以 根据 它 对 量化 属性 的 处理 方式 分为 三种 下面 我们 将 一一 介绍 但 不会 涉及 到 方法 的 具体 细节 
  使用 量化 属性 的 静态 离散 化 挖掘 多维 关联 规则 
即 使用 预定 义 的 概念 分组 对 量化 属性 离散 化 在 进行 挖掘 之前 我们 首先 使用 自定义 的 分组 替换 掉 原本 的 量化 属性 比如 对于 数值 属性 我们 可以 通过 预先 划分 的 区间 值 如 [ 10 ,   20 ) , [ 20 ,   30 ) ,   [ 30 ,   40 ) 等 将 原本 的 数值 属性 转换 为 相应 的 区间 每个 区间 包含 区间 标号 可以 看作 一个 分组 这样 就 能 以 处理 标称 属性 的 方式 对 量化 属性 进行 处理 了 这种 离散 化是 静态 的 必须 在 挖掘 之前 进行 
  挖掘 量化 关联 规则 
即 根据 数据 的 分布 情况 将 量化 属性 离散 化 或 聚类 到 箱 和 第一种 方法 不同 该 方法 将 数值 属性 的 值 处理 为 数量 的 形式 而 非 类别 或 区间 且 这种 离散 化是 动态 的 在 数据挖掘 过程 中 可以 进行 自动 调整 比如 相邻 的 箱 可能 合并 自动 调整 的 标准 则 是 预定 义 的 比如 最大化 所得 关联 规则 的 提升 度 ARCS Association   Rule   Clustering   System 就 应用 了 该 方法 它 将 量化 属性 对 映射 到 满足 给定 的 分类 条件 的 2D 栅格 上 然后 使用 聚类 算法 搜索 栅格 点 从而 得到 关联 规则 
  挖掘 基于 距离 的 关联 规则 
该 方法 同样 是 使用 区间 对 量化 属性 离散 化 但 它 不 允许 数据 值 的 近似 这一 方法 考虑 到 了 数据 点 之间 的 距离 因此 得名 且 应用 在 了 两趟 扫描 算法 中 即 在 第一趟 扫描 时 使用 聚类 算法 寻找 出簇 第二趟 扫描 搜索 簇组 以 得到 基于 距离 的 关联 规则 
	 
需要 注意 的 是 我们 介绍 的 上述 方法 可以 用于 多维 关联 规则 挖掘 但 并 不 适合 挖掘 高维 数据 即 维度 达到 数百 甚至 数千 的 数据 如今 虽然 有 一些 方法 可以 用于 挖掘 高维 数据 如 基于 行 枚举 的 模式 增长 方法 以及 挖掘 巨型 模式 的 模式 融合 方法 但是 仍有 很长 的 路 要 走 我们 在 此 则 不作 详细 介绍 

18.4 . 2 量化 关联 规则 挖掘 
量化 关联 规则 的 定义 在 18.1 . 2 小节 中 已经 介绍 过 即 包含 了 量化 的 项 或 属性 的 规则 由于 量化 关联 规则 和 多维 关联 规则 之间 本身 是 有 交叉 的 正如 我们 在 18.2 节中 挖掘 的 单维 布尔 型 关联 规则 我们 现在 讨论 的 是 挖掘 多维 量化 关联 规则 所以 两者 的 挖掘 方法 不必 完全 区分 而 如 18.4 . 1 节 介绍 的 使用 量化 属性 的 静态 离散 化 挖掘 方法 我们 先 将 量化 属性 离散 化到 多个 区间 从而 作为 标称 数据 看待 但 这种 做法 可能 导致 产生 大量 冗余 的 无 意义 的 关联 规则 为了 改善 这一 缺点 我们 接下来 会 介绍 一些 新 的 方法 帮助 我们 能 更 高效 地 发现 有趣 的 关联 规则 
第一种 方法 是 基于 数据 立方体 进行 挖掘 
第二种 方法 是 基于 聚类 进行 挖掘 
第三种 方法 则 是 基于 统计学 理论 来 发现 能 揭示 异常 行为 的 量化 关联 规则 



18.5   时序 关联 规则 挖掘 
在生活中 数据 事件 之间 常常 存在 时间 或 空间 上 的 序数 关系 在 之前 讨论 的 关联 规则 挖掘 中 我们 没有 考虑 数据 中 可能 携带 的 序列 信息 以 前面 的 购物篮 数据 为例 我们 只 考虑 了 顾客 单次 购买 的 商品 之间 的 联系 而 对于 一位 多次 光临 的 顾客 其 每次 购买 的 清单 之间 也 可能 包含 一些 有 意义 的 关联 模式 值得 我们 探究 实际上 许多 数据 在 时间 维度 上 都 会 呈现出 某种 趋势 比较 直观 的 如 股票 数据 和 心电图 数据 等 我们 不能 忽视 时间 信息 而 应该 对 其 善加利用 这 一节 我们 就 将 介绍 时序 关联 规则 的 挖掘 过程 
18.5 . 1 时序 模式 的 定义 
在 之前 介绍 的 关联 规则 的 基础 上 引入 时间 或 空间 维度 便是 序列 模式 而 这 一节 我们 主要 介绍 引入 时间 维度 的 数据挖掘 所以 称为 时序 模式 接下来 我们 首先 需要 了解 一些 基本概念 对 序列 信息 有 一个 清晰 的 认识 
18.1 . 3 节中 的 事务 数据库 中 每 一行 是 一个 事务 每个 事务 有 一个 TID 号 和 对应 的 项集 而 一个 序列 则 是 事务 的 有 序列表 通常 记为 s = < t _ 1   t _ 2   t _ 3   t _ n > 其中 t _ i 表示 一个 事件 集 这里 的 事件 即 相当于 项 在 讨论 序列 时 为了 避免 混淆 我们 通常 称 事务 为 元素 称项 为 事件 即 元素 是 事件 的 集合 序列 是 元素 的 有 序列表 下面 给出 几个 序列 的 例子 
1 某 顾客 在 附近 超市 一个月 的 购买 清单 记录 
< { 牛奶 面包 } { 矿泉水 } { 薯片 方便面 } { 衣架 } { 薯片 } { 清洁球 } > 
2 某校 计算机科学 专业 学生 不 同学 年 参与 的 课程 序列 
< { 高等数学 线性代数 数据结构 } { 概率论 算法 导论 离散数学 } { 操作系统 数据库系统 } { 计算机 体系结构 编译 原理 软件工程 } > 
我们 通常 以 序列 的 长度 来 描述 一个 序列 序列 长度 即 序列 中 元素 的 个数 其中 包含 k 个 元素 的 序列 称为 k - 序列 在 上述 两个 序列 中 序列 1 有 6 个 元素 7 个 事件 是 一个 6 - 序列 序列 2 则 有 4 个 元素 11 个 事件 是 一个 4 - 序列 在 书写 时 元素 通常 用 { } 包盖 而 序列 通常 用 < > 包盖 需要 注意 的 是 我们 不 考虑 同一个 事件 的 数量 故 一个 序列 的 同一个 元素 中 不会 出现 重复 的 事件 但 一个 序列 的 不同 元素 中 可以 出现 相同 的 事件 如 某次 购物 中 一 顾客 在 超市 先 购买 了 1 盒 牛奶 再 购买 了 2 块 面包 我们 不会 将 其 记为 { 牛奶 面包 面包 } 而是 记 为 { 牛奶 面包 } 
此外 我们 还 需要 定义 序列 之间 的 包含 关系 与 项 集中 的 包含 关系 略有不同 序列 之间 的 包含 关系 略微 复杂 一些 具体 如下 
对 序列 T = < t _ 1   t _ 2   t _ 3   t _ n > 和 序列 S = < s _ 1   s _ 2   s _ 3   s _ m > 其中 n ≤ m 如果 存在 整数 1 ≤ j _ 1 < j _ 2 < < j _ n ≤ m 使得 t _ i ⊑ s _ ( j _ i   ) i = 1 , 2 , , n 那么 序列 T 就是 序列 S 的 子 序列 下面 给出 一些 简单 的 示例 


18.5 . 2 时序 模式 的 基本 框架 
在 时序 数据 中 我们 要 挖掘 的 是 频繁 序列 和 挖掘 频繁 项集 类似 我们 首先 需要 定义 一个 最小 支持 度 阈值 minsup 对于 一个 序列 来说 它 的 支持 度 是 序列 数据库 中 包含 该 序列 的 序列 所 占 的 比例 如果 它 的 支持 度 大于 设定 的 最小 支持 度 阈值 就 称 其 为 频繁 序列 
表 18 - 11   一个 序列 数据库 示例 

在 该 序列 数据库 中 每 一行 是 一个 序列 每个 序列 包含 多个 事件 集 假设 最小 支持 度 阈值 为 50% 暂且 列出 部分 候选 序列 的 支持 度 如 上 右图 所示 对于 序列 < { b } { c } > 它 是 S001 S003 S004 的 子 序列 所以 支持 度为 60% 需要 注意 的 是 它 并 不是 S002 的 子 序列 因为 时序 数据 本身 还 包含 时间 信息 在 S002 中 元素 { a ,   c } 出现 在 { b ,   g } 之前 所以 < { c } { b } > 是 S002 的 子 序列 而 < { b } { c } > 则 不是 对于 序列 < { c ,   g } > 它 是 S003 的 子 序列 而 并 不是 S002 的 子 序列 同样 是因为 时间 信息 的 冲突 < { c ,   g } > 表示 事件 c 和 事件 g 出现 在 同一 元素 中 即 两者 同时 出现 而 在 S002 中 事件 c 则 先于 事件 g 出现 故 < { c ,   g } > 不是 S002 的 子 序列 
下面 我们 首先 来 尝试 枚举法 即 列出 全部 的 候选 序列 然后 一一 计算 它们 的 支持 度 与 最小 支持 度 阈值 比较 从而 搜索 出 全部 的 频繁 序列 
不过 候选 序列 和 候选 项集 的 枚举 有 一些 不同 具体 如下 
首先 在 项 集中 不会 出现 重复 的 项 但是 在 序列 中 一个 事件 可以 重复 出现 多次 比如 对于 项 a 和 项 b 可以 产生 一个 候选 2 - 项集 { a ,   b } 但是 却 可以 产生 多个 候选 2 - 序列 如 < { a } { a ,   b } > < { b ,   a } { b } > < { a } { a } > < { a } { b } > < { a ,   b } { b ,   a } > 等 
其次 项集 忽视 了 序列 信息 而 在 序列 中 事件 出现 的 先后 次序 是 很 重要 的 比如 { a ,   b } 和 { b ,   a } 表示 的 是 相同 的 项集 但是 < { a ,   b } > 和 < { b ,   a } > 却是 两个 不同 的 序列 
由于 这些 不同 在 使用 枚举法 时 候选 序列 的 个数 将 十分 庞大 其 数量 会 随 原始数据 中 事件 数量 的 增加 而 呈现 指数 式 增长 所以 想要 使用 枚举法 来 挖掘 频繁 序列 是 十分困难 的 我们 希望 你 能 了解 使用 枚举法 挖掘 频繁 序列 的 基本 过程 能够 明白 如何 列举 候选 k - 序列 并 学会 计算 序列 的 支持 度 但 我们 极力 不 推荐 你 使用 枚举法 即使 数据 中 的 事件 数量 不 多 
下面 我们 将 介绍 三种 用于 频繁 序列 挖掘 的 算法 它们 能 帮助 我们 避免 繁杂 的 枚举 有效 减少 候选 序列 数量 从而 加速 挖掘 

18.5 . 3   基于 Apriori 的 算法 
Rakesh   Agrawal 和 Ramakrishnan   Srikant 于 1995 年 提出 了 两种 基于 Apriori 的 序列 挖掘 算法 分别 是 AprioriAll 和 AprioriSome 下面 我们 将 分别 介绍 并 比较 
首先 我们 需要 介绍 一些 基本概念 在 本节 中 我们 称 频繁 1 - 序列 中 的 项集 为 Large   Itemset 简写 为 litemset 频繁 序列 则 被 称为 Large   Sequence Large   Sequence 中 的 元素 都 是 litemset 此外 这 一节 介绍 的 两种 算法 的 目的 不是 挖掘 全部 的 频繁 序列 而是 挖掘 全部 的 maximal   sequence 那么 什么 是 maximal   sequence 呢 我们 定义 在 频繁 序列 的 集合 中 如果 一个 序列 不是 集合 内 任何 其他 频繁 序列 的 子 序列 这个 频繁 序列 就是 maximal   sequence 后面 例子 理 清楚 了 再 补上 例子 描述 
下面 我们 来 介绍 算法 的 基本 框架 AprioriAll 算法 和 AprioriSome 算法 都 遵循 这个 框架 执行 我们 将 序列 挖掘 分为 5 个 阶段 具体 如下 

第一个 阶段 是 Sort   Phase 我们 得到 的 原始 数据库 通常 如 例子 待 补充 所示 我们 需要 将 其 转换 为 序列 数据库 以表 18 - 12 为例 以 顾客 ID 为主 键 以 交易 时间 戳 为 次键 将 原始 数据库 排序 后 同一个 顾客 的 全部 事务 便 转换 为 一条 序列 事务 按照 时间 戳 从小到大 排列 如表 18 - 13 所示 
表 18 - 12   某 商场 用户 购物 数据库 



表 18 - 12   序列 数据库 

第二个 阶段 是 Litemset   Phase 在 这个 阶段 我们 从 上 一步 得到 的 序列 数据库 中 按照 挖掘 频繁 项集 的 方法 设定 最小 支持 度 阈值 迭代 寻找 频繁 1 - 项集 频繁 2 - 项集 等 需要 注意 的 是 在 序列 数据库 中 如果 一个 项集 在 同一个 序列 的 不同 元素 中 出现 支持 度 计数 只 增加 一次 具体 过程 如图 18 - 12 所示 

图 18 - 12     生成 全部 频繁 项集 
这些 频繁 项集 的 集合 就 构成 了 litemset 的 集合 对于 litemset 我们 通常 会 将 它们 映射 到 连续 的 整数 或 字母 上 这样 不管 项 集中 项 的 个数 它们 都 平等 地被 看作 一个 实体 便于 表示 和 比较 我们 选择 将 litemsets 映射 到 连续 的 小写字母 上 如表 18 - 14 所示 这里 我们 使用 代替 { } 来 表示 项集 是 为了 在 下 一个 阶段 作 区分 
表 18 - 14   Large   Itemsets 及 映射 

第三个 阶段 是 Transformation   Phase 由于 频繁 序列 中 只 包含 litemset 所以 在 这 一步 中 我们 要 将 之前 得到 的 序列 数据库 作 一些 转换 如果 一个 元素 中 不 包含 任何 litemset 就 删除 该 元素 剩余 的 每个 元素 都 转换 为 这个 元素 所 包含 的 全部 litemset 的 集合 而 如果 一个 序列 中 不 包含 任何 litemset 就 删除 该 序列 以表 18 - 12 数据 为例 转换 后 的 序列 数据库 如表 18 - 15 所示 需要 注意 的 是 即使 一个 序列 在 这 一步 被 删除 之后 在 计算 支持 度时 序列 总数 也 不会 改变 只是 我们 预先判断 这个 序列 不会 包含 任何 频繁 序列 为 之后 的 支持 度 计算 步骤 减少 计算 量 
表 18 - 15   转换 后 的 序列 数据库 
  
第四个 阶段 是 Sequence   Phase 在 这个 阶段 我们 要 利用 从 第三阶段 得到 的 序列 数据库 应用 AprioriAll 或 AprioriSome 算法 从中 挖掘出 全部 的 频繁 序列 Large   Sequences 具体 算法 我们 之后 再 详细 介绍 
第五个 阶段 是 Maximal   Phase 这一 阶段 的 作用 是从 全部 的 频繁 序列 中 找出 全部 的 maximal   sequence 假设 全部 频繁 序列 中 最大 的 序列 长度 为 n 我们 首先 遍历 每个 n - 序列 删除 集合 中该 n - 序列 的 全部 子 序列 然后 遍历 集合 中 剩余 的 n - 1 - 序列 同样 从 集合 中 删除 其 全部 子 序列 按照 这个 步骤 n 逐渐 递减 当 n 等于 1 时 结束 遍历 此时 集合 中 剩余 的 全部 频繁 序列 都 是 maximal   sequence 考虑 给 简短 的 伪 代码 
现在 让 我们 来 详细描述 Sequence   Phase 这一 阶段 算法 的 基本 思想 和 我们 之前 介绍 的 Apriori 算法 类似 即 自 底向上 通过 多轮 迭代 来 产生 全部 的 频繁 序列 第一轮 时 由于 我们 已经 得到 了 litemset 的 集合 将 它们 略作 转换 便是 1 - 频繁 序列 的 集合 记为 L _ 1 而后 从 第二轮 开始 的 每 一轮 我们 先 通过 上 一轮 得到 的 频繁 序列 集合 生成 当前 这轮 的 候选 频繁 序列 然后 计算 它们 的 支持 度 与 最小 支持 度 阈值 比较 得到 本轮 的 频繁 序列 集合 然后 就 能 继续 下 一轮 迭代 当 某轮 的 候选 频繁 序列 集合 或 频繁 序列 集合 为 空集 时 迭代 结束 我们 就 得到 了 全部 的 频繁 序列 集合 进入 下个 阶段 
考虑 到 我们 的 最终 目的 是 挖掘出 全部 的 maximal   sequence 这一 阶段 便 出现 了 两种 思路 分别 是 count - all 和 count - some AprioriAll 就是 count - all 类型 的 算法 即 统计 全部 序列 的 支持 度 产生 全部 频繁 序列 后 在 maximal   phase 再 将 其中 的 non - maximal   sequence 剪枝 而 count - some 类型 的 算法 AprioriSome 则 是 将 sequence   phase 和 maximal   phase 合并 这 类 算法 分为 向前 和 向 后 两个 阶段 目的 是 在 挖掘 过程 中 尽量避免 统计 non - maximal   sequence 但 代价 是 它 可能 会 需要 统计 一些 非 频繁 序列 的 支持 度 这 其中 的 平衡 便 决定 了 算法 的 性能 下面 我们 将 依次 介绍 这 两种 算法 
AprioriAll 算法 和 我们 之前 介绍 的 Apriori 算法 的 基本 流程 一模一样 只是 在 生成 候选 序列 和 支持 度 计数 两个 过程 的 细节 略有不同 假设 我们 现在 得到 了 L _ ( k - 1 ) 现在 要 产生 候选 序列 集合 C _ k 其 过程 具体 如下 提供 伪 代码 提供 案例 

需要 注意 的 是 在 序列 中 顺序 很 重要 所以 < { a ,   b } > < { a ,   c } > 能 生成 < { a ,   b ,   c } > 和 < a ,   c ,   b > 两个 候选 序列 
对于 支持 度 计数 过程 我们 可以 像 Apriori 算法 一样 扫描 整个 序列 数据库 然后 得到 每个 候选 序列 的 支持 度 计数 但是 这 需要 多次 扫描 序列 数据库 换个 角度 来说 对于 序列 数据库 中 的 每个 序列 s 我们 都 需要 检查 各个 候选 序列 c 是否 被 s 支持 十分 费时 
这里 我们 介绍 一种 新 的 计算 支持 度 的 方法 其 目的 是 对于 序列 数据库 中 的 每个 序列 s 可以 不必 检查 每个 候选 序列 c 减少 需要 统计 的 候选 序列 的 数量 从而 实现 加速 
假设 我们 要 统计 C _ k 中 全部 序列 的 支持 度 那么 我们 首先 根据 C _ k 来 构建 hash 树 hash 树 的 节点 分为 叶 结点 和 内部 结点 叶 结点 中 存储 的 是 候选 序列 的 集合 而 内部 结点 中 存储 的 则 是 hash 表 我们 定义 根 结点 的 深度 为 1 深度 为 d 的 结点 指向 深度 为 d + 1 的 结点 构建 hash 树时 我们 依次 读入 候选 序列 起初 每个 候选 序列 都 放入 叶 结点 当叶 结点 的 候选 序列 数 达到 我们 设定 的 阈值 时 该叶 结点 就 需要 分裂 假设 该叶 结点 的 深度 为 k 其中 的 候选 序列 就 将 其 第 k 个 litemset 作为 hash 函数 的 输入 根据 返回值 散列 到 不同 的 叶 结点 中 原本 的 叶 结点 则 变成 内部 结点 其中 存储 一个 hash 表 
构建 完 hash 树后 我们 再 依次 读入 序列 数据库 中 的 序列 统计 它们 需要 检查 哪些 候选 序列 假设 我们 当前 读入 序列 s 在 根 结点 时 我们 将 序列 s 的 每个 litemset 依次 作为 hash 函数 的 输入 得到 返回值 然后 根据 返回值 定位 到 下 一层 的 结点 此时 会 出现 两种 情况 如果 我们 到达 的 是 叶 结点 那么 该叶 结点 中 的 序列 就是 序列 s 需要 检查 的 候选 序列 而 如果 我们 现在 到达 的 是 内部 结点 假设 我们 是 通过 散列 序列 s 的 某个 litemset 称为 i 到达 该 内部 结点 的 那么 在 下 一次 散列时 我们 只 需要 考虑 s 中 包含 i 的 元素 的 后 一个 元素 中 的 litemset 并 依次 对 它们 进行 散列 即可 而 不 需要 散列 s 中 的 全部 litemset 将 序列 s 散列 完成 后 我们 就 得到 了 序列 s 所 需要 检查 的 候选 序列 集合 C _ s 然后 再 一一 检查 统计 支持 度 即可 以 相同 的 步骤 处理 序列 数据库 中 的 每个 序列 后 我们 就 得到 了 全部 候选 序列 的 支持 度 计数 
然后 再 根据 候选 序列 的 支持 度 计数 与 最小 支持 度 阈值 比较 我们 就 能 得到 全部 的 频繁 序列 再 将 这些 频繁 序列 作为 下一阶段 Maximal   Phase 的 输入 即可 

图 18 - 13     AprioriAll 算法 生成 过程 
然后 我们 还 需要 进行 maximal   phase 由于 频繁 4 - 序列 只有 < { a } { b } { c } { d } > 我们 要 从 L _ 3 L _ 1 和 L _ 2 中 删除 其 全部 子 序列 此时 L _ 3 中 只 剩下 < { a } { c } { e } > 我们 再 从 L _ 1 和 L _ 2 中 删除 其 全部 子 序列 删除 后 L _ 2 中 没有 剩余 序列 该 阶段 结束 最后 我们 得到 全部 的 maximal   sequence 具体 为 < { a } { b } { c } { d } > < { a } { c } { e } > < { f } > < { a ,   c } > < { a ,   f } > < { c ,   f } > < { a ,   c ,   f } > 
接着 我们 来 介绍 AprioriSome 算法 该 算法 分为 两个 阶段 首先 是 向前 迭代 阶段 这个 阶段 只 挖掘 特定 长度 的 序列 然后 是 向 后 迭代 阶段 这个 阶段 是 挖掘出 剩余 的 序列 比如 我们 可能 在 向前 迭代 阶段 挖掘 了 长度 为 1 2 4 6 的 频繁 序列 然后 在 向 后 迭代 阶段 挖掘 长度 为 3 和 5 的 频繁 序列 为了 确定 在 向前 迭代 阶段 中 下 一轮 所 要 挖掘 的 序列 长度 我们 定义 了 一个 next 函数 该 函数 以 本轮 挖掘 的 序列 长度 为 输入 并 输出 下 一轮 所 要 挖掘 的 序列 长度 设 输入 参数 为 k 即 本轮 挖掘 得到 了 长度 为 k 的 频繁 序列 我们 令 hit _ k = ( | L _ k   | ) / ( | C _ k   | ) 即 在 长度 为 k 的 候选 序列 中 频繁 k - 序列 所 占 的 比例 而 通常 我们 的 直觉 是 hit _ k 越大 由 L _ k 迭代 产生 的 候选 序列 中非 频繁 序列 越 少 在 非 频繁 序列 上 的 统计 开销 就 会 少于 在 non - maximal   sequence 上 的 统计 开销 就 值得 我们 跳过 更 多 的 长度 所以 我们 给出 next 函数 如下 

设置 next 函数 的 作用 就是 在 统计 非 频繁 序列 和 统计 non - maximal 序列 的 开销 之间 寻求 一个 最佳 的 平衡点 如果 不论 k 是 多少 next ( k ) 总是 返回 k + 1 此时 就是 选择 统计 全部 的 non - maximal 序列 AprioriSome 算法 就 等价 于 AprioriAll 算法 相反 如果 next ( k ) = 100 × k 即 返回 一个 与 输入 相差 很大 的 数 那么 就 相当于 选择 统计 大量 的 非 频繁 序列 是 另 一种 极限 情况 由于 我们 可能 跳过 某 几个 长度 的 序列 所以 在 第 k 轮 迭代 时 我们 不 一定 得到 了 L _ ( k - 1 ) 此时 就 可以 通过 C _ ( k - 1 ) 来 生成 C _ k 因为 L _ ( k - 1 ) ⊑ C _ ( k - 1 ) 所以 可以 保证 生成 的 C _ k 不 遗漏 任何 频繁 序列 AprioriSome 算法 生成 候选 序列 的 规则 和 AprioriAll 算法 相同 k 从 2 开始 逐渐 递增 只有 当 k 和 next ( k ) 的 返回值 相等 时 才 会 计算 当前 C _ k 的 支持 度 从而 得到 L _ k 否则 不 需要 对 C _ k 进行 支持 度 计数 
当某 一轮 迭代 生成 的 候选 序列 或 频繁 序列 集合 为 空时 向前 迭代 阶段 就 终止 进入 向 后 迭代 阶段 假设 我们 已经 挖掘 了 长度 为 1 2 4 6 的 频繁 序列 此时 转入 向 后 迭代 阶段 我们 就要 挖掘 长度 为 5 和 3 的 频繁 序列 此时 我们 已经 得到 了 L _ 6 由于 我们 的 目标 是 maximal   sequence 所以 C _ 5 中是 L _ 6 中 某个 序列 的 子集 的 序列 都 可以 被 剪枝 同理 L _ 4 C _ 3 L _ 2 L _ 1 中 的 子 序列 也 都 直接 被 剪枝 L _ 6 的 子 序列 都 被 剪枝 后 我们 再 根据 L _ 5 进行 剪枝 即 序列 长度 递减 不断 剪枝 最后 留下 的 就 都 是 maximal   sequence 
下面 我们 给出 AprioriSome 的 伪 代码 具体 如下 









以表 18 - 15 中 的 数据 为例 我们 简单 假设 next ( k ) = 2k 所以 AprioriSome 算法 先生 成 C _ 1 和 L _ 1 然后 生成 C _ 2 和 L _ 2 这 一部分 过程 和 AprioriAll 算法 基本一致 如图所示 

图 18 - 14     AprioriSome 算法 生成 L _ 1 和 L _ 2 
接着 会 根据 L _ 2 生成 C _ 3 并 跳 过 L _ 3 直接 生成 C _ 4 与 L _ 4 具体 如图 18 - 15 所示 我们 在 生成 C _ 3 时 只 通过 先验 原理 对 其 进行 剪枝 由于 不 需要 生成 L _ 3 所以 不用 对 C _ 3 进行 支持 度 计数 

图 18 - 15     AprioriSome 算法 生成 C _ 3 和 L _ 4 
由于 L _ 4 生成 C _ 5 时 得到 空集 所以 向前 阶段 结束 下面 我们 进行 向 后 阶段 首先 检查 L _ 4 由于 只有 一个 序列 所以 其 必定 是 maximal   sequence 无需 删除 然后 我们 从 C _ 3 L _ 1 和 L _ 2 中 找到 < { a } { b } { c } { d } > 的 子 序列 并 删除 结果 如图 18 - 16 所示 然后 再 将 C _ 3 中 剩余 的 序列 进行 支持 度 计数 根据 最小 支持 度 计数 筛选 得到 < { a } { c } { e } > 再 从 L _ 1 和 L _ 2 中 删除 该 频繁 3 - 序列 的 子 序列 结果 如图 18 - 17 所示 由于 频繁 2 - 序列 中 没有 maximal   sequence 所以 我们 已经 得到 了 全部 的 maximal   sequence 这 与 AprioriAll 算法 得到 的 结果 相同 

图 18 - 16     AprioriSome 算法 后退 阶段 1 

图 18 - 17     AprioriSome 算法 后退 阶段 2 


18.5 . 4   GSP 算法 
在 实际 应用 中 我们 常常 需要 对 序列 模式 加上 一些 时限 约束 以 助于 其 更好 地 反映 元素 之间 的 关联 比如 给定 如下 购物 序列 < { 洗衣机 } { 方便面 } { 啤酒 } > 其中 洗衣机 和 方便面 的 购买 时间 相隔 一年 由于 时间 间隔 较长 我们 很难 认为 一年 前 购买 的 洗衣机 会 对 一年 后 购买 的 方便面 有 影响 或 联系 因此 我们 需要 再 原先 的 序列 模式定义 之上 引入 时限 约束 从而 定义新 的 序列 模式 GSP 算法 便是 针对 这种 新 的 序列 模式 所 提出 的 挖掘 算法 
下面 我们 首先 来 介绍 GSP 算法 中 对 序列 模式 的 约束 
  最大 间隔 和 最小 间隔 约束 
这是 通过 约束 序列 中 两个 连续 元素 之间 的 时间差 来 限制 序列 模式 若 设定 最大 时间差 maxgap 为 3 则 当前 元素 中 的 事件 和 前 一个 元素 中 的 事件 的 间隔 不能 超过 3 而 设定 最小 时间差 mingap 为 0 则 意味着 当前 元素 中 的 事件 必须 在 前 一个 元素 中 的 事件 之后 立即 出现 下面 我们 设定 maxgap = 4 mingap = 2 给出 子 序列 是否 满足 最大 间隔 和 最小 间隔 约束 的 案例 

需要 注意 的 是 由于 加入 了 时限 约束 在 进行 支持 度 计数 时 我们 还 需要 检查 候选 序列 是否 满足 时限 约束 此外 先验 原理 可能 不再 成立 假设 序列 数据库 中 某条 序列 为 < { a } { b } { c } > 当 没有 时限 约束 时 序列 < { a } { c } > 和 < { a } { b } { c } > 都 被 该 序列 支持 此时 加入 时限 约束 maxgap = 1 mingap = 0 那么 序列 < { a } { c } > 就 不再 被 支持 而 序列 < { a } { b } { c } > 依旧 被 支持 这 就 可能 导致 序列 < { a } { b } { c } > 的 支持 度 超过 其子 序列 的 支持 度 与 先验 原理 相悖 之后 我们 会 来 解决 这个 问题 
  窗口 大小 约束 
我们 定义 一个 窗口 大小 阈值 window   size 通常 简写 为 ws 它 用于 指定 一个 序列 中 的 任意 元素 中 的 事件 最早 和 最晚 出现 的 最大 允许 时间差 比如 当 窗口 大小 为 0 时 同一 元素 中 的 全部 事件 必须 同时 出现 而 当 窗口 大小 为 1 时 子 序列 中 某个 元素 里 的 多个 事件 可以 在 原 数据库 序列 中 的 两个 相邻 元素 内 出现 下面 我们 设定 ws = 2 给出 如下 案例 

需要 注意 的 是 如果 在 ws = 2 的 基础 上 我们 再 加入 maxgap = 3 的 限制 那么 表格 中 第四行 的 子 序列 < { a ,   b ,   c } { e ,   f ,   g } > 就 不再 被 s 支持 因为 其 最大 时间差 为 事件 a 和 g 的 事件 差 5 不 满足 maxgap 的 限制 
最大 间隔 和 最小 间隔 约束 是 加大 了 对 频繁 序列 的 限制 而 窗口 大小 约束则 是 在 一定 程度 上 放松 了 对 频繁 序列 的 判定 能 帮助 我们 避免 错过 一些 有趣 的 序列 模式 
  分类 标准 约束 
分类 标准 约束 是 加入 了 对 事件 之间 纵向 关系 的 考量 比如 事件 a 是 事件 b 的 上层 事件 且 事件 b 属于 元素 e 那么 事件 a 也 属于 元素 e 不过 在 之后 的 讨论 中 我们 不会 考虑 分类 标准 约束 而 只 考虑 前面 的 两种 时限 约束 
介绍 完 了 对 序列 模式 的 约束 下面 我们 开始 介绍 GSP 算法 
首先 我们 需要 重新 定义 k - 序列 之前 我们 定义 包含 k 个 元素 的 序列 为 k - 序列 而 在 GSP 算法 中 我们 定义 包含 k 个 事件 的 序列 为 k - 序列 对于 序列 < { a ,   b } { c } > 按 之前 的 定义 它 是 2 - 序列 而 现在 它 是 3 - 序列 而 对于 序列 < { a ,   b } { a ,   c } > 按 之前 的 定义 它 是 2 - 序列 现在 它 则 是 4 - 序列 即 同一个 事件 出现 在 不同 的 元素 中 时 需要 重复 计数 关于 这么 定义 的 理由 我们 会 在 之后 阐述 
由于 引入 最大 间隔 和 最小 间隔 约束 后 先验 原理 不再 满足 为了 解决 这一 问题 我们 现在 给出 邻接 子 序列 的 定义 从而 改进 先验 原理 
定义 18.4   邻接 子 序列   给定 一个 序列 s = < s _ 1   s _ 2 s _ n > 和 一个 子 序列 c 如果 下列 条件 之一 成立 那么 就 称 c 为 s 的 邻接 子 序列 contiguous   subsequence 
  c 是从 s 中 的 s _ 1 或 s _ n 中 删除 一个 事件 后 得到 的 
  c 是从 s 中 至少 包含 两个 事件 的 元素 里 删除 一个 事件 后 得到 的 
  c 是 t 的 邻接 子 序列 而 t 是 s 的 邻接 子 序列 
下面 我们 给出 一个 案例 帮助 更好 地 理解 邻接 子 序列 的 概念 

利用 邻接 子 序列 我们 可以 得到 如下 形式 的 先验 原理 如果 一个 k - 序列 是 频繁 的 则 它 的 所有 邻接 ( k - 1 ) - 子 序列 一定 是 频繁 的 
如果 一个 序列 s 支持 序列 模式 t 那么 当 没有 最大 间隔 约束 时 序列 s 也 一定 会 支持 t 的 所有 子 序列 而 若 有 最大 间隔 约束 序列 s 则 一定 会 支持 t 的 所有 邻接 子 序列 所以 上述 先验 原理 是 成立 的 
GSP 算法 的 整体 框架 和 Apriori 算法 类似 第一轮 扫描 原始 序列 数据库 得到 全部 1 - 序列 的 支持 度 再 根据 设定 的 最小 支持 度 阈值 筛选 出 频繁 1 - 序列 之后 每轮 将 迭代 地 产生 新 的 候选 k - 序列 然后 利用 先验 原理 剪枝 接着 对 剩余 候选 序列 进行 支持 度 计数 得到 每轮 的 频繁 k - 序列 但是 GSP 算法 的 候选 生成 过程 和 支持 度 计数 过程 与 Apriori 算法 不同 下面 我们 将 进行 详细描述 
首先 是 候选 生成 过程 这个 过程 分为 两个 阶段 具体 如下 
	 第一步 是 连接 阶段 即 通过 连接 频繁 ( k - 1 ) - 序列 来 生成 候选 k - 序列 假设 有 两个 k - 序列 s _ 1 和 s _ 2 如果 从 s _ 1 中 去掉 第一个 事件 得到 的 子 序列 与 从 s _ 2 中 去掉 最后 一个 事件 得到 的 子 序列 相同 那么 s _ 1 和 s _ 2 是 可以 合并 的 在 可以 合并 的 情况 下 如果 s _ 2 的 最后 一个 元素 只有 一个 事件 那么 将 s _ 2 的 最后 一个 元素 添加 到 s _ 1 的 末尾 就 得到 一个 候选 k - 序列 而 如果 s _ 2 的 最后 一个 元素 有 多个 事件 则 将 s _ 2 的 最后 一个 事件 添加 到 s _ 1 的 最后 一个 元素 的 末尾 同样 得到 一个 候选 k - 序列 需要 注意 的 是 如果 令 s _ 1 = < { a } > s _ 2 = < { b } > 它们 之间 连接 可以 得到 2 个 候选 2 - 序列 即 < { a ,   b } > < { a } { b } > 不难 发现 s _ 1 和 s _ 2 都 是 它们 连接 得到 的 候选 序列 的 邻接 子 序列 
	 第二步 是 剪枝 阶段 即 利用 先验 原理 对 候选 序列 进行 剪枝 当有 maxgap 时限 约束 时 如果 一个 候选 序列 的 任何 一个 邻接 子 序列 不 满足 最小 支持 度 就 将 其 剪 去 如果 没有 maxgap 时限 约束 我们 需要 检查 候选 序列 的 全部 子 序列 如果 其中 任何 一个 子 序列 不 满足 最小 支持 度 就 将 该 候选 序列 剪去 可以 看到 利用 邻接 子 序列 定义 的 先验 原理 可以 在 一定 程度 上 帮助 我们 减少 需要 检查 的 子 序列 的 数量 从而 加速 剪枝 
接着 是 支持 度 计数 过程 这一 过程 和 AprioriAll 算法 中 的 支持 度 计数 过程 相似 首先 利用 hash 树结构 存储 候选 序列 然后 利用 hash 树来 减少 序列 数据库 中 每个 序列 需要 检查 的 候选 序列 数量 再 一一 检查 筛选 后 的 候选 序列 是否 被 支持 在 GSP 算法 中 支持 度 计数 过程 的 前 两步 和 AprioriAll 算法 完全 一样 不同之处 是 它 提出 了 一种 高效 的 方法 用于 检查 一个 特定 的 候选 序列 是否 被 某个 序列 支持 下面 我们 将作 详细 介绍 
假设 s 是 序列 数据库 中 的 一个 序列 c 是 一条 候选 序列 我们 的 目的 是 快速 检查 s 是否 支持 c 即 检查 c 是否 为 s 的 子 序列 为了 实现 这 一点 给出 算法 如下 它 也 分为 向前 迭代 阶段 和 向 后 迭代 阶段 但是 和 AprioriSome 中 的 完全 不同 
在 向前 阶段 我们 在 s 中 寻找 c 的 相邻 元素 的 出现 并 检查 它们 之间 的 时间差 是否 满足 时间 约束 如果 满足 则 按 顺序 继续 寻找 c 的 下 一个 元素 如果 不 满足 就 转入 向 后 阶段 
假设 在 寻找 过程 中 c _ i 出现 时间 为 t 和 其前 一个 元素 c _ ( i - 1 ) 的 出现 时间 不 满足 时间 约束 从而 转入 了 向 后 阶段 在 向 后 阶段 中 我们 将 c _ ( i - 1 ) 删去 在 t - maxgap 的 时间 点 之后 继续 寻找 新 的 c _ ( i - 1 ) 接着 可能 出现 以下 三种 情况 需要 分别 处理 
若 找到 后 两者 的 时间差 满足 时间 约束 我们 还 不能 马上 转回 向前 阶段 由于 c _ ( i - 1 ) 的 出现 时间 改变 了 我们 还 需要 检查 c _ ( i - 1 ) 和 c _ ( i - 2 ) 的 时间差 是否 依旧 满足 时间 约束 若 不 满足 则 还 需要 如 调整 c _ ( i - 1 ) 一样 尝试 调整 c _ ( i - 2 ) 直到 当前 全部 元素 之间 的 时间差 都 满足 时间 约束 才能 转入 向前 阶段 
若 没 找到 新 的 c _ ( i - 1 ) 则 说明 s 不 支持 c 迭代 结束 
若 找到 后 但 需要 不断 向前 调整 元素 最后 如果 导致 c 中 的 第一个 元素 c _ 1 也 需要 重新 寻找 新 的 出现 位置 时 我们 如果 能 找到 新 的 c _ 1 就 立即 转回 向前 阶段 否则 说明 s 不 支持 c 迭代 结束 
每次 从 向 后 阶段 转回 向前 阶段 时 假设 向 后 阶段 中 最后 一个 需要 调整 出现 位置 的 元素 是 c _ j 回到 向前 阶段 时 我们 就 需要 在 s 中 从 c _ ( j + 1 ) 继续 寻找 
向前 阶段 和 向 后 阶段 是 交替 进行 的 如果 在 s 中 找到 了 c 的 全部 元素 且 都 满足 时间 约束 那么 就 说明 s 支持 c 下面 我们 结合 一个 具体 案例 进行 说明 
以图 18 - 13 1 中 数据 为 序列 数据库 中 的 一条 序列 数据 s 设 maxgap = 30 mingap = 5 window - size = 0 我们 要 检查 的 候选 序列 p 为 < { a ,   b } { c } { d } > 我们 首先 在 s 中 找到 p 中 第一个 元素 { a ,   b } 的 出现 时间 为 10 然后 找到 p 中 第二个 元素 { c } 的 出现 时间 为 45 两者 的 时间差 为 35 大于 maxgap 所以 转入 向 后 阶段 删去 { a ,   b } 在 时间 点 15 即 t _ ( { a ,   b } ) - maxgap 之后 继续 寻找 新 的 { a ,   b } 出现 时间 我们 找到 新 的 { a ,   b } 出现 时间 为 50 由于 { a ,   b } 是 p 中 第一个 元素 不用 考虑 调整 { a ,   b } 出现 时间 后 其 与 之前 元素 的 时间 约束 是否 还 满足 的 问题 然后 转回 向前 阶段 从 时间 55 t _ ( { a ,   b } ) + mingap 之后 重新 寻找 { a ,   b } 的 下 一个 元素 即 { c } { c } 的 下 一个 出现 时间 是 65 由于 65 - 50 = 15 满足 时间 约束 接着 我们 从 时间 70 t _ ( { c } ) + mingap 开始 继续 寻找 下 一个 元素 { d } { d } 的 出现 时间 是 90 由于 90 - 65 = 25 满足 时间 约束 且 p 中 的 全部 元素 都 已 找到 所以 迭代 结束 得出结论 序列 s 支持 候选 序列 p 
在 上面 的 流程 中 我们 没有 详细描述 在 序列 中 找到 某个 元素 的 出现 时间 这一 过程 事实上 如果 我们 每次 都 通过 遍历 序列 来 寻找 给定 元素 的 出现 时间 的话 效率 将 严重 下降 而 若 将 数据 序列 s 的 表示 方法 作如图 18 - 13 2 所示 变换 就 能 这 一 过程 更加 高效 

          图 18 - 13     1 为 序列 数据 右为 序列 数据 转换 后 的 表示 
创建 一个 字典 其中 键 是 序列 s 中 的 事件 名称 值则 是 该 事件 在 序列 s 中 的 出现 时间 具体 如图 18 - 13 2 所示 要 找到 事件 q 在 时间 节点 t 之后 的 第一次 出现 时间 我们 只 需要 遍历 字典 中 q 对应 的 值 然后 找到 比 t 大 的 第一个 值 即可 创建 这个 字典 的 时间 复杂度 是 O ( n + m ) 其中 n 是 整个 序列 数据库 中 事件 的 个数 m 则 是 序列 s 中 事件 的 个数 
对于 包含 多个 事件 的 元素 设 元素 中 最早 和 最晚 的 事件 的 出现 时间 分别 为 start - time st 和 end - time et 如果 两者 之差 大于 设定 的 window - size ws 我们 需要 从 t = et - ws 开始 重复 上述 搜索 过程 否则 就 结束 搜索 
仍旧 以图 18 - 13 1 中 所示 设 window - size = 7 如果 我们 需要 搜索 t = 20 之后 元素 { b ,   f } 的 第一次 出现 时间 则 过程 如下 首先 根据 图 18 - 13 2 我们 找到 b 第一次 出现 时间 是 50 而 f 的 第一次 出现 时间 是 25 故 et - st = 50 - 25 = 25 > 7 然后 设置 t = et - ws = 50 - 7 = 43 从 时间 点 t 往后 重新 搜索 我们 找到 b 的 出现 时间 仍 是 50 而 f 的 出现 时间 为 95 此时 et - st = 45 > 7 再 设置 t = et - ws = 88 重新 搜索 这次 我们 找到 b 的 出现 时间 是 90 f 的 出现 时间 仍为 95 此时 et - st = 5 < 7 搜索 结束 
最后 让 我们 总结 一下 GSP 算法 它 加入 了 maxgap mingap 和 window - size 等 时限 约束 以期 不会 忽视 一些 有趣 的 序列 模式 GSP 算法 的 总体 流程 和 Apriori 类 算法 一致 主要 分为 两个 步骤 一是 候选 序列 生成 二是 候选 序列 支持 度 计数 在 候选 序列 生成 中 GSP 算法 定义 了 邻接 子 序列 重新 定义 了 连接 阶段 和 剪枝 阶段 最后 输出 候选 序列 在 支持 度 计数 过程 中 GSP 算法 通过 hash 树 数据结构 减少 了 数据库 中 单个 序列 需要 检查 的 候选 序列 数量 并 通过 变换 数据库 中 序列 的 表示 方式 达到 高效 查询 单个 候选 序列 是否 被 数据库 中 序列 支持 的 目的 
18.5 . 5   PrefixSpan 算法 

18.5 . 6 算法 优缺点 


18.6   关联 规则 挖掘 的 其它 研究 问题 




  








1   按照 多维 数据库 使用 的 术语 通常 将 规则 中 的 不同 谓词 称作 维 
[ l1 ] 概念 定义 部分 与 书本 语句 有 重复 
[ l2 ] 和 书本 有 相似 
[ l3 ] 和 书本 有 相似 
[ l4 ] 在 18.2 . 4 里 比较 
[ l5 ] 不太 明白 资料 较 少 
[ l6 ] 例子 考虑 替换 有 重复 
[ l7 ] 参考文献 
[ l8 ] 看 情况 待 补充 不 平衡 比 等 信息 
--------------- 

------------------------------------------------------------ 

--------------- 

------------------------------------------------------------ 

