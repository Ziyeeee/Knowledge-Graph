<html>

<head>
<meta http-equiv=Content-Type content="text/html; charset=gb2312">
<meta name=Generator content="Microsoft Word 15 (filtered)">

<style id="dynCom" type="text/css"><!-- --></style>
<script language="JavaScript"><!--
function msoCommentShow(anchor_id, com_id)
{
	if(msoBrowserCheck()) 
		{
		c = document.all(com_id);
		a = document.all(anchor_id);
		if (null != c && null == c.length && null != a && null == a.length)
			{
			var cw = c.offsetWidth;
			var ch = c.offsetHeight;
			var aw = a.offsetWidth;
			var ah = a.offsetHeight;
			var x  = a.offsetLeft;
			var y  = a.offsetTop;
			var el = a;
			while (el.tagName != "BODY") 
				{
				el = el.offsetParent;
				x = x + el.offsetLeft;
				y = y + el.offsetTop;
				}
			var bw = document.body.clientWidth;
			var bh = document.body.clientHeight;
			var bsl = document.body.scrollLeft;
			var bst = document.body.scrollTop;
			if (x + cw + ah / 2 > bw + bsl && x + aw - ah / 2 - cw >= bsl ) 
				{ c.style.left = x + aw - ah / 2 - cw; }
			else 
				{ c.style.left = x + ah / 2; }
			if (y + ch + ah / 2 > bh + bst && y + ah / 2 - ch >= bst ) 
				{ c.style.top = y + ah / 2 - ch; }
			else 
				{ c.style.top = y + ah / 2; }
			c.style.visibility = "visible";
}	}	}
function msoCommentHide(com_id) 
{
	if(msoBrowserCheck())
		{
		c = document.all(com_id);
		if (null != c && null == c.length)
		{
		c.style.visibility = "hidden";
		c.style.left = -1000;
		c.style.top = -1000;
		} } 
}
function msoBrowserCheck()
{
	ms = navigator.appVersion.indexOf("MSIE");
	vers = navigator.appVersion.substring(ms + 5, ms + 6);
	ie4 = (ms > 0) && (parseInt(vers) >= 4);
	return ie4;
}
if (msoBrowserCheck())
{
	document.styleSheets.dynCom.addRule(".msocomanchor","background: infobackground");
	document.styleSheets.dynCom.addRule(".msocomoff","display: none");
	document.styleSheets.dynCom.addRule(".msocomtxt","visibility: hidden");
	document.styleSheets.dynCom.addRule(".msocomtxt","position: absolute");
	document.styleSheets.dynCom.addRule(".msocomtxt","top: -1000");
	document.styleSheets.dynCom.addRule(".msocomtxt","left: -1000");
	document.styleSheets.dynCom.addRule(".msocomtxt","width: 33%");
	document.styleSheets.dynCom.addRule(".msocomtxt","background: infobackground");
	document.styleSheets.dynCom.addRule(".msocomtxt","color: infotext");
	document.styleSheets.dynCom.addRule(".msocomtxt","border-top: 1pt solid threedlightshadow");
	document.styleSheets.dynCom.addRule(".msocomtxt","border-right: 2pt solid threedshadow");
	document.styleSheets.dynCom.addRule(".msocomtxt","border-bottom: 2pt solid threedshadow");
	document.styleSheets.dynCom.addRule(".msocomtxt","border-left: 1pt solid threedlightshadow");
	document.styleSheets.dynCom.addRule(".msocomtxt","padding: 3pt 3pt 3pt 3pt");
	document.styleSheets.dynCom.addRule(".msocomtxt","z-index: 100");
}
// --></script>
<style>
<!--
 /* Font Definitions */
 @font-face
	{font-family:Helvetica;
	panose-1:2 11 5 4 2 2 2 2 2 4;}
@font-face
	{font-family:Courier;
	panose-1:2 7 4 9 2 2 5 2 4 4;}
@font-face
	{font-family:"Tms Rmn";
	panose-1:2 2 6 3 4 5 5 2 3 4;}
@font-face
	{font-family:Helv;
	panose-1:2 11 6 4 2 2 2 3 2 4;}
@font-face
	{font-family:"New York";
	panose-1:2 4 5 3 6 5 6 2 3 4;}
@font-face
	{font-family:System;
	panose-1:0 0 0 0 0 0 0 0 0 0;}
@font-face
	{font-family:Wingdings;
	panose-1:5 0 0 0 0 0 0 0 0 0;}
@font-face
	{font-family:"MS Mincho";
	panose-1:2 2 6 9 4 2 5 8 3 4;}
@font-face
	{font-family:Batang;
	panose-1:2 3 6 0 0 1 1 1 1 1;}
@font-face
	{font-family:宋体;
	panose-1:2 1 6 0 3 1 1 1 1 1;}
@font-face
	{font-family:PMingLiU;
	panose-1:2 1 6 1 0 1 1 1 1 1;}
@font-face
	{font-family:"MS Gothic";
	panose-1:2 11 6 9 7 2 5 8 2 4;}
@font-face
	{font-family:Dotum;
	panose-1:2 11 6 0 0 1 1 1 1 1;}
@font-face
	{font-family:黑体;
	panose-1:2 1 6 9 6 1 1 1 1 1;}
@font-face
	{font-family:MingLiU;
	panose-1:2 1 6 9 0 1 1 1 1 1;}
@font-face
	{font-family:Mincho;
	panose-1:2 2 6 9 4 3 5 8 3 5;}
@font-face
	{font-family:Gulim;
	panose-1:2 11 6 0 0 1 1 1 1 1;}
@font-face
	{font-family:Century;
	panose-1:2 4 6 4 5 5 5 2 3 4;}
@font-face
	{font-family:"Angsana New";
	panose-1:2 2 6 3 5 4 5 2 3 4;}
@font-face
	{font-family:"Cordia New";
	panose-1:2 11 3 4 2 2 2 2 2 4;}
@font-face
	{font-family:Mangal;
	panose-1:0 0 4 0 0 0 0 0 0 0;}
@font-face
	{font-family:Latha;
	panose-1:2 0 4 0 0 0 0 0 0 0;}
@font-face
	{font-family:Sylfaen;
	panose-1:1 10 5 2 5 3 6 3 3 3;}
@font-face
	{font-family:Vrinda;
	panose-1:0 0 4 0 0 0 0 0 0 0;}
@font-face
	{font-family:Raavi;
	panose-1:2 0 5 0 0 0 0 0 0 0;}
@font-face
	{font-family:Shruti;
	panose-1:2 0 5 0 0 0 0 0 0 0;}
@font-face
	{font-family:Sendnya;
	panose-1:0 0 4 0 0 0 0 0 0 0;}
@font-face
	{font-family:Gautami;
	panose-1:2 0 5 0 0 0 0 0 0 0;}
@font-face
	{font-family:Tunga;
	panose-1:0 0 4 0 0 0 0 0 0 0;}
@font-face
	{font-family:"Estrangelo Edessa";
	panose-1:0 0 0 0 0 0 0 0 0 0;}
@font-face
	{font-family:"Cambria Math";
	panose-1:2 4 5 3 5 4 6 3 2 4;}
@font-face
	{font-family:"Arial Unicode MS";
	panose-1:2 11 6 4 2 2 2 2 2 4;}
@font-face
	{font-family:"Calibri Light";
	panose-1:2 15 3 2 2 2 4 3 2 4;}
@font-face
	{font-family:Calibri;
	panose-1:2 15 5 2 2 2 4 3 2 4;}
@font-face
	{font-family:"Microsoft YaHei UI";
	panose-1:2 11 5 3 2 2 4 2 2 4;}
@font-face
	{font-family:等线;
	panose-1:2 1 6 0 3 1 1 1 1 1;}
@font-face
	{font-family:华文楷体;
	panose-1:2 1 6 0 4 1 1 1 1 1;}
@font-face
	{font-family:"等线 Light";
	panose-1:2 1 6 0 3 1 1 1 1 1;}
@font-face
	{font-family:"\@等线";
	panose-1:2 1 6 0 3 1 1 1 1 1;}
@font-face
	{font-family:"\@华文楷体";
	panose-1:2 1 6 0 4 1 1 1 1 1;}
@font-face
	{font-family:"\@Arial Unicode MS";
	panose-1:2 11 6 4 2 2 2 2 2 4;}
@font-face
	{font-family:"\@MS Gothic";
	panose-1:2 11 6 9 7 2 5 8 2 4;}
 /* Style Definitions */
 p.MsoNormal, li.MsoNormal, div.MsoNormal
	{margin:0cm;
	margin-bottom:.0001pt;
	text-align:justify;
	text-justify:inter-ideograph;
	font-size:10.5pt;
	font-family:等线;}
p.MsoFootnoteText, li.MsoFootnoteText, div.MsoFootnoteText
	{mso-style-link:"脚注文本 Char";
	margin:0cm;
	margin-bottom:.0001pt;
	layout-grid-mode:char;
	font-size:9.0pt;
	font-family:等线;}
p.MsoCommentText, li.MsoCommentText, div.MsoCommentText
	{mso-style-link:"批注文字 Char";
	margin:0cm;
	margin-bottom:.0001pt;
	font-size:10.5pt;
	font-family:等线;}
p.MsoHeader, li.MsoHeader, div.MsoHeader
	{mso-style-link:"页眉 Char";
	margin:0cm;
	margin-bottom:.0001pt;
	text-align:center;
	layout-grid-mode:char;
	border:none;
	padding:0cm;
	font-size:9.0pt;
	font-family:等线;}
p.MsoFooter, li.MsoFooter, div.MsoFooter
	{mso-style-link:"页脚 Char";
	margin:0cm;
	margin-bottom:.0001pt;
	layout-grid-mode:char;
	font-size:9.0pt;
	font-family:等线;}
span.MsoFootnoteReference
	{vertical-align:super;}
p.MsoCommentSubject, li.MsoCommentSubject, div.MsoCommentSubject
	{mso-style-link:"批注主题 Char";
	margin:0cm;
	margin-bottom:.0001pt;
	font-size:10.5pt;
	font-family:等线;
	font-weight:bold;}
p.MsoAcetate, li.MsoAcetate, div.MsoAcetate
	{mso-style-link:"批注框文本 Char";
	margin:0cm;
	margin-bottom:.0001pt;
	text-align:justify;
	text-justify:inter-ideograph;
	font-size:9.0pt;
	font-family:等线;}
span.MsoPlaceholderText
	{color:gray;}
p.MsoListParagraph, li.MsoListParagraph, div.MsoListParagraph
	{margin:0cm;
	margin-bottom:.0001pt;
	text-align:justify;
	text-justify:inter-ideograph;
	text-indent:21.0pt;
	font-size:10.5pt;
	font-family:等线;}
span.Char
	{mso-style-name:"页眉 Char";
	mso-style-link:页眉;}
span.Char0
	{mso-style-name:"页脚 Char";
	mso-style-link:页脚;}
span.Char1
	{mso-style-name:"脚注文本 Char";
	mso-style-link:脚注文本;}
span.Char2
	{mso-style-name:"批注文字 Char";
	mso-style-link:批注文字;}
span.Char3
	{mso-style-name:"批注主题 Char";
	mso-style-link:批注主题;
	font-weight:bold;}
span.Char4
	{mso-style-name:"批注框文本 Char";
	mso-style-link:批注框文本;}
span.msoIns
	{mso-style-name:"";
	text-decoration:underline;
	color:teal;}
span.msoDel
	{mso-style-name:"";
	text-decoration:line-through;
	color:red;}
.MsoChpDefault
	{font-family:等线;}
 /* Page Definitions */
 @page WordSection1
	{size:595.3pt 841.9pt;
	margin:72.0pt 90.0pt 72.0pt 90.0pt;
	layout-grid:15.6pt;}
div.WordSection1
	{page:WordSection1;}
 /* List Definitions */
 ol
	{margin-bottom:0cm;}
ul
	{margin-bottom:0cm;}
-->
</style>

</head>

<body lang=ZH-CN style='text-justify-trim:punctuation'>

<div class=WordSection1 style='layout-grid:15.6pt'>

<p class=MsoNormal align=center style='text-align:center'><b><span
style='font-size:16.0pt'>第<span lang=EN-US>18</span>章 关联规则挖掘</span></b></p>

<p class=MsoNormal style='text-indent:22.7pt'><span style='font-family:华文楷体;
background:yellow'>为什么、是什么、怎么做</span></p>

<p class=MsoNormal><b><span lang=EN-US style='font-size:14.0pt;font-family:
华文楷体'>18.1 </span></b><b><span style='font-size:14.0pt;font-family:华文楷体'>关联规则挖掘概述</span></b></p>

<p class=MsoNormal style='text-indent:22.7pt'><span style='font-family:华文楷体'>关联就是反映某个事物与其他事物之间相互依存关系，而关联分析是指在交易数据中，找出存在于项目集合之间的关联模式，即如果两个或多个事物之间存在一定的关联性，则其中一个事物就能通过其他事物进行预测。通常的做法是挖掘隐藏在数据中的相互关系，当两个或多个数据项的取值相互间高概率的重复出现时，那么就会认为它们之间存在一定的关联。</span></p>

<p class=MsoNormal><span lang=EN-US style='font-family:华文楷体;color:red'>&nbsp;</span></p>

<p class=MsoNormal><b><span lang=EN-US style='font-size:12.0pt;font-family:
华文楷体'>18.1.1</span></b><b><span style='font-size:12.0pt;font-family:华文楷体'>一个简单的关联规则应用案例</span></b></p>

<p class=MsoNormal style='text-indent:22.7pt'><span style='font-family:华文楷体'>网络购物越来越受欢迎，电商平台的卖家同样竞争激烈。作为电商店铺管理员，我们能够获得每个用户在本店的购买记录，通过利用这些购买记录，采取合适的销售策略，能在一定程度上提高店铺的商品销量，那么如何利用这些购买记录呢？下面我们将一起探索这个问题。</span></p>

<p class=MsoNormal style='text-indent:22.7pt'><span style='font-family:华文楷体'>表<span
lang=EN-US>18-2</span>中给出了某电商店铺的部分事务数据，其中包含<span lang=EN-US>10</span>个事务，即<span
lang=EN-US>10</span>条购买记录。我们期望从中发现一些关联规则，从而合理地设置商品组合。</span></p>

<p class=MsoNormal align=center style='margin-top:7.8pt;text-align:center;
text-indent:22.7pt'><b><span style='font-family:华文楷体'>表<span lang=EN-US>18-1 </span>某电商店铺的事务数据</span></b></p>

<div align=center>

<table class=MsoTableGrid border=1 cellspacing=0 cellpadding=0
 style='border-collapse:collapse;border:none'>
 <tr>
  <td width=151 valign=top style='width:113.1pt;border:solid windowtext 1.0pt;
  padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormal align=left style='text-align:left'><span lang=EN-US
  style='font-family:华文楷体'>TID</span><span style='font-family:华文楷体'>（事务<span
  lang=EN-US>ID</span>）</span></p>
  </td>
  <td width=152 valign=top style='width:113.7pt;border:solid windowtext 1.0pt;
  border-left:none;padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormal><span style='font-family:华文楷体'>商品列表</span></p>
  </td>
 </tr>
 <tr>
  <td width=151 valign=top style='width:113.1pt;border:solid windowtext 1.0pt;
  border-top:none;padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormal><span lang=EN-US style='font-family:华文楷体'>T100</span></p>
  </td>
  <td width=152 valign=top style='width:113.7pt;border-top:none;border-left:
  none;border-bottom:solid windowtext 1.0pt;border-right:solid windowtext 1.0pt;
  padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormal><span style='font-family:华文楷体'>暂略</span></p>
  </td>
 </tr>
 <tr>
  <td width=151 valign=top style='width:113.1pt;border:solid windowtext 1.0pt;
  border-top:none;padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormal><span lang=EN-US style='font-family:华文楷体'>T101</span></p>
  </td>
  <td width=152 valign=top style='width:113.7pt;border-top:none;border-left:
  none;border-bottom:solid windowtext 1.0pt;border-right:solid windowtext 1.0pt;
  padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormal><span lang=EN-US style='font-family:华文楷体'>&nbsp;</span></p>
  </td>
 </tr>
 <tr>
  <td width=151 valign=top style='width:113.1pt;border:solid windowtext 1.0pt;
  border-top:none;padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormal><span lang=EN-US style='font-family:华文楷体'>T102</span></p>
  </td>
  <td width=152 valign=top style='width:113.7pt;border-top:none;border-left:
  none;border-bottom:solid windowtext 1.0pt;border-right:solid windowtext 1.0pt;
  padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormal><span lang=EN-US style='font-family:华文楷体'>&nbsp;</span></p>
  </td>
 </tr>
 <tr>
  <td width=151 valign=top style='width:113.1pt;border:solid windowtext 1.0pt;
  border-top:none;padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormal><span lang=EN-US style='font-family:华文楷体'>T103</span></p>
  </td>
  <td width=152 valign=top style='width:113.7pt;border-top:none;border-left:
  none;border-bottom:solid windowtext 1.0pt;border-right:solid windowtext 1.0pt;
  padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormal><span lang=EN-US style='font-family:华文楷体'>&nbsp;</span></p>
  </td>
 </tr>
 <tr>
  <td width=151 valign=top style='width:113.1pt;border:solid windowtext 1.0pt;
  border-top:none;padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormal><span lang=EN-US style='font-family:华文楷体'>T104</span></p>
  </td>
  <td width=152 valign=top style='width:113.7pt;border-top:none;border-left:
  none;border-bottom:solid windowtext 1.0pt;border-right:solid windowtext 1.0pt;
  padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormal><span lang=EN-US style='font-family:华文楷体'>&nbsp;</span></p>
  </td>
 </tr>
 <tr>
  <td width=151 valign=top style='width:113.1pt;border:solid windowtext 1.0pt;
  border-top:none;padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormal><span lang=EN-US style='font-family:华文楷体'>T105</span></p>
  </td>
  <td width=152 valign=top style='width:113.7pt;border-top:none;border-left:
  none;border-bottom:solid windowtext 1.0pt;border-right:solid windowtext 1.0pt;
  padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormal><span lang=EN-US style='font-family:华文楷体'>&nbsp;</span></p>
  </td>
 </tr>
 <tr>
  <td width=151 valign=top style='width:113.1pt;border:solid windowtext 1.0pt;
  border-top:none;padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormal><span lang=EN-US style='font-family:华文楷体'>T106</span></p>
  </td>
  <td width=152 valign=top style='width:113.7pt;border-top:none;border-left:
  none;border-bottom:solid windowtext 1.0pt;border-right:solid windowtext 1.0pt;
  padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormal><span lang=EN-US style='font-family:华文楷体'>&nbsp;</span></p>
  </td>
 </tr>
 <tr>
  <td width=151 valign=top style='width:113.1pt;border:solid windowtext 1.0pt;
  border-top:none;padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormal><span lang=EN-US style='font-family:华文楷体'>T107</span></p>
  </td>
  <td width=152 valign=top style='width:113.7pt;border-top:none;border-left:
  none;border-bottom:solid windowtext 1.0pt;border-right:solid windowtext 1.0pt;
  padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormal><span lang=EN-US style='font-family:华文楷体'>&nbsp;</span></p>
  </td>
 </tr>
 <tr>
  <td width=151 valign=top style='width:113.1pt;border:solid windowtext 1.0pt;
  border-top:none;padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormal><span lang=EN-US style='font-family:华文楷体'>T108</span></p>
  </td>
  <td width=152 valign=top style='width:113.7pt;border-top:none;border-left:
  none;border-bottom:solid windowtext 1.0pt;border-right:solid windowtext 1.0pt;
  padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormal><span lang=EN-US style='font-family:华文楷体'>&nbsp;</span></p>
  </td>
 </tr>
 <tr>
  <td width=151 valign=top style='width:113.1pt;border:solid windowtext 1.0pt;
  border-top:none;padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormal><span lang=EN-US style='font-family:华文楷体'>T109</span></p>
  </td>
  <td width=152 valign=top style='width:113.7pt;border-top:none;border-left:
  none;border-bottom:solid windowtext 1.0pt;border-right:solid windowtext 1.0pt;
  padding:0cm 5.4pt 0cm 5.4pt'>
  <p class=MsoNormal><span lang=EN-US style='font-family:华文楷体'>&nbsp;</span></p>
  </td>
 </tr>
</table>

</div>

<p class=MsoNormal><span lang=EN-US style='font-family:华文楷体;color:red'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></p>

<p class=MsoNormal style='text-indent:21.0pt'><span style='font-family:华文楷体'>通过关联规则分析，我们发现了如下几条关联规则：</span></p>

<p class=MsoNormal align=right style='text-align:right;text-indent:21.0pt;
line-height:50%'><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:11.5pt'><img width=160 height=42
src="chap18.files/image001.png"></span><span style='font-family:华文楷体'>&nbsp;<span
lang=EN-US>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>（<span
lang=EN-US>1</span>）</span></p>

<p class=MsoNormal align=right style='text-align:right;text-indent:21.0pt'><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:11.5pt'><img width=90 height=42
src="chap18.files/image002.png"></span><span lang=EN-US style='font-family:
华文楷体'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;
</span><span style='font-family:华文楷体'>（<span lang=EN-US>2</span>）</span></p>

<p class=MsoNormal align=right style='text-align:right;text-indent:21.0pt'><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:11.5pt'><img width=146 height=42
src="chap18.files/image003.png"></span><span style='font-family:华文楷体'>&nbsp;<span
lang=EN-US>&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</span>（<span
lang=EN-US>3</span>） </span></p>

<p class=MsoNormal align=left style='text-align:left;text-indent:21.0pt'><span
style='font-family:华文楷体'>对于关联规则（<span lang=EN-US>1</span>），这个推论是可以接受的，购买笔记本保护套的顾客通常是刚买了笔记本，而为了代替笔记本电脑的键盘，这些顾客可能就会再买一个机械键盘。根据这条关联规则，我们可以设置销售策略，顾客在购买机械键盘后少量加价即可赠送笔记本保护套，从而提高销量。</span></p>

<p class=MsoNormal align=left style='text-align:left;text-indent:21.0pt'><span
style='font-family:华文楷体'>对于关联规则（<span lang=EN-US>2</span>），这个推论较难直接看出因果关系，但我们可以试着推出钢笔和保温杯的优惠购买套餐，再根据销售情况适时调整。</span></p>

<p class=MsoNormal align=left style='text-align:left;text-indent:21.0pt'><span
style='font-family:华文楷体'>对于关联规则（<span lang=EN-US>3</span>），我们可以认为购买手机壳的用户爱好干净整洁，所以会同时购买键盘清洁工具。所以可以在用户挑选手机壳的界面，放入键盘清洁工具的相关图片和链接，刺激消费。</span></p>

<p class=MsoNormal><span lang=EN-US style='font-family:华文楷体;color:red'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span
style='font-family:华文楷体'>在下一小节，我们会更详细地介绍关联规则分析所涉及的基本概念，同时也会介绍关联规则的分类，使你对关联规则有更清晰且全面的认识。</span></p>

<p class=MsoNormal><span lang=EN-US style='font-family:华文楷体'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></p>

<p class=MsoNormal><b><span lang=EN-US style='font-size:12.0pt;font-family:
华文楷体'>18.1.2</span></b><b><span style='font-size:12.0pt;font-family:华文楷体'>关联规则的定义与分类</span></b></p>

<p class=MsoNormal style='text-indent:22.7pt'><span style='font-family:华文楷体'>我们首先需要介绍一些关联规则分析所涉及的基本概念。</span></p>

<p class=MsoNormal style='text-indent:22.7pt'><a><span style='font-family:华文楷体'>数据通常以二维表的形式展示，如表<span
lang=EN-US>18-1</span>所示，每一行都对应一个事务。令</span></a><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=103 height=21
src="chap18.files/image004.png"></span><span style='font-family:华文楷体'>是所有事务的集合。对于每行事务，其中包含的每个商品都称为<b>项</b>。在关联分析中，包含零个或多个项的集合称为<b>项集</b>。如果一个项集包含<span
lang=EN-US>k</span>个项，则称它为<b><span lang=EN-US>k-</span>项集</b>。例如，<span
lang=EN-US>{I1</span>，<span lang=EN-US>I2</span>，<span lang=EN-US>I4}</span>是一个三项集。<b>空集</b>则是不包含任何项的项集。项集有一个重要的属性，称为<b>支持度计数</b>，是指在数据库中包含该项集的事务个数，也称为<b>出现频度</b>。我们用</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=28 height=21
src="chap18.files/image005.png"></span><span style='font-family:华文楷体'>表示，具体定义为：</span></p>

<p class=MsoNormal align=center style='text-align:center'><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif"'><img
width=155 height=21 src="chap18.files/image006.png"></span></p>

<p class=MsoNormal style='text-indent:22.7pt'><span style='font-family:华文楷体'>其中，符号<span
lang=EN-US>|&#8226;|</span>表示集合中元素的个数。</span></p>

<p class=MsoNormal style='text-indent:22.7pt'><b><span style='font-family:华文楷体'>关联规则</span></b><span
style='font-family:华文楷体'>是形如</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=35 height=21
src="chap18.files/image007.png"></span><span style='font-family:华文楷体'>的蕴涵表达式，其中<span
lang=EN-US>X</span>和<span lang=EN-US>Y</span>是不相交的两个项集。</span></p>

<p class=MsoNormal style='text-indent:22.7pt'><span style='font-family:华文楷体'>以上述关联规则（<span
lang=EN-US>1</span>）为例，购买笔记本保护套的顾客也倾向于购买机械键盘，则可以表示如下：</span></p>

<p class=MsoNormal align=center style='text-align:center;text-indent:22.7pt'><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif"'><img
width=274 height=21 src="chap18.files/image008.png"></span></p>

<p class=MsoNormal style='text-indent:22.7pt'><span style='font-family:华文楷体'>其中<span
lang=EN-US>support</span>是<b>支持度</b>，可以用于给定数据集的频繁程度，表示所有事务的<span lang=EN-US>40%</span>显示机械键盘和笔记本保护套被同时购买；<span
lang=EN-US>confidence</span>是<b>置信度</b>，可以用于确定后者在包含前者的事务中出现的频繁程度，表示购买笔记本保护套的顾客中<span
lang=EN-US>80%</span>也购买了机械键盘。</span></p>

<p class=MsoNormal style='text-indent:22.7pt'><span style='font-family:华文楷体'>对于关联规则</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=35 height=21
src="chap18.files/image007.png"></span><span style='font-family:华文楷体'>，令</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=10 height=21
src="chap18.files/image009.png"></span><span style='font-family:华文楷体'>是事务个数，给出支持度（<span
lang=EN-US>s</span>）和置信度（<span lang=EN-US>c</span>）的形式定义如下：</span></p>

<p class=MsoNormal align=center style='text-align:center'><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif"'><img
width=125 height=42 src="chap18.files/image010.png"></span></p>

<p class=MsoNormal><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif"'><img
width=123 height=42 src="chap18.files/image011.png"></span></p>

<p class=MsoNormal style='text-indent:22.7pt'><span style='font-family:华文楷体'>为了筛选出有用的关联规则，我们需要根据应用场景设定相应的阈值，分别是<b>最小支持度阈值</b>（<span
lang=EN-US>minsup</span>）和<b>最小置信度阈值</b>（<span lang=EN-US>minconf</span>）。对于项集来说，如果它的支持度满足最小支持度阈值，则称它为<b>频繁项集</b>，频繁<span
lang=EN-US>k</span>项集的集合通常记为</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=15 height=21
src="chap18.files/image012.png"></span><span style='font-family:华文楷体'>。而对于规则来说，如果它同时满足最小支持度阈值和最小置信度阈值，则称它为<b>强规则</b>。</span></p>

<p class=MsoNormal style='text-indent:22.7pt'><span style='font-family:华文楷体'>由于在不同的应用场景下，数据形式也会有所不同，挖掘得到的关联规则也会不同。我们基于不同的考量，给出三种常用的关联规则分类，具体如下：</span></p>

<p class=MsoListParagraph style='margin-left:43.7pt;text-indent:-21.0pt'><b><span
lang=EN-US style='font-family:华文楷体'>(1)<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;
</span></span></b><b><span style='font-family:华文楷体'>基于规则所涉及的维数</span></b></p>

<p class=MsoListParagraph style='margin-left:64.7pt;text-indent:-21.0pt'><span
lang=EN-US style='font-family:Wingdings'>l<span style='font:7.0pt "Times New Roman"'>&nbsp;
</span></span><span style='font-family:华文楷体'>单维关联规则：若关联规则中的项或属性只涉及一个维<a
href="#_ftn1" name="_ftnref1" title=""><span class=MsoFootnoteReference><span
lang=EN-US><span class=MsoFootnoteReference><span lang=EN-US style='font-size:
10.5pt;font-family:华文楷体'>[1]</span></span></span></span></a>，则称它为单维关联规则。单维关联规则展示了同一个属性或维内的联系，例如：</span></p>

<p class=MsoListParagraph align=right style='margin-left:64.7pt;text-align:
right;text-indent:0cm'><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=241 height=21
src="chap18.files/image013.png"></span><span lang=EN-US style='font-family:
华文楷体'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span><span style='font-family:华文楷体'>（<span lang=EN-US>18-3</span>）</span></p>

<p class=MsoListParagraph align=left style='margin-top:0cm;margin-right:10.5pt;
margin-bottom:0cm;margin-left:64.7pt;margin-bottom:.0001pt;text-align:left;
text-indent:0cm'><span style='font-family:华文楷体'>其中</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=8 height=21
src="chap18.files/image014.png"></span><span style='font-family:华文楷体'>指代顾客，在该关联规则中，只涉及了<span
lang=EN-US>buys</span>这一个维，。</span></p>

<p class=MsoListParagraph style='margin-left:64.7pt;text-indent:-21.0pt'><span
lang=EN-US style='font-family:Wingdings'>l<span style='font:7.0pt "Times New Roman"'>&nbsp;
</span></span><span style='font-family:华文楷体'>多维关联规则：若关联规则中的项或属性涉及两个及以上的维，则称它为多维关联规则。多维关联规则展示了不同属性或维之间的关联。例如：
</span></p>

<p class=MsoListParagraph align=right style='margin-left:64.7pt;text-align:
right;text-indent:0cm'><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=385 height=21
src="chap18.files/image015.png"></span><span lang=EN-US style='font-family:
华文楷体'>&nbsp;</span><span style='font-family:华文楷体'>（<span lang=EN-US>18-4</span>）</span></p>

<p class=MsoListParagraph style='margin-left:64.7pt;text-indent:0cm'><span
style='font-family:华文楷体'>其中</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=8 height=21
src="chap18.files/image014.png"></span><span style='font-family:华文楷体'>同样指代顾客，该规则涉及三个维，分别是<span
lang=EN-US>age</span>、<span lang=EN-US>income</span>和<span lang=EN-US>buys</span>。</span></p>

<p class=MsoListParagraph style='margin-left:43.7pt;text-indent:-21.0pt'><b><span
lang=EN-US style='font-family:华文楷体'>(2)<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;
</span></span></b><b><span style='font-family:华文楷体'>基于规则所处理的值类型</span></b></p>

<p class=MsoListParagraph style='margin-left:64.7pt;text-indent:-21.0pt'><span
lang=EN-US style='font-family:Wingdings'>l<span style='font:7.0pt "Times New Roman"'>&nbsp;
</span></span><span style='font-family:华文楷体'>布尔关联规则：若关联规则只考虑项是否出现，而不涉及具体的取值，则它是布尔关联规则。例如，在关联规则<span
lang=EN-US>18-3</span>中，它只考虑顾客是否购买<span lang=EN-US>laptop</span>和<span
lang=EN-US>keyboard</span>，而不考虑顾客购买的<span lang=EN-US>laptop</span>的价格等属性，所以它是布尔关联规则。</span></p>

<p class=MsoListParagraph style='margin-left:64.7pt;text-indent:-21.0pt'><span
lang=EN-US style='font-family:Wingdings'>l<span style='font:7.0pt "Times New Roman"'>&nbsp;
</span></span><span style='font-family:华文楷体'>量化关联规则：若关联规则中还考虑了量化的项或属性之间的关联，则它是量化关联规则。在量化关联规则中，部分项或属性的值被划分为区间，这些属性被称为量化属性。例如在关联规则<span
lang=EN-US>18-4</span>中，<span lang=EN-US>age</span>和<span lang=EN-US>income</span>都是量化属性，所以该规则是量化关联规则。注意，量化关联规则中也能包含非量化的项或属性，例如规则<span
lang=EN-US>18-4</span>中的<span lang=EN-US>buys</span>。</span></p>

<p class=MsoListParagraph style='margin-left:43.7pt;text-indent:-21.0pt'><b><span
lang=EN-US style='font-family:华文楷体'>(3)<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;
</span></span></b><b><span style='font-family:华文楷体'>基于所挖掘的数据类型和特征</span></b></p>

<p class=MsoListParagraph style='margin-left:64.7pt;text-indent:-21.0pt'><span
lang=EN-US style='font-family:Wingdings'>l<span style='font:7.0pt "Times New Roman"'>&nbsp;
</span></span><span style='font-family:华文楷体'>时序模式关联规则：在一些应用场景中，关联规则可能涉及到序列特征，即存在基于时间或空间的先后次序。例如：通过店铺订单数据，我们可能发现顾客会先购买<span
lang=EN-US>PC</span>，再购买机械键盘、显示器等外设，接着购买电脑保护套、键盘清洁泥等小工具。这就是一种序列模式。时序模式关联规则就是包含序列模式信息的关联规则。</span></p>

<p class=MsoListParagraph style='margin-left:64.7pt;text-indent:-21.0pt'><span
lang=EN-US style='font-family:Wingdings'>l<span style='font:7.0pt "Times New Roman"'>&nbsp;
</span></span><span style='font-family:华文楷体'>结构模式关联规则：结构模式是指结构数据集中的频繁子结构。与序列相比，结构是一个更一般的概念，包括有向图、无向图、格、树、序列、集合等，单个项可以看作是最简单的结构模式。结构模式关联规则就是挖掘结构模式得到的关联规则。</span></p>

<p class=MsoNormal style='text-indent:22.7pt'><span style='font-family:华文楷体'>除了上述分类，还有对闭模式、极大模式、不频繁模式、稀有模式、负模式、压缩模式等模式的挖掘而产生的关联规则，我们会在<span
lang=EN-US>18.6</span>节作简单的介绍，有兴趣的同学也可以自行搜索资料了解。下一小节，我们会向你介绍频繁模式的关联规则挖掘的基本框架，使你对关联规则挖掘的流程有全面的了解。</span></p>

<p class=MsoNormal><b><span lang=EN-US style='font-size:12.0pt;font-family:
华文楷体'>18.1.3</span></b><b><span style='font-size:12.0pt;font-family:华文楷体'>关联规则挖掘的基本框架</span></b></p>

<p class=MsoNormal align=center style='margin-top:7.8pt;text-align:center;
text-indent:22.7pt'><b><span style='font-family:华文楷体'>表<span lang=EN-US>18-1 </span>商品<span
lang=EN-US>ID</span>与商品名称对应关系</span></b></p>

<p class=MsoNormal align=center style='margin-top:7.8pt;text-align:center;
text-indent:22.7pt'><b><span style='font-family:华文楷体'>暂略</span></b></p>

<p class=MsoNormal align=center style='margin-top:7.8pt;text-align:center;
text-indent:22.7pt'><b><span lang=EN-US style='font-family:华文楷体'>&nbsp;</span></b></p>

<p class=MsoNormal align=center style='margin-top:7.8pt;text-align:center;
text-indent:22.7pt'><b><span style='font-family:华文楷体'>表<span lang=EN-US>18-2 </span>某电商店铺的事务数据</span></b></p>

<p class=MsoNormal align=center style='margin-top:7.8pt;text-align:center'><span
lang=EN-US><img width=197 height=322 id="图片 42" src="chap18.files/image016.jpg"></span></p>

<p class=MsoNormal style='text-indent:22.7pt'><span style='font-family:华文楷体'>关联规则挖掘任务通常分为两个子任务。</span></p>

<p class=MsoNormal style='text-indent:22.7pt'><span style='font-family:华文楷体'>（<span
lang=EN-US>1</span>）<b>频繁项集发现</b>：目标是找出所有满足最小支持度阈值的项集，这些项集被称为频繁项集。</span></p>

<p class=MsoNormal style='text-indent:22.7pt'><span style='font-family:华文楷体'>（<span
lang=EN-US>2</span>）<b>关联规则产生</b>：目标是从发现的频繁项集中提取出所有满足最小置信度阈值的规则，这些规则被称为强规则。</span></p>

<p class=MsoNormal style='text-indent:22.7pt'><span style='font-family:华文楷体'>在上述例子中，<span
lang=EN-US>I={I1, I2, I3, I4, I5, I6, I7}</span>是所有项的集合，其中能产生</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=14 height=21
src="chap18.files/image017.png"></span><span style='font-family:华文楷体'>种项集组合，其中包括<span
lang=EN-US>1</span>个空集、<span lang=EN-US>7</span>个<span lang=EN-US>1-</span>项集，<span
lang=EN-US>21</span>个<span lang=EN-US>2-</span>项集，<span lang=EN-US>35</span>个<span
lang=EN-US>3-</span>项集，<span lang=EN-US>35</span>个<span lang=EN-US>4-</span>项集，<span
lang=EN-US>21</span>个<span lang=EN-US>5-</span>项集，<span lang=EN-US>7</span>个<span
lang=EN-US>6-</span>项集，<span lang=EN-US>1</span>个<span lang=EN-US>7-</span>项集。我们称这些项集为候选项集。</span></p>

<p class=MsoNormal style='text-indent:22.7pt'><span style='font-family:华文楷体'>那么怎么判断哪些是频繁项集呢？从频繁项集的定义出发，我们只需要计算出每个项集的支持度，再将其与最小支持度阈值比较，满足的即为频繁项集。要计算候选项集的支持度，我们需要确定候选项集的支持度计数。而确定支持度计数的方法很简单，只需要将候选项集与每个事务进行比较，如果候选项集包含在事务中，就增加它的支持度计数。例如，候选项集<span
lang=EN-US>{I2, I3}</span>出现在事务<span lang=EN-US>T002</span>和<span lang=EN-US>T009</span>中，其支持度计数即为<span
lang=EN-US>2</span>，再根据支持度计算公式，其支持度为<span lang=EN-US>0.2</span>。</span></p>

<p class=MsoNormal style='text-indent:22.7pt'><span style='font-family:华文楷体'>按上述方法计算每个候选项集的支持度，并与最小支持度阈值（本例设为<span
lang=EN-US>0.3</span>）比较，最后得到<span lang=EN-US>14</span>个频繁项集，具体如下：</span></p>

<p class=MsoNormal align=center style='text-align:center;text-indent:22.7pt'><span
lang=EN-US><img width=417 height=99 id="图片 43" src="chap18.files/image018.jpg"></span></p>

<p class=MsoNormal style='text-indent:22.7pt'><span style='font-family:华文楷体'>这种频繁项集挖掘方法虽然容易理解，但是计算开销大，需要进行</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=53 height=21
src="chap18.files/image019.png"></span><span style='font-family:华文楷体'>次比较，其中<span
lang=EN-US>N</span>是事务数，</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:3.0pt'><img width=69 height=21
src="chap18.files/image020.png"></span><span style='font-family:华文楷体'>是候选项集数（不含空集），而<span
lang=EN-US>w</span>是事务的最大宽度。在本例中，<span lang=EN-US>N=10</span>，<span lang=EN-US>M=127</span>，<span
lang=EN-US>w=4</span>。而在实际应用中，这几个值可能很大，所以在下一节我们会介绍更好的算法，降低发现频繁项集的计算复杂度。</span></p>

<p class=MsoNormal style='text-indent:22.7pt'><span lang=EN-US
style='font-family:华文楷体'>&nbsp;</span></p>

<p class=MsoNormal style='text-indent:22.7pt'><span style='font-family:华文楷体'>得到频繁项集后，我们需要从这些频繁项集中提取出关联规则（强规则）。提取的方式可以简要地概括如下：将频繁项集<span
lang=EN-US>Y</span>划分成两个非空子集</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=8 height=21
src="chap18.files/image014.png"></span><span style='font-family:华文楷体'>和</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=33 height=21
src="chap18.files/image021.png"></span><span style='font-family:华文楷体'>，得到候选关联规则</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=60 height=21
src="chap18.files/image022.png"></span><span style='font-family:华文楷体'>，然后计算该候选关联规则的置信度，若满足最小置信度阈值，则该关联规则就是强规则，否则舍弃。注意，</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=8 height=21
src="chap18.files/image014.png"></span><span style='font-family:华文楷体'>和</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=33 height=21
src="chap18.files/image021.png"></span><span style='font-family:华文楷体'>必须是非空子集，因为</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=36 height=21
src="chap18.files/image023.png"></span><span style='font-family:华文楷体'>和</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=36 height=21
src="chap18.files/image024.png"></span><span style='font-family:华文楷体'>没有实际意义。</span></p>

<p class=MsoNormal style='text-indent:22.7pt'><span style='font-family:华文楷体'>以</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=67 height=21
src="chap18.files/image025.png"></span><span style='font-family:华文楷体'>这个频繁项集为例，从中能够产生<span
lang=EN-US>2</span>个候选关联规则：</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=66 height=21
src="chap18.files/image026.png"></span><span style='font-family:华文楷体'>，</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=66 height=21
src="chap18.files/image027.png"></span><span style='font-family:华文楷体'>。由于它们的支持度都等于<span
lang=EN-US>Y</span>的支持度，所以这些候选关联规则必定满足最小支持度阈值。我们需要计算这<span lang=EN-US>2</span>个候选关联规则的置信度，根据置信度计算公式，</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=66 height=21
src="chap18.files/image028.png"></span><span style='font-family:华文楷体'>的置信度为</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:13.0pt'><img width=105 height=42
src="chap18.files/image029.png"></span><span style='font-family:华文楷体'>，而</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=66 height=21
src="chap18.files/image027.png"></span><span style='font-family:华文楷体'>的置信度则为</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:13.0pt'><img width=105 height=42
src="chap18.files/image030.png"></span><span style='font-family:华文楷体'>，最后将计算得到的置信度与最小置信度阈值比较，即可得到我们的目标――强规则。</span></p>

<p class=MsoNormal style='text-indent:22.7pt'><span style='font-family:华文楷体'>每个频繁<span
lang=EN-US>k-</span>项集能够产生</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:3.0pt'><img width=39 height=21
src="chap18.files/image031.png"></span><span style='font-family:华文楷体'>个候选关联规则（除去两个包含空集的关联规则），我们首先从上一步得到的频繁项集中产生候选关联规则，然后一一计算它们的置信度并与最小置信度阈值（本例设为<span
lang=EN-US>0.7</span>）比较，最终就能得到该例下的全部强规则，即我们期望发现的关联规则。在本例中，我们最后能得到<span
lang=EN-US>6</span>条强规则，具体如下：</span></p>

<p class=MsoNormal style='text-indent:22.7pt'><span lang=EN-US
style='font-family:华文楷体'>{I5}</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=15 height=21
src="chap18.files/image032.png"></span><span lang=EN-US style='font-family:
华文楷体'>&nbsp;{I6}, &nbsp;confidence=1.0</span></p>

<p class=MsoNormal style='text-indent:22.7pt'><span lang=EN-US
style='font-family:华文楷体'>{I6}</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=15 height=21
src="chap18.files/image032.png"></span><span lang=EN-US style='font-family:
华文楷体'>&nbsp;{I5}, &nbsp;confidence=1.0</span></p>

<p class=MsoNormal style='text-indent:22.7pt'><span lang=EN-US
style='font-family:华文楷体'>{I1, I5}</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=15 height=21
src="chap18.files/image032.png"></span><span lang=EN-US style='font-family:
华文楷体'>&nbsp;{I6}, &nbsp;confidence=1.0</span></p>

<p class=MsoNormal style='text-indent:22.7pt'><span lang=EN-US
style='font-family:华文楷体'>{I1, I6}</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=15 height=21
src="chap18.files/image032.png"></span><span lang=EN-US style='font-family:
华文楷体'>&nbsp;{I5}, &nbsp;confidence=1.0</span></p>

<p class=MsoNormal style='text-indent:22.7pt'><span lang=EN-US
style='font-family:华文楷体'>{I3, I5}</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=15 height=21
src="chap18.files/image032.png"></span><span lang=EN-US style='font-family:
华文楷体'>&nbsp;{I6}, &nbsp;confidence=1.0</span></p>

<p class=MsoNormal style='text-indent:22.7pt'><span lang=EN-US
style='font-family:华文楷体'>{I3, I6}</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=15 height=21
src="chap18.files/image032.png"></span><span lang=EN-US style='font-family:
华文楷体'>&nbsp;{I5}, &nbsp;confidence=1.0</span></p>

<p class=MsoNormal style='text-indent:22.7pt'><span lang=EN-US
style='font-family:华文楷体'>&nbsp;</span></p>

<p class=MsoNormal style='text-indent:22.7pt'><span style='font-family:华文楷体'>同样，此处介绍的关联规则产生方法虽然容易理解，但是计算开销较大，我们会在<span
lang=EN-US>18.3</span>节介绍更好的算法，降低计算复杂度。</span></p>

<p class=MsoNormal style='text-indent:22.7pt'><span lang=EN-US
style='font-family:华文楷体'>&nbsp;</span></p>

<p class=MsoNormal style='text-indent:22.7pt'><span lang=EN-US
style='font-family:华文楷体'>&nbsp;</span></p>

<p class=MsoNormal><span lang=EN-US style='font-family:华文楷体'>&nbsp;</span></p>

<p class=MsoNormal><b><span lang=EN-US style='font-size:14.0pt;font-family:
华文楷体'>18.2 </span></b><b><span style='font-size:14.0pt;font-family:华文楷体'>频繁项集发现</span></b></p>

<p class=MsoNormal style='text-indent:22.7pt'><span style='font-family:华文楷体'>要降低频繁项集挖掘的计算复杂度，我们可以从以下三个方面进行优化：</span></p>

<p class=MsoListParagraph style='margin-left:58.7pt;text-indent:-36.0pt'><span
lang=EN-US style='font-family:华文楷体'>（1）<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><span style='font-family:华文楷体'>减少候选项集的数目。</span></p>

<p class=MsoListParagraph style='margin-left:58.7pt;text-indent:-36.0pt'><span
lang=EN-US style='font-family:华文楷体'>（2）<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><span style='font-family:华文楷体'>减少候选项集与事务的比较次数。</span></p>

<p class=MsoListParagraph style='margin-left:58.7pt;text-indent:-36.0pt'><span
lang=EN-US style='font-family:华文楷体'>（3）<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span><span style='font-family:华文楷体'>减少事务数目。</span></p>

<p class=MsoNormal style='text-indent:21.0pt'><span style='font-family:华文楷体'>下面，我们将介绍<span
lang=EN-US>Apriori</span>算法、<span lang=EN-US>FP-Tree</span>算法、<span lang=EN-US>Eclat</span>算法，并在<span
lang=EN-US>18.2.4</span>小节中对这几种算法进行比较。</span></p>

<p class=MsoNormal style='text-indent:21.0pt'><span lang=EN-US
style='font-family:华文楷体'>&nbsp;</span></p>

<p class=MsoNormal><b><span lang=EN-US style='font-size:12.0pt;font-family:
华文楷体'>18.2.1 Apriori</span></b><b><span style='font-size:12.0pt;font-family:
华文楷体'>类算法</span></b></p>

<p class=MsoNormal style='text-indent:22.7pt'><a><span lang=EN-US
style='font-family:华文楷体'>Apriori</span></a><span style='font-family:华文楷体'>算法是第一个关联规则挖掘算法，由<span
lang=EN-US>Agrawal</span>和<span lang=EN-US>R.Srikant</span>于<span lang=EN-US>1994</span>年提出，它利用先验原理，开创性地使用了基于支持度的剪枝技术，系统地控制候选项集指数增长。</span><span
class=MsoCommentReference><span lang=EN-US><a class=msocomanchor id="_anchor_2"
onmouseover="msoCommentShow('_anchor_2','_com_2')"
onmouseout="msoCommentHide('_com_2')" href="#_msocom_2" language=JavaScript
name="_msoanchor_2">[l2]</a>&nbsp;</span></span></p>

<p class=MsoNormal style='text-indent:22.7pt'><span style='font-family:华文楷体'>在介绍<span
lang=EN-US>Apriori</span>算法之前，我们需要先理解先验原理，它能帮助我们利用支持度度量，减少产生频繁项集时所需扫描的候选项集个数。</span></p>

<p class=MsoNormal style='text-indent:22.7pt'><b><span style='font-family:华文楷体'>定理
<span lang=EN-US>18.1 </span>先验原理 </span></b><span style='font-family:华文楷体'>如果一个项集是频繁的，则它的所有子集一定也是频繁的。</span></p>

<p class=MsoNormal style='text-indent:22.7pt'><span style='font-family:华文楷体'>为了更好地理解先验原理，我们从一个例子出发。假设项集<span
lang=EN-US>{I1, I3, I4}</span>是频繁项集，而任何包含项集<span lang=EN-US>{I1, I3, I4}</span>的事务一定包含它的子集<span
lang=EN-US>{I1}</span>，<span lang=EN-US>{I3}</span>，<span lang=EN-US>{I4}</span>，<span
lang=EN-US>{I1, I3}</span>，<span lang=EN-US>{I1, I4}</span>，<span lang=EN-US>{I3,
I4}</span>。所以，如果项集<span lang=EN-US>{I1, I3, I4}</span>是频繁的，则它的子集的支持度一定大于或等于它本身的支持度，所以它的子集也都是频繁的。</span></p>

<p class=MsoNormal style='text-indent:22.7pt'><span style='font-family:华文楷体'>相反，如果一个项集是非频繁的，那么它的所有超集也都是非频繁的。例如，假设项集<span
lang=EN-US>{I1, I3}</span>是非频繁的，则如<span lang=EN-US>{I1, I3, I4}</span>，<span
lang=EN-US>{I1, I3, I5, I6}</span>等<span lang=EN-US>{I1, I3}</span>的超集的支持度一定小于或等于<span
lang=EN-US>{I1, I3}</span>的支持度，所以它的所有超集都是非频繁的。<a>利用这一点，我们就能有效减少候选项集的数目，这种基于支持度度量修剪指数搜索空间的策略称为基于支持度的剪枝。而这种剪枝策略依赖于支持度度量的一个重要性质――反单调性。</a></span></p>

<p class=MsoNormal style='text-indent:22.7pt'><b><span style='font-family:华文楷体'>定义
<span lang=EN-US>18.1 </span>反单调性 </span></b><span style='font-family:华文楷体'>如果对于项集<span
lang=EN-US>Y</span>的每个真子集<span lang=EN-US>X</span>（即</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=34 height=21
src="chap18.files/image033.png"></span><span style='font-family:华文楷体'>），有</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=66 height=21
src="chap18.files/image034.png"></span><span style='font-family:华文楷体'>，那么称度量<span
lang=EN-US>f</span>具有反单调性。</span></p>

<p class=MsoNormal style='text-indent:22.7pt'><span style='font-family:华文楷体'>对于支持度度量来说，即一个项集的支持度绝不会超过它的子集的支持度。而除了支持度度量，一些其它度量也具有反单调性，同样能够应用在挖掘算法中，以有效地修剪候选项集的指数搜索空间。</span><span
class=MsoCommentReference><span lang=EN-US><a class=msocomanchor id="_anchor_3"
onmouseover="msoCommentShow('_anchor_3','_com_3')"
onmouseout="msoCommentHide('_com_3')" href="#_msocom_3" language=JavaScript
name="_msoanchor_3">[l3]</a>&nbsp;</span></span></p>

<p class=MsoNormal style='text-indent:22.7pt'><span style='font-family:华文楷体'>了解了先验原理，下面我们将结合具体实例来介绍<span
lang=EN-US>Apriori</span>算法。</span></p>

<p class=MsoNormal style='text-indent:22.7pt'><span lang=EN-US
style='font-family:华文楷体'>Apriori</span><span style='font-family:华文楷体'>算法的基本思想是通过逐层搜索迭代，用上一轮迭代得到的<span
lang=EN-US>k</span>项集来探索下一轮迭代的（<span lang=EN-US>k+1</span>）项集。初始时，我们将每个项都看作候选<span
lang=EN-US>1-</span>项集，其集合记为</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=14 height=21
src="chap18.files/image035.png"></span><span style='font-family:华文楷体'>，对它们进行支持度计数后，满足最小支持度阈值的项集被留下，构成频繁<span
lang=EN-US>1-</span>项集，其集合记为</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=13 height=21
src="chap18.files/image036.png"></span><span style='font-family:华文楷体'>。在第二轮迭代中，利用</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=13 height=21
src="chap18.files/image036.png"></span><span style='font-family:华文楷体'>来生成候选<span
lang=EN-US>2-</span>项集的集合</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=14 height=21
src="chap18.files/image037.png"></span><span style='font-family:华文楷体'>，然后利用先验原理进行剪枝，只保留那些所有子集都频繁的候选<span
lang=EN-US>2-</span>项集，再对这些候选<span lang=EN-US>2-</span>项集进行支持度计数，与最小支持度阈值比较，得到频繁<span
lang=EN-US>2-</span>项集的集合</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=14 height=21
src="chap18.files/image038.png"></span><span style='font-family:华文楷体'>，在下一轮迭代，再以同样方法找出</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=14 height=21
src="chap18.files/image039.png"></span><span style='font-family:华文楷体'>，如此迭代下去，直到不能再发现频繁<span
lang=EN-US>k</span>项集为止。</span></p>

<p class=MsoNormal align=center style='margin-top:7.8pt;text-align:center;
text-indent:22.7pt'><b><span style='font-family:华文楷体'>表<span lang=EN-US>18-2 </span>某电商店铺的事务数据</span></b></p>

<p class=MsoNormal align=center style='text-align:center;text-indent:22.7pt'><span
lang=EN-US><img width=189 height=309 id="图片 33" src="chap18.files/image040.jpg"></span></p>

<p class=MsoNormal style='text-indent:22.7pt'><span style='font-family:华文楷体'>以<span
lang=EN-US>18.1.3</span>小节中的数据为例，共有<span lang=EN-US>10</span>个事务，设定最小支持度阈值为<span
lang=EN-US>0.3</span>，即最小支持度计数为<span lang=EN-US>3</span>。</span></p>

<p class=MsoNormal style='text-indent:22.7pt'><span style='font-family:华文楷体'>第一轮迭代：每个项都是候选<span
lang=EN-US>1-</span>项集的集合</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=14 height=21
src="chap18.files/image035.png"></span><span style='font-family:华文楷体'>的成员，算法扫描全部事务，对每个候选<span
lang=EN-US>1-</span>项集的出现次数计数。将每个候选项集的支持度计数与最小支持度计数比较，得到频繁<span lang=EN-US>1-</span>项集的集合</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=13 height=21
src="chap18.files/image036.png"></span><span style='font-family:华文楷体'>，在本例中，<span
lang=EN-US>{I4}</span>的支持度计数不满足最小支持度计数，被剪去。</span></p>

<p class=MsoNormal align=center style='text-align:center;text-indent:22.7pt'><span
lang=EN-US><img width=418 height=234 id="图片 1" src="chap18.files/image041.jpg"></span></p>

<p class=MsoNormal align=center style='margin-bottom:7.8pt;text-align:center'><b><span
style='font-family:华文楷体'>图<span lang=EN-US>18-1 </span>第一轮迭代过程</span></b></p>

<p class=MsoNormal style='text-indent:22.7pt'><span style='font-family:华文楷体'>第二轮迭代：通过</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=46 height=21
src="chap18.files/image042.png"></span><span style='font-family:华文楷体'>来产生候选<span
lang=EN-US>2-</span>项集的集合</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=14 height=21
src="chap18.files/image037.png"></span><span style='font-family:华文楷体'>，共有<span
lang=EN-US>15</span>个<span lang=EN-US>2-</span>项集，由于它们的所有子集都是频繁的，所以没有候选被删除。然后对</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=14 height=21
src="chap18.files/image037.png"></span><span style='font-family:华文楷体'>中的每个候选进行支持度计数。将每个候选项集的支持度计数与最小支持度计数比较，得到</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=14 height=21
src="chap18.files/image038.png"></span><span style='font-family:华文楷体'>。</span></p>

<p class=MsoNormal align=center style='text-align:center'><span lang=EN-US><img
width=554 height=348 id="图片 35" src="chap18.files/image043.jpg"></span></p>

<p class=MsoNormal align=center style='margin-bottom:7.8pt;text-align:center'><b><span
style='font-family:华文楷体'>图<span lang=EN-US>18-2 </span>第二轮迭代过程</span></b></p>

<p class=MsoNormal style='text-indent:22.7pt'><span style='font-family:华文楷体'>第三轮迭代：通过</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=47 height=21
src="chap18.files/image044.png"></span><span style='font-family:华文楷体'>来产生候选<span
lang=EN-US>3-</span>项集的集合</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=14 height=21
src="chap18.files/image045.png"></span><span style='font-family:华文楷体'>，共有<span
lang=EN-US>4</span>个<span lang=EN-US>3-</span>项集，具体为</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=94 height=21
src="chap18.files/image046.png"></span><span lang=EN-US style='font-family:
华文楷体'>{{I1, I3, I5}, {I1, I3, I6}, {I1, I5, I6}, {I3, I5, I6}}</span><span
style='font-family:华文楷体'>。根据先验原理，这四个候选项集的所有子集都是频繁的，所以这四个项集的集合构成</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=14 height=21
src="chap18.files/image037.png"></span><span style='font-family:华文楷体'>。然后对</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=14 height=21
src="chap18.files/image037.png"></span><span style='font-family:华文楷体'>中的每个候选进行支持度计数，将每个候选项集的支持度计数与最小支持度计数比较，得到</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=14 height=21
src="chap18.files/image039.png"></span><span style='font-family:华文楷体'>。</span></p>

<p class=MsoNormal><span lang=EN-US><img width=554 height=133 id="图片 36"
src="chap18.files/image047.jpg"></span></p>

<p class=MsoNormal align=center style='margin-bottom:7.8pt;text-align:center'><b><span
style='font-family:华文楷体'>图<span lang=EN-US>18-3 </span>第三轮迭代过程</span></b></p>

<p class=MsoNormal style='text-indent:22.7pt'><span style='font-family:华文楷体'>第四轮迭代：通过</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=47 height=21
src="chap18.files/image048.png"></span><span style='font-family:华文楷体'>来产生候选<span
lang=EN-US>4-</span>项集的集合</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=14 height=21
src="chap18.files/image049.png"></span><span style='font-family:华文楷体'>，其中只有一个候选<span
lang=EN-US>4-</span>项集<span lang=EN-US>{I1, I3, I5, I6}</span>，而根据先验原理，它不满足所有的子集都是频繁的条件，所以</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=41 height=21
src="chap18.files/image050.png"></span><span style='font-family:华文楷体'>，因此算法终止，我们成功得到了全部频繁项集。</span></p>

<p class=MsoNormal style='text-indent:22.7pt'><span lang=EN-US
style='font-family:华文楷体'>&nbsp;</span></p>

<p class=MsoNormal style='text-indent:22.7pt'><span style='font-family:华文楷体'>下面给出<span
lang=EN-US>Apriori</span>算法产生频繁项集的伪代码。</span></p>

<p class=MsoNormal style='text-indent:22.7pt'><span lang=EN-US
style='font-family:华文楷体'>&nbsp;</span></p>

<p class=MsoNormal style='text-indent:22.7pt'><a><span style='font-family:华文楷体'>下面分析该算法的复杂度。（与穷举法比较）</span></a><span
class=MsoCommentReference><span lang=EN-US><a class=msocomanchor id="_anchor_4"
onmouseover="msoCommentShow('_anchor_4','_com_4')"
onmouseout="msoCommentHide('_com_4')" href="#_msocom_4" language=JavaScript
name="_msoanchor_4">[l4]</a>&nbsp;</span></span></p>

<p class=MsoNormal style='text-indent:22.7pt'><span lang=EN-US
style='font-family:华文楷体'>&nbsp;</span></p>

<p class=MsoNormal style='text-indent:22.7pt'><span style='font-family:华文楷体'>那么如何才能进一步提高<span
lang=EN-US>Apriori</span>算法的效率呢？下面，我们将简单介绍一些经过实践验证且比较有效的优化方法。</span></p>

<p class=MsoNormal style='text-indent:22.7pt'><b><span style='font-family:华文楷体'>基于散列优化支持度计数
</span></b><span style='font-family:华文楷体'>首先，需要设置一个合理的散列函数，当散列<span lang=EN-US>k-</span>项集时，散列函数就有<span
lang=EN-US>k</span>个自变量。如散列<span lang=EN-US>2-</span>项集时，可以设散列函数如下：</span></p>

<p class=MsoNormal style='text-indent:22.7pt'><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif"'><img
width=211 height=21 src="chap18.files/image051.png"></span></p>

<p class=MsoNormal style='text-indent:22.7pt'><span style='font-family:华文楷体'>其中<span
lang=EN-US>x</span>是项，</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=28 height=21
src="chap18.files/image052.png"></span><span style='font-family:华文楷体'>是一个自定义的映射，将项映射到一个数值，比如</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=61 height=21
src="chap18.files/image053.png"></span><span style='font-family:华文楷体'>。当需要从</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=27 height=21
src="chap18.files/image054.png"></span><span style='font-family:华文楷体'>生成</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=14 height=21
src="chap18.files/image055.png"></span><span style='font-family:华文楷体'>时，我们可以扫描一次全部事务，然后生成全部候选<span
lang=EN-US>k-</span>项集，将它们按照散列函数散列到不同的桶中，统计每个桶的项集个数。如果一个桶的项集个数低于最小支持度阈值，则这个桶内的全部项集都可以排除，从而减少了候选<span
lang=EN-US>k-</span>项集的数量。经过实践，当<span lang=EN-US>k=2</span>时，优化效果尤为明显。</span></p>

<p class=MsoNormal style='text-indent:22.7pt'><b><span style='font-family:华文楷体'>压缩迭代时扫描的事务数
</span></b><span style='font-family:华文楷体'>如果一个事务，不包含任何一个频繁<span lang=EN-US>k-</span>项集，那么这个事务也一定不包含任何一个频繁（<span
lang=EN-US>k+1</span>）<span lang=EN-US>-</span>项集。因此，在产生频繁<span lang=EN-US>k-</span>项集的集合</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=14 height=21
src="chap18.files/image056.png"></span><span style='font-family:华文楷体'>后，如果一个事务满足这一点，就可以将其删除或标记，在之后的迭代中不再需要考虑。</span></p>

<p class=MsoNormal style='text-indent:22.7pt'><b><span style='font-family:华文楷体'>基于划分快速寻找频繁项集
</span></b><span style='font-family:华文楷体'>划分技术是分治思想的体现。首先，我们将全部事务尽量均匀地划分为<span
lang=EN-US>n</span>个分组，然后根据最小支持度阈值，找出每个分组中的频繁项集，称为局部频繁项集。接着，我们将全体局部频繁项集作为候选项集，再次扫描全部事务，计算每个候选项集的实际支持度，与最小支持度阈值比较后，得到全局频繁项集。值得一提的是，如果每个分组的大小都能放入内存，那么运行效率就会较快，我们可以依次确定分组的数量。</span></p>

<p class=MsoNormal style='text-indent:22.7pt'><b><span style='font-family:华文楷体'>抽样搜索频繁项集
</span></b><span style='font-family:华文楷体'>首先，我们从全部事务中随机抽取部分事务集合<span
lang=EN-US>S</span>，然后在<span lang=EN-US>S</span>中寻找频繁项集，通常会控制<span lang=EN-US>S</span>的大小，使其能装入主存，使得扫描一遍即可完成计算。显而易见，这种方法虽然减少了事务数，但是会遗漏部分频繁项集。为了降低这种可能性，我们在<span
lang=EN-US>S</span>中寻找频繁项集时，设定更小的最小支持度阈值，找到<span lang=EN-US>S</span>中的频繁项集后，我们使用一种机制来确定是否有遗漏，若有遗漏，则需要对全部事务进行第二次扫描，反之，就结束搜索。这种方法通常应用在效率优先的场合。</span></p>

<p class=MsoNormal><b><span lang=EN-US style='font-family:华文楷体'>&nbsp;</span></b></p>

<p class=MsoNormal><b><span lang=EN-US style='font-size:12.0pt;font-family:
华文楷体'>18.2.2 FP-tree</span></b><b><span style='font-size:12.0pt;font-family:
华文楷体'>算法</span></b></p>

<p class=MsoNormal style='text-indent:22.7pt'><span style='font-family:华文楷体'>这一小节我们将介绍一种完全不同于<span
lang=EN-US>Apriori</span>算法的频繁项集挖掘方法，这种方法由韩嘉炜等人于<span lang=EN-US>2000</span>年提出，名为频繁模式增长（<span
lang=EN-US>Frequent-Pattern Growth</span>），它通过使用一种紧凑的数据结构――<span lang=EN-US>FP</span>树（<span
lang=EN-US>FP-tree</span>）来组织数据，并从中发现频繁项集，所以也被称为<span lang=EN-US>FP-tree</span>算法。</span></p>

<p class=MsoNormal style='text-indent:22.7pt'><span lang=EN-US
style='font-family:华文楷体'>FP-tree</span><span style='font-family:华文楷体'>算法的基本思想是依次读入每个事务，构造出<span
lang=EN-US>FP-tree</span>，然后自底向上探索<span lang=EN-US>FP-tree</span>的全部路径，查找出全部频繁项集。这个方法也可以分为两步，首先是构造出<span
lang=EN-US>FP-tree</span>，然后是由<span lang=EN-US>FP-tree</span>产生频繁项集。</span></p>

<p class=MsoNormal style='text-indent:22.7pt'><span style='font-family:华文楷体'>同样以<span
lang=EN-US>18.1.3</span>节中的数据为例，设定最小支持度阈值为<span lang=EN-US style='background:
yellow'>0.2</span>，即最小支持度计数为<span lang=EN-US style='background:yellow'>2</span>。</span></p>

<p class=MsoNormal style='text-indent:22.7pt'><span style='font-family:华文楷体'>第一次扫描全部事务，得到每个<span
lang=EN-US>1-</span>项集的支持度计数，与最小支持度计数比较后，<span lang=EN-US>{I4}</span>被剪枝，剩余的构成频繁<span
lang=EN-US>1-</span>项集的集合，并将它们按支持度递减排序。</span></p>

<p class=MsoNormal style='text-indent:22.7pt'><span style='font-family:华文楷体'>第二次扫描，就开始构建<span
lang=EN-US>FP-tree</span>。第一步，创建根结点，标记为“<span lang=EN-US>null</span>”。然后读入第一个事务<span
lang=EN-US>{I1</span>，<span lang=EN-US>I2}</span>，构造这两个项的结点，并按照支持度递减的次序处理，形成</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=87 height=21
src="chap18.files/image057.png"></span><span style='font-family:华文楷体'>的路径，路径上结点的计数增加<span
lang=EN-US>1</span>，初始为<span lang=EN-US>0</span>。接着读入第二个事务<span lang=EN-US>{I2</span>，<span
lang=EN-US>I3</span>，<span lang=EN-US>I5</span>，<span lang=EN-US>I6}</span>，需要创建<span
lang=EN-US>I2</span>、<span lang=EN-US>I3</span>、<span lang=EN-US>I5</span>、<span
lang=EN-US>I6</span>的结点，形成</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=150 height=21
src="chap18.files/image058.png"></span><span style='font-family:华文楷体'>的路径，这四个结点的计数增加<span
lang=EN-US>1</span>。同理读入第三个事务<span lang=EN-US>{I3</span>，<span lang=EN-US>I5</span>，<span
lang=EN-US>I6}</span>。再读入第四个事务<span lang=EN-US>{I1</span>，<span lang=EN-US>I3</span>，<span
lang=EN-US>I7}</span>，由于该事务的第一个项也是<span lang=EN-US>I1</span>，所以只需创建<span
lang=EN-US>I3</span>和<span lang=EN-US>I7</span>的结点，该事务的路径</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=119 height=21
src="chap18.files/image059.png"></span><span style='font-family:华文楷体'>与第一个事务的路径</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=87 height=21
src="chap18.files/image057.png"></span><span style='font-family:华文楷体'>部分重叠。读入前<span
lang=EN-US>4</span>个事务的<span lang=EN-US>FP-tree</span>的构建过程如图<span lang=EN-US>18-4</span>所示。</span></p>

<p class=MsoNormal style='text-indent:22.7pt'><span style='font-family:华文楷体'>继续读入剩余的<span
lang=EN-US>6</span>个事务，按上述步骤依次处理，最后便能得到完整的<span lang=EN-US>FP-tree</span>。为了使遍历<span
lang=EN-US>FP-tree</span>更加快捷，我们将频繁<span lang=EN-US>1-</span>项集的集合与<span
lang=EN-US>FP-tree</span>链接，通过结点链，使每个项都能在<span lang=EN-US>FP-tree</span>中快速定位，最后得到的<span
lang=EN-US>FP-tree</span>如图<span lang=EN-US>18-5</span>所示。建议同学们自己动手尝试一下，从而更好地理解<span
lang=EN-US>FP-tree</span>的构建过程。</span></p>

<p class=MsoNormal align=center style='text-align:center;text-indent:22.7pt'><span
lang=EN-US><img width=452 height=336 id="图片 13" src="chap18.files/image060.jpg"></span></p>

<p class=MsoNormal align=center style='margin-bottom:7.8pt;text-align:center'><b><span
style='font-family:华文楷体'>图<span lang=EN-US>18-4 </span>依次读入前<span lang=EN-US>4</span>个事务的<span
lang=EN-US>FP-tree</span></span></b></p>

<p class=MsoNormal align=center style='text-align:center;text-indent:22.7pt'><span
lang=EN-US style='font-family:华文楷体'>&nbsp;</span></p>

<p class=MsoNormal align=center style='text-align:center;text-indent:22.7pt'><span
lang=EN-US><img width=524 height=197 id="图片 22" src="chap18.files/image061.jpg"></span></p>

<p class=MsoNormal align=center style='margin-bottom:7.8pt;text-align:center'><b><span
style='font-family:华文楷体'>图<span lang=EN-US>18-5 </span>读入全部事务的<span lang=EN-US>FP-tree</span></span></b></p>

<p class=MsoNormal align=left style='text-align:left;text-indent:22.7pt'><span
lang=EN-US style='font-family:华文楷体'>&nbsp;</span></p>

<p class=MsoNormal align=left style='text-align:left;text-indent:22.7pt'><span
style='font-family:华文楷体'>得到<span lang=EN-US>FP-tree</span>后，我们就可以在其中进行频繁模式挖掘了。首先，从全局来看，我们可以将全体频繁项集的集合分为多个小集合，在本例中，可以将全体频繁项集的集合划分为分别以<span
lang=EN-US>I1</span>、<span lang=EN-US>I2</span>、<span lang=EN-US>I3</span>、<span
lang=EN-US>I5</span>、<span lang=EN-US>I6</span>、<span lang=EN-US>I7</span>结尾的频繁项集集合，其中每个频繁项集中的项都按照支持度递减排序，从而避免重复。在这里，我们利用了分治的思想，将一个规模较大的问题转化为了<span
lang=EN-US>6</span>个规模较小的问题。下面，我们就来解决挖掘以某个项结尾的频繁项集的子问题。</span></p>

<p class=MsoNormal align=left style='text-align:left;text-indent:22.7pt'><span
style='font-family:华文楷体'>我们首先考虑挖掘以<span lang=EN-US>I7</span>结尾的频繁项集集合，因为<span
lang=EN-US>I7</span>的支持度最低，按支持度由低到高来解决这<span lang=EN-US>6</span>个子问题是有理由的，我们之后会进行解释，暂且先将注意力集中到这个子问题上。观察图<span
lang=EN-US>18-5</span>中的<span lang=EN-US>FP-tree</span>，根据结点链，我们发现<span
lang=EN-US>I7</span>出现在<span lang=EN-US>3</span>个分枝中，对应的路径分别是</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=160 height=21
src="chap18.files/image062.png"></span><span style='font-family:华文楷体'>、</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=160 height=21
src="chap18.files/image063.png"></span><span style='font-family:华文楷体'>和</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=114 height=21
src="chap18.files/image064.png"></span><span style='font-family:华文楷体'>。<span
lang=EN-US>{I7}</span>本身是频繁项集，再考虑以<span lang=EN-US>I7</span>为结尾，有</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=72 height=21
src="chap18.files/image065.png"></span><span style='font-family:华文楷体'>、</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=72 height=21
src="chap18.files/image066.png"></span><span style='font-family:华文楷体'>和</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=26 height=21
src="chap18.files/image067.png"></span><span style='font-family:华文楷体'>三条前缀路径。由于这些路径中存在某些事务并不包含<span
lang=EN-US style='background:yellow'>I6</span>，所以我们要将那些事务去除，更新前缀路径上的支持度计数，即得到</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=72 height=21
src="chap18.files/image068.png"></span><span style='font-family:华文楷体'>、</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=72 height=21
src="chap18.files/image069.png"></span><span style='font-family:华文楷体'>和</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=26 height=21
src="chap18.files/image067.png"></span><span style='font-family:华文楷体'>三条前缀路径，将这三条前缀路径上的项以及它们的支持度计数看作事务数据库中的数据，可以得到“子事务数据库”，也称为<span
lang=EN-US style='background:yellow'>I6</span>的<b>条件模式基</b>。再根据条件模式基来构造<span
lang=EN-US>FP-tree</span>，将其称为<span lang=EN-US style='background:yellow'>I6</span>的条件<span
lang=EN-US>FP-tree</span>，如图<span lang=EN-US>18-6</span>所示。</span></p>

<p class=MsoNormal align=center style='text-align:center;text-indent:22.7pt'><span
lang=EN-US><img width=484 height=146 id="图片 28" src="chap18.files/image070.jpg"></span></p>

<p class=MsoNormal align=center style='margin-bottom:7.8pt;text-align:center'><b><span
style='font-family:华文楷体'>图<span lang=EN-US>18-6&nbsp; I7</span>的条件<span
lang=EN-US>FP-tree</span></span></b></p>

<p class=MsoNormal style='text-indent:22.7pt'><span style='font-family:华文楷体'>由于<span
lang=EN-US>I7</span>的条件<span lang=EN-US>FP-tree</span>中，所有可能的前缀项集的支持度计数都小于最小支持度阈值<span
lang=EN-US>3</span>，所以我们不必继续探索，可以得出结论：除去<span lang=EN-US>{I7}</span>本身外，不存在以<span
lang=EN-US>I7</span>结尾的频繁项集。（此后，我们不再指出除去结尾本身的频繁项集这一点）</span></p>

<p class=MsoNormal style='text-indent:22.7pt'><span style='font-family:华文楷体'>然后我们要解决下一个子问题，即挖掘以<span
lang=EN-US>I2</span>结尾的频繁项集，因为<span lang=EN-US>I2</span>的支持度次低。以同样的步骤得到<span
lang=EN-US>I2</span>的条件模式基，并构建<span lang=EN-US>I2</span>的条件<span lang=EN-US>FP-tree</span>，如图<span
lang=EN-US>18-7</span>所示。</span></p>

<p class=MsoNormal align=center style='text-align:center;text-indent:22.7pt'><span
lang=EN-US><img width=485 height=189 id="图片 27" src="chap18.files/image071.jpg"></span></p>

<p class=MsoNormal align=center style='margin-bottom:7.8pt;text-align:center'><b><span
style='font-family:华文楷体'>图<span lang=EN-US>18-7&nbsp; I2</span>的条件<span
lang=EN-US>FP-tree</span></span></b></p>

<p class=MsoNormal style='text-indent:22.7pt'><span style='font-family:华文楷体'>同样，<span
lang=EN-US>I2</span>的所有可能前缀项集的支持度计数也都小于<span lang=EN-US>3</span>，所以可以得出结论：不存在以<span
lang=EN-US>I2</span>结尾的频繁项集。</span></p>

<p class=MsoNormal align=left style='text-align:left;text-indent:22.7pt'><span
style='font-family:华文楷体'>接着，我们挖掘以<span lang=EN-US>I6</span>结尾的频繁项集，以同样的步骤可以得到<span
lang=EN-US>I6</span>的条件<span lang=EN-US>FP-tree</span>，如图<span lang=EN-US>18-8</span>所示。</span></p>

<p class=MsoNormal style='text-indent:22.7pt'><span lang=EN-US><img width=472
height=165 id="图片 29" src="chap18.files/image072.jpg"></span></p>

<p class=MsoNormal align=center style='margin-bottom:7.8pt;text-align:center'><b><span
style='font-family:华文楷体'>图<span lang=EN-US>18-8&nbsp; I6</span>的条件<span
lang=EN-US>FP-tree</span></span></b></p>

<p class=MsoNormal style='text-indent:22.7pt'><span style='font-family:华文楷体'>此时，我们发现，有<span
lang=EN-US>3</span>个前缀项集的支持度满足最小支持度阈值，所以我们需要继续探索。让我们再次利用分治思想，挖掘以<span
lang=EN-US>I6</span>结尾的频繁项集的问题可以再次分解为<span lang=EN-US>3</span>个子问题，分别是挖掘以<span
lang=EN-US>{I1, I6}</span>、<span lang=EN-US>{I3, I6}</span>、<span lang=EN-US>{I5,
I6}</span>结尾的频繁项集。同样，以支持度从低到高依次解决每个子问题。首先是挖掘以<span lang=EN-US>{I3, I6}</span>结尾的频繁项集，<span
lang=EN-US>{I3, I6}</span>的支持度计数为<span lang=EN-US>3</span>，满足最小支持度计数，所以是频繁<span
lang=EN-US>2-</span>项集，然后我们按照与之前相同的方式寻找出<span lang=EN-US>{I3, I6}</span>的条件模式基，并构建对应的条件<span
lang=EN-US>FP-tree</span>。如图<span lang=EN-US>18-9</span>（<span lang=EN-US>1</span>）所示。由于其前缀项集支持度计数小于<span
lang=EN-US>3</span>，所以不存在以<span lang=EN-US>{I3, I6}</span>结尾的频繁项集。接着是挖掘以<span
lang=EN-US>{I1, I6}</span>结尾的频繁项集，<span lang=EN-US>{I1, I6}</span>的支持度计数为<span
lang=EN-US>3</span>，所以是频繁<span lang=EN-US>2-</span>项集。而由于其条件<span lang=EN-US>FP-tree</span>为空，所以并未画出，结论是不存在以<span
lang=EN-US>{I1, I6}</span>结尾的频繁项集。</span></p>

<p class=MsoNormal style='text-indent:22.7pt'><span style='font-family:华文楷体'>最后是挖掘以<span
lang=EN-US>{I5, I6}</span>结尾的频繁项集，<span lang=EN-US>{I5, I6}</span>的支持度计数为<span
lang=EN-US>5</span>，所以是频繁<span lang=EN-US>2-</span>项集。其条件<span lang=EN-US>FP-tree</span>如图<span
lang=EN-US>18-9</span>（<span lang=EN-US>2</span>）所示。由于其前缀项集<span lang=EN-US>{I1}</span>和<span
lang=EN-US>{I3}</span>的支持度计数都满足最小支持度计数，所以我们可以再将问题分解为两个子问题，分别是挖掘以<span
lang=EN-US>{I1, I5, I6}</span>和<span lang=EN-US>{I3, I5, I6}</span>为结尾的频繁项集。这两个子问题已经十分清晰，我们便不再画出其条件<span
lang=EN-US>FP-tree</span>，而是直接给出结果。<span lang=EN-US>{I1, I5, I6}</span>和<span
lang=EN-US>{I3, I5, I6}</span>的支持度计数都是<span lang=EN-US>3</span>，所以都是频繁<span
lang=EN-US>3-</span>项集。而以<span lang=EN-US>{I3, I5, I6}</span>结尾的候选<span
lang=EN-US>4-</span>项集只有<span lang=EN-US>{I1, I3, I5, I6}</span>，其支持度计数为<span
lang=EN-US>1</span>，不满足最小支持度计数，以<span lang=EN-US>{I1, I5, I6}</span>结尾的<span
lang=EN-US>4-</span>项集不存在。至此，挖掘以<span lang=EN-US>I6</span>结尾的频繁项集，该子问题求解结束。</span></p>

<p class=MsoNormal align=center style='text-align:center;text-indent:22.7pt'><span
lang=EN-US><img width=567 height=134 id="图片 30" src="chap18.files/image073.jpg"></span></p>

<p class=MsoNormal align=center style='margin-bottom:7.8pt;text-align:center'><b><span
style='font-family:华文楷体'>图<span lang=EN-US>18-9&nbsp; </span>左为<span
lang=EN-US>I3, I6</span>的条件<span lang=EN-US>FP-tree</span>，右为<span lang=EN-US>I5,
I6</span>的条件<span lang=EN-US>FP-tree</span></span></b></p>

<p class=MsoNormal style='text-indent:22.7pt'><span style='font-family:华文楷体'>当然，我们还需要将三个子问题的求解结果合并，得到集合<span
lang=EN-US>{{I1, I5, I6}</span>，<span lang=EN-US>{I3, I5, I6}</span>，<span
lang=EN-US>{I5, I6}</span>，<span lang=EN-US>{I3, I6}</span>，<span lang=EN-US>{I1,
I6}}</span>，这就是通过<span lang=EN-US>FP-tree</span>挖掘得到的以<span lang=EN-US>I6</span>结尾的所有频繁项集（不包括<span
lang=EN-US>{I6}</span>这个频繁<span lang=EN-US>1-</span>项集）。</span></p>

<p class=MsoNormal style='text-indent:22.7pt'><span style='font-family:华文楷体'>接着，按照算法思想，我们继续依次求解以<span
lang=EN-US>I5</span>、<span lang=EN-US>I3</span>、<span lang=EN-US>I1</span>结尾的频繁项集集合，结果如表<span
lang=EN-US>18-3</span>所示。最后，将<span lang=EN-US>FP-tree</span>挖掘结果与频繁<span
lang=EN-US>1-</span>项集的集合</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=13 height=21
src="chap18.files/image036.png"></span><span style='font-family:华文楷体'>合并，就得到了我们所要挖掘的全体频繁项集，不难发现，这与<span
lang=EN-US>18.2.1</span>节中<span lang=EN-US>Apriori</span>算法的挖掘结果是相同的。</span></p>

<p class=MsoNormal align=center style='margin-top:7.8pt;text-align:center;
text-indent:22.7pt'><b><span style='font-family:华文楷体'>表<span lang=EN-US>18-3 FP-tree</span>挖掘结果</span></b></p>

<p class=MsoNormal align=center style='text-align:center'><span lang=EN-US><img
width=554 height=204 id="图片 31" src="chap18.files/image074.jpg"></span></p>

<p class=MsoNormal style='text-indent:22.7pt'><span style='font-family:华文楷体'>下面我们给出<span
lang=EN-US>FP-tree</span>算法产生频繁项集的伪代码。建议同学们结合伪代码再次体会<span lang=EN-US>FP-tree</span>算法的思想。</span></p>

<p class=MsoNormal style='text-indent:22.7pt'><span lang=EN-US
style='font-family:华文楷体'>&nbsp;</span></p>

<p class=MsoNormal style='text-indent:22.7pt'><span lang=EN-US
style='font-family:华文楷体'>&nbsp;</span></p>

<p class=MsoNormal style='text-indent:22.7pt'><span lang=EN-US
style='font-family:华文楷体'>&nbsp;</span></p>

<p class=MsoNormal style='text-indent:22.7pt'><span lang=EN-US
style='font-family:华文楷体'>&nbsp;</span></p>

<p class=MsoNormal style='text-indent:22.7pt'><span lang=EN-US
style='font-family:华文楷体'>&nbsp;</span></p>

<p class=MsoNormal style='text-indent:22.7pt'><span lang=EN-US
style='font-family:华文楷体'>&nbsp;</span></p>

<p class=MsoNormal style='text-indent:22.7pt'><span lang=EN-US
style='font-family:华文楷体'>&nbsp;</span></p>

<p class=MsoNormal style='text-indent:22.7pt'><span lang=EN-US
style='font-family:华文楷体'>&nbsp;</span></p>

<p class=MsoNormal style='text-indent:22.7pt'><span lang=EN-US
style='font-family:华文楷体'>&nbsp;</span></p>

<p class=MsoNormal><span lang=EN-US style='font-family:华文楷体'>&nbsp;</span></p>

<p class=MsoNormal style='text-indent:22.7pt'><span style='font-family:华文楷体'>现在我们来解释一下为什么按支持度由低到高来解决子问题，由于每次选择的是最不频繁的项作为结尾，在搜索频繁模式时能够拥有较好的选择性，即有较多的条件模式基，相应的条件<span
lang=EN-US>FP-tree</span>也更“茂盛”，我们观察表<span lang=EN-US>18-3</span>，可以发现，由上至下，结尾项的支持度是递减的，但是条件模式基的数量却是递增的，这就是较好的选择性的含义。<span
lang=EN-US>FP-tree</span>算法的有趣之处在于压缩事务数据库，递归生成子问题，从而快速搜寻频繁项集。不过，当事务数据库较大时，<span
lang=EN-US>FP-tree</span>也会较大，无法一次性放入主存，导致效率降低。这时，我们可以将事务数据库划分成多个投影数据库，并在每个投影数据库上应用<span
lang=EN-US>FP-tree</span>算法，提高挖掘效率。</span></p>

<p class=MsoNormal style='text-indent:22.7pt'><span style='font-family:华文楷体'>下面我们就来介绍一下如何得到投影数据库并应用<span
lang=EN-US>FP-tree</span>算法。</span></p>

<p class=MsoNormal style='text-indent:22.7pt'><span style='font-family:华文楷体'>让我们从数据库投影的过程开始介绍。首先按照支持度从小到大的顺序，从频繁<span
lang=EN-US>1-</span>项集取出支持度最小的项</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=5 height=21
src="chap18.files/image075.png"></span><span style='font-family:华文楷体'>，然后将原来的事务数据库中包含</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=5 height=21
src="chap18.files/image075.png"></span><span style='font-family:华文楷体'>的事务取出，去除这些事务中的</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=5 height=21
src="chap18.files/image075.png"></span><span style='font-family:华文楷体'>和非频繁项，就得到了原数据库到项</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=5 height=21
src="chap18.files/image075.png"></span><span style='font-family:华文楷体'>的投影数据库。然后，从频繁<span
lang=EN-US>1-</span>项集中取出下一个项</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=8 height=21
src="chap18.files/image076.png"></span><span style='font-family:华文楷体'>，同样将原来的事务数据库中包含</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=8 height=21
src="chap18.files/image076.png"></span><span style='font-family:华文楷体'>的事务取出，并去除这些事务中的</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=8 height=21
src="chap18.files/image076.png"></span><span style='font-family:华文楷体'>、</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=5 height=21
src="chap18.files/image075.png"></span><span style='font-family:华文楷体'>和非频繁项，从而得到了原数据库到项</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=8 height=21
src="chap18.files/image076.png"></span><span style='font-family:华文楷体'>的投影数据库。注意，某一项的投影数据库中，不会包含非频繁项、该项自身、以及按支持度从大到小排序好的频繁<span
lang=EN-US>1-</span>项集中位序比该项靠后的项。之后，只要以相同的方式处理频繁<span lang=EN-US>1-</span>项集中的每个项，我们就将原本的事务数据库划分为了多个投影数据库。</span></p>

<p class=MsoNormal style='text-indent:22.7pt'><span style='font-family:华文楷体'>以<span
lang=EN-US>18.1.3</span>节中的数据为例，假设频繁<span lang=EN-US>1-</span>项集的排序为</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=157 height=21
src="chap18.files/image077.png"></span><span style='font-family:华文楷体'>，我们得到<span
lang=EN-US>6</span>个投影数据库如下：</span></p>

<p class=MsoNormal align=center style='margin-top:7.8pt;text-align:center;
text-indent:22.7pt'><b><span style='font-family:华文楷体'>表<span lang=EN-US>18-3 </span>投影数据库</span></b></p>

<p class=MsoNormal align=center style='text-align:center;text-indent:22.7pt'><span
lang=EN-US><img width=436 height=183 id="图片 4" src="chap18.files/image078.jpg"></span></p>

<p class=MsoNormal style='text-indent:22.7pt'><span style='font-family:华文楷体'>可以发现，对频繁项</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=5 height=21
src="chap18.files/image075.png"></span><span style='font-family:华文楷体'>，其投影数据库中都不包含支持度排序在其之后的项和它自身。表中第三列为按支持度计数筛选后的条件模式基。得到全部投影数据库后，我们只需要在其中条件模式基不为空的投影数据库应用<span
lang=EN-US>FP-tree</span>算法，找到每个投影数据库上的频繁项集，最后将结果合并，即可得到全部频繁项集。细心的同学可能已经发现，投影数据库生成的<span
lang=EN-US>FP-tree</span>和之前原算法生成的条件<span lang=EN-US>FP-tree</span>十分相似，实际上，这两个过程本就是同源的。</span></p>

<p class=MsoNormal style='text-indent:22.7pt'><span style='font-family:华文楷体'>该投影过程只需要扫描一遍数据库，虽然在介绍的时候，我们是依次投影得到各个投影数据库，但实际上，这些投影数据库可以并行生成，并不会互相影响，因此，这个投影方法也被称为<b>并行投影</b>（<b><span
lang=EN-US>parallel projection</span></b>）。</span></p>

<p class=MsoNormal style='text-indent:22.7pt'><span style='font-family:华文楷体'>研究证明，投影后的子数据库所生成的<span
lang=EN-US>FP-tree</span>在大小上通常比原数据库所生成的<span lang=EN-US>FP-tree</span>小几个数量级。因此，通过构造投影数据库，能够使<span
lang=EN-US>FP-tree</span>算法有效地应对大型数据库的应用场景。此时，你可能还会问，那如果投影数据库依旧不能一次性放入主存，该怎么办？一个不难想到的解决方案是继续投影，递归地执行这一过程，直到最终得到的投影数据库能够一次性放入主存为止。</span></p>

<p class=MsoNormal style='text-indent:22.7pt'><span style='font-family:华文楷体'>不过，并行投影在实际应用中，依旧可能遇到一些问题。假设一个事务数据库中的某个事务长度很大且包含很多频繁项，那么在构造到每个频繁项的投影数据库的过程中，这个事务就会被重复投影多次。如果该事务中含</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=12 height=21
src="chap18.files/image079.png"></span><span style='font-family:华文楷体'>个频繁项，那么就会被投影到</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=36 height=21
src="chap18.files/image080.png"></span><span style='font-family:华文楷体'>个投影数据库，该事务就会占据大小约为</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:12.0pt'><img width=98 height=42
src="chap18.files/image081.png"></span><span style='font-family:华文楷体'>的空间，而原先该事务只需要占据大小约为</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=12 height=21
src="chap18.files/image079.png"></span><span style='font-family:华文楷体'>的空间，投影后所占据的空间是原先的</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:12.0pt'><img width=23 height=42
src="chap18.files/image082.png"></span><span style='font-family:华文楷体'>倍，这在许多时候是十分浪费且难以接受的。</span></p>

<p class=MsoNormal style='text-indent:22.7pt'><span style='font-family:华文楷体'>为了克服这个缺点，我们可以使用另一种投影方法――<b>分区投影</b>（<b><span
lang=EN-US>partition projection</span></b>）。分区投影的执行过程和并行投影略有不同，下面我们进行介绍。对于事务数据库中的每个事务，都只投影到项</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=5 height=21
src="chap18.files/image075.png"></span><span style='font-family:华文楷体'>的投影数据库，其中项</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=5 height=21
src="chap18.files/image075.png"></span><span style='font-family:华文楷体'>是该条事务中支持度排序最靠后的频繁项。而具体的投影规则和并行投影一样，即当投影到项</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=5 height=21
src="chap18.files/image075.png"></span><span style='font-family:华文楷体'>时，不包含非频繁项、支持度排序在项</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=5 height=21
src="chap18.files/image075.png"></span><span style='font-family:华文楷体'>之后的频繁项和项</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=5 height=21
src="chap18.files/image075.png"></span><span style='font-family:华文楷体'>自身。这样，扫描一遍事务数据库后，我们得到了初始的投影数据库。接着，我们先在支持度最小的投影数据库上应用<span
lang=EN-US>FP-tree</span>算法，在本例中，即先处理到<span lang=EN-US>I7</span>的投影数据库，因为其初始数据信息是完整的。处理完到<span
lang=EN-US>I7</span>的投影数据库后，我们需要将该投影数据库中的每个事务继续按上述规则进行投影，以确保下一个被处理的投影数据库也拥有完整的数据信息，从而避免遗漏。如图所示，处理完到<span
lang=EN-US>I7</span>的投影数据库后，需要将第一个事务<span lang=EN-US>{I1, I3}</span>继续投影，投影到该事务中支持度最小的<span
lang=EN-US>I3</span>的投影数据库上，得到<span lang=EN-US>{I1}</span>；第二个事务<span
lang=EN-US>{I2}</span>只有一个项，无需投影，因为投影到<span lang=EN-US>I2</span>上也只是空集；第三个事务<span
lang=EN-US>{I2, I3}</span>则需要投影到<span lang=EN-US>I2</span>的投影数据库上，得到<span
lang=EN-US>{I3}</span>。然后我们便可以处理到<span lang=EN-US>I2</span>的投影数据库，挖掘结束后，同样需要将每个事务继续投影，以确保之后处理的数据库拥有完整的数据信息。具体过程不再赘述。当全部投影数据库处理完后，合并挖掘结果，便得到所有的频繁项集。</span></p>

<p class=MsoNormal style='text-indent:22.7pt'><span lang=EN-US><img width=554
height=332 id="图片 5" src="chap18.files/image083.jpg"></span></p>

<p class=MsoNormal align=center style='margin-bottom:7.8pt;text-align:center'><b><span
style='font-family:华文楷体'>图<span lang=EN-US>18-10&nbsp; </span>分区投影过程</span></b></p>

<p class=MsoNormal style='text-indent:22.7pt'><span style='font-family:华文楷体'>在分区投影中，投影数据库的总大小小于原始数据库，克服了并行投影中空间浪费的缺点，并且，它通常只需要较少的内存和<span
lang=EN-US>I/O</span>操作。不过，分区投影必须以特定的顺序依次处理这些投影数据库，并且需要进行多次投影。但总体来说，分区投影的内存需求较低，更适合在实际应用中使用。</span></p>

<p class=MsoNormal style='text-indent:22.7pt'><span lang=EN-US
style='font-family:华文楷体'>&nbsp;</span></p>

<p class=MsoNormal><b><span lang=EN-US style='font-size:12.0pt;font-family:
华文楷体'>18.2.3 Eclat</span></b><b><span style='font-size:12.0pt;font-family:华文楷体'>算法</span></b></p>

<p class=MsoNormal style='text-indent:22.7pt'><span style='font-family:华文楷体'>这一节我们将介绍<span
lang=EN-US>Eclat</span>（<span lang=EN-US>Equivalence CLAss Transformation</span>）算法，也叫做等价类变换算法。它与前面介绍的两个算法不同，它使用垂直数据格式来挖掘频繁项集，而<span
lang=EN-US>Apriori</span>算法和<span lang=EN-US>FP-tree</span>算法都是使用水平数据格式来挖掘频繁项集。那么什么是水平数据格式和垂直数据格式呢？下面我们以具体的例子来表述。</span></p>

<p class=MsoNormal style='text-indent:22.7pt'><span style='font-family:华文楷体'>如表<span
lang=EN-US>18-2</span>所示的数据格式为水平数据格式，即形如<span lang=EN-US>{TID</span>：<span
lang=EN-US>itemset}</span>的数据格式，其中第一列为事务标识号，第二列为事务涉及的项集。而如下表<span lang=EN-US>18-4</span>所示，形如<span
lang=EN-US>{itemset</span>：<span lang=EN-US>TID}</span>的数据格式，被称为垂直数据格式，即第一列为项集，第二列为包含该项集的事务标识号的集合。</span></p>

<p class=MsoNormal align=center style='margin-top:7.8pt;text-align:center;
text-indent:22.7pt'><b><span style='font-family:华文楷体'>表<span lang=EN-US>18-4 </span>垂直数据格式表示的事务数据库</span></b></p>

<p class=MsoNormal align=center style='text-align:center;text-indent:22.7pt'><span
lang=EN-US><img width=298 height=247 id="图片 38" src="chap18.files/image084.jpg"></span></p>

<p class=MsoNormal style='text-indent:22.7pt'><span lang=EN-US
style='font-family:华文楷体'>&nbsp;</span></p>

<p class=MsoNormal style='text-indent:22.7pt'><span style='font-family:华文楷体'>理解了垂直数据格式，我们来介绍<span
lang=EN-US>Eclat</span>算法的基本思想。和<span lang=EN-US>Apriori</span>算法类似，<span
lang=EN-US>Eclat</span>算法也是通过逐层迭代来产生频繁项集，即通过频繁<span lang=EN-US>k-</span>项集的集合</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=14 height=21
src="chap18.files/image056.png"></span><span style='font-family:华文楷体'>来生成</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=27 height=21
src="chap18.files/image085.png"></span><span style='font-family:华文楷体'>，其中同样利用了<span
lang=EN-US>18.2.1</span>小节中介绍的先验原理。但是挖掘的数据格式不同，每次迭代产生频繁项集的过程自然也不同。在垂直数据格式中，项集的支持度很容易得到，即<span
lang=EN-US>TID</span>集的长度。得到频繁<span lang=EN-US>k-</span>项集后，我们对<span
lang=EN-US>TID</span>集取交集，对项集取并集，再计算对应的（<span lang=EN-US>k+1</span>）项集的支持度，与最小支持度阈值比较，就可以得到频繁（<span
lang=EN-US>k+1</span>）<span lang=EN-US>-</span>项集的集合</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=27 height=21
src="chap18.files/image085.png"></span><span style='font-family:华文楷体'>。如此继续下去，<span
lang=EN-US>k</span>逐渐递增，直到不再产生频繁项集为止。</span></p>

<p class=MsoNormal style='text-indent:22.7pt'><span style='font-family:华文楷体'>下面我们就以表<span
lang=EN-US>18.2</span>的数据为例，设定最小支持度计数为<span lang=EN-US>3</span>，来介绍<span
lang=EN-US>Eclat</span>算法的执行流程。第一步，扫描一次事务数据库，将水平格式数据转换为垂直格式，得到表<span
lang=EN-US>18-4</span>所示数据。对每行项集计算<span lang=EN-US>TID</span>长度，即为相应的支持度计数，与最小支持度计数比较，得到频繁<span
lang=EN-US>1-</span>项集的集合</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=13 height=21
src="chap18.files/image036.png"></span><span style='font-family:华文楷体'>。然后，对全部频繁项集两两求并集，同时对它们的<span
lang=EN-US>TID</span>集两两求交集，得到垂直数据格式的<span lang=EN-US>2-</span>项集。</span></p>

<p class=MsoNormal align=center style='margin-top:7.8pt;text-align:center;
text-indent:22.7pt'><b><span style='font-family:华文楷体'>表<span lang=EN-US>18-5 </span>垂直数据格式表示的<span
lang=EN-US>2-</span>项集</span></b></p>

<p class=MsoNormal align=left style='text-align:left;text-indent:22.7pt'><span
lang=EN-US><img width=534 height=251 id="图片 39" src="chap18.files/image086.jpg"></span></p>

<p class=MsoNormal style='text-indent:22.7pt'><span style='font-family:华文楷体'>根据表<span
lang=EN-US>18-5</span>很容易得到每个<span lang=EN-US>2-</span>项集的支持度，然后与最小支持度计数比较后，得到频繁<span
lang=EN-US>2-</span>项集如表<span lang=EN-US>18-6</span>所示。接着，我们要通过</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=14 height=21
src="chap18.files/image038.png"></span><span style='font-family:华文楷体'>来生成</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=14 height=21
src="chap18.files/image039.png"></span><span style='font-family:华文楷体'>。由于并非所有的<span
lang=EN-US>2-</span>项集都是频繁项集，这时先验原理就派上用场了。根据先验原理，只有每个<span lang=EN-US>2-</span>项集子集都是频繁项集的<span
lang=EN-US>3-</span>项集才可能是频繁<span lang=EN-US>3-</span>项集。这样，我们得到四个候选<span
lang=EN-US>3-</span>项集，即<span lang=EN-US>{I1, I3, I5}, {I1, I3, I6}, {I1, I5,
I6}, {I3, I5, I6}</span>，对每个候选<span lang=EN-US>3-</span>项集，取它的任意两个<span
lang=EN-US>2-</span>项集，对项集作并运算，对<span lang=EN-US>TID</span>集作交运算，结果如表<span
lang=EN-US>18-7</span>所示。</span></p>

<p class=MsoNormal align=center style='margin-top:7.8pt;text-align:center;
text-indent:22.7pt'><b><span style='font-family:华文楷体'>表<span lang=EN-US>18-6 </span>垂直数据格式表示的频繁<span
lang=EN-US>2-</span>项集</span></b></p>

<p class=MsoNormal align=center style='text-align:center;text-indent:22.7pt'><span
lang=EN-US><img width=326 height=237 id="图片 40" src="chap18.files/image087.jpg"></span></p>

<p class=MsoNormal align=center style='margin-top:7.8pt;text-align:center;
text-indent:22.7pt'><b><span style='font-family:华文楷体'>表<span lang=EN-US>18-7 </span>垂直数据格式表示的<span
lang=EN-US>3-</span>项集</span></b></p>

<p class=MsoNormal align=center style='text-align:center;text-indent:22.7pt'><span
lang=EN-US><img width=353 height=187 id="图片 41" src="chap18.files/image088.jpg"></span></p>

<p class=MsoNormal style='text-indent:22.7pt'><span style='font-family:华文楷体'>其中项集<span
lang=EN-US>{I1, I5, I6}</span>和<span lang=EN-US>{I3, I5, I6}</span>满足最小支持度计数，所以是频繁<span
lang=EN-US>3-</span>项集，它们构成了</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=14 height=21
src="chap18.files/image039.png"></span><span style='font-family:华文楷体'>。然后我们要通过</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=14 height=21
src="chap18.files/image039.png"></span><span style='font-family:华文楷体'>来生成</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=14 height=21
src="chap18.files/image089.png"></span><span style='font-family:华文楷体'>，其中只有一个候选<span
lang=EN-US>4-</span>项集，即<span lang=EN-US>{I1, I3, I5, I6}</span>，其支持度计数为<span
lang=EN-US>1</span>，故剪去。最后，由于</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=14 height=21
src="chap18.files/image089.png"></span><span style='font-family:华文楷体'>为空集，所以无法再构造<span
lang=EN-US>5-</span>项集，算法执行结束，我们也找到了全部的频繁项集，和前两个算法得到的结果相同。</span></p>

<p class=MsoNormal style='text-indent:22.7pt'><span style='font-family:华文楷体'>下面我们给出<span
lang=EN-US>Eclat</span>算法的伪代码实现，如下：</span></p>

<p class=MsoNormal style='text-indent:22.7pt'><span lang=EN-US
style='font-family:华文楷体'>&nbsp;</span></p>

<p class=MsoNormal style='text-indent:22.7pt'><span style='font-family:华文楷体'>使用垂直数据格式的优点很明显，在计算项集的支持度时，不需要扫描事务数据库，只需要计算<span
lang=EN-US>TID</span>集的长度即可。而且在由</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=14 height=21
src="chap18.files/image056.png"></span><span style='font-family:华文楷体'>计算</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=27 height=21
src="chap18.files/image085.png"></span><span style='font-family:华文楷体'>时，利用先验原理，剪枝效果很好，能有效降低候选项集数量。但是，当<span
lang=EN-US>TID</span>集长度较大时，其交运算的开销较大，且会占用大量内存空间。</span></p>

<p class=MsoNormal style='text-indent:22.7pt'><a><span style='font-family:华文楷体'>想要对<span
lang=EN-US>Eclat</span>算法的上述缺点进行优化，我们可以采用<b>差集</b>技术。差集顾名思义，就是两个集合之差，而我们可以通过记录（<span
lang=EN-US>k+1</span>）<span lang=EN-US>-</span>项集与相对应的<span lang=EN-US>k-</span>项集之间的<span
lang=EN-US>TID</span>集的差集，如上例中，<span lang=EN-US>{I1}</span>的<span lang=EN-US>TID</span>集为<span
lang=EN-US>{T001, T004, T005, T007, T008, T010}, {I1, I3}</span>的<span
lang=EN-US>TID</span>集为<span lang=EN-US>{ T004, T007, T008}</span>，两者的差集即为<span
lang=EN-US>{T001, T005, T010}</span>，这样只需记录差集，而不必完全存储两个<span lang=EN-US>TID</span>集。相关的优化算法有<span
lang=EN-US>GenMax</span>算法，它利用差集进行快速频繁项集检验，降低<span lang=EN-US>TID</span>集的存储开销和交运算的计算开销。当数据集较稠密或数据集中包含较多长模式时，差集技术的作用尤为明显。</span></a><span
class=MsoCommentReference><span lang=EN-US><a class=msocomanchor id="_anchor_5"
onmouseover="msoCommentShow('_anchor_5','_com_5')"
onmouseout="msoCommentHide('_com_5')" href="#_msocom_5" language=JavaScript
name="_msoanchor_5">[l5]</a>&nbsp;</span></span></p>

<p class=MsoNormal><b><span lang=EN-US style='font-size:12.0pt;font-family:
华文楷体'>18.2.4</span></b><b><span style='font-size:12.0pt;font-family:华文楷体'>优缺点讨论</span></b></p>

<p class=MsoNormal style='text-indent:22.7pt'><span style='font-family:华文楷体'>现在，相信你对<span
lang=EN-US>Apriori</span>算法、<span lang=EN-US>FP-tree</span>算法和<span lang=EN-US>Eclat</span>算法的原理已经比较熟悉了，下面我们将从不同角度对这三种算法的标准实现（不考虑各种优化技术）进行比较，带你一起梳理它们各自的优势和缺陷，以及适合的应用场景，使你对它们的了解更加全面清晰。</span></p>

<p class=MsoNormal style='text-indent:22.7pt'><span lang=EN-US
style='font-family:华文楷体'>Apriori</span><span style='font-family:华文楷体'>算法原理简洁，易于实现，十分适合稀疏数据集中的频繁模式挖掘。而当待挖掘的数据量较大时，虽然与穷举法相比，<span
lang=EN-US>Apriori</span>算法有显著的性能提高，但是其速度仍不能令人满意，且其空间复杂度较高，尤其是当</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=13 height=21
src="chap18.files/image036.png"></span><span style='font-family:华文楷体'>较大时，</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=14 height=21
src="chap18.files/image038.png"></span><span style='font-family:华文楷体'>的数量也会很大，每次迭代搜索下一层频繁项集时，它都重新需要扫描一遍数据集，从而产生不可忽视的<span
lang=EN-US>I/O</span>开销。</span></p>

<p class=MsoNormal style='text-indent:22.7pt'><span lang=EN-US
style='font-family:华文楷体'>FP-tree</span><span style='font-family:华文楷体'>算法使用一个高度压缩的数据结构存储了事务数据库的信息，整个过程只需扫描两次数据集，相关研究表明，在挖掘某些事务数据集时，<span
lang=EN-US>FP-tree</span>算法比<span lang=EN-US>Apriori</span>算法快多个数量级。不过，由于<span
lang=EN-US>FP-tree</span>算法在执行过程中需要递归生成条件数据库和条件<span lang=EN-US>FP-tree</span>，所以内存开销也较大，且当生成的<span
lang=EN-US>FP-tree</span>十分茂盛时，如满前缀树，算法产生的子问题数量会剧增，导致性能显著下降。需要注意的是，<span
lang=EN-US>FP-tree</span>算法和<span lang=EN-US>Apriori</span>算法都只能用于挖掘单维的布尔型关联规则。</span></p>

<p class=MsoNormal style='text-indent:22.7pt'><span lang=EN-US
style='font-family:华文楷体'>Eclat</span><span style='font-family:华文楷体'>算法是一种深度优先算法，利用了倒排思想，只需要扫描一次原始数据集。它的性能主要取决于垂直数据格式表示下的<span
lang=EN-US>TID</span>集长度，当<span lang=EN-US>TID</span>集较短时，算法性能不逊于<span
lang=EN-US>FP-tree</span>算法。而当<span lang=EN-US>TID</span>集很长时，不仅需要大量存储空间，其交运算耗时也会随之增加，导致算法效率下降。</span></p>

<p class=MsoNormal style='text-indent:22.7pt'><span style='font-family:华文楷体'>随着数据环境日益复杂，上述算法很难直接应用，但它们背后的思想仍然值得我们学习，对我们理解频繁项集挖掘问题有重要的帮助。</span></p>

<p class=MsoNormal style='text-indent:22.7pt'><span lang=EN-US
style='font-family:华文楷体'>&nbsp;</span></p>

<p class=MsoNormal><b><span lang=EN-US style='font-size:14.0pt;font-family:
华文楷体'>18.3 </span></b><b><span style='font-size:14.0pt;font-family:华文楷体'>关联规则生成及相关性评价</span></b></p>

<p class=MsoNormal style='text-indent:22.7pt'><span style='font-family:华文楷体'>从频繁项集里提取关联规则的过程中，可能产生大量关联规则，而其中很大一部分是人们所不感兴趣的，且某项关联规则是否有趣也会因人而异，如何建立有效且广泛适用的关联规则评估标准是一个重要且有趣的问题。</span></p>

<p class=MsoNormal style='text-indent:22.7pt'><span style='font-family:华文楷体'>下面，我们将介绍从频繁项集产生关联规则的过程，并对现有的多种关联规则评估方法进行阐释和比较。</span></p>

<p class=MsoNormal><b><span lang=EN-US style='font-size:12.0pt;font-family:
华文楷体'>18.3.1</span></b><b><span style='font-size:12.0pt;font-family:华文楷体'>候选关联规则生成</span></b></p>

<p class=MsoNormal style='text-indent:22.7pt'><span style='font-family:华文楷体'>前面我们介绍了三种频繁项集挖掘方法，而得到频繁项集后，下一步就是根据这些频繁项集来产生关联规则，并从中筛选出强关联规则，即满足最小支持度阈值和最小置信度阈值的关联规则。在<span
lang=EN-US>18.1.3</span>小节中，我们使用了枚举法来产生关联规则，介绍了产生关联规则的基本过程，下面我们将更详细地介绍这一过程及相关改进。</span></p>

<p class=MsoNormal style='text-indent:22.7pt'><span style='font-family:华文楷体'>让我们回忆一下从频繁项集产生关联规则的原理：首先将频繁项集<span
lang=EN-US>Y</span>划分成两个非空子集</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=8 height=21
src="chap18.files/image014.png"></span><span style='font-family:华文楷体'>和</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=33 height=21
src="chap18.files/image021.png"></span><span style='font-family:华文楷体'>，得到候选关联规则</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=60 height=21
src="chap18.files/image022.png"></span><span style='font-family:华文楷体'>，然后计算该候选关联规则的置信度，若满足最小置信度阈值，则该关联规则就是强关联规则，否则舍弃。其中，</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=8 height=21
src="chap18.files/image014.png"></span><span style='font-family:华文楷体'>和</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=33 height=21
src="chap18.files/image021.png"></span><span style='font-family:华文楷体'>必须是非空子集，因为</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=36 height=21
src="chap18.files/image023.png"></span><span style='font-family:华文楷体'>和</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=36 height=21
src="chap18.files/image024.png"></span><span style='font-family:华文楷体'>没有实际意义。</span></p>

<p class=MsoNormal style='text-indent:22.7pt'><span style='font-family:华文楷体'>以从表<span
lang=EN-US>18-2</span>数据中挖掘到的频繁<span lang=EN-US>3-</span>项集为例，令</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=84 height=21
src="chap18.files/image090.png"></span><span style='font-family:华文楷体'>，我们可以得到如表<span
lang=EN-US>18-8</span>前三列所示<span lang=EN-US>6</span>种不同的划分。</span></p>

<p class=MsoNormal align=center style='margin-top:7.8pt;text-align:center;
text-indent:22.7pt'><b><span style='font-family:华文楷体'>表<span lang=EN-US>18-8 </span>由频繁项集<span
lang=EN-US>Y</span>产生的候选关联规则</span></b></p>

<p class=MsoNormal align=center style='text-align:center;text-indent:22.7pt'><span
lang=EN-US><img width=393 height=202 id="图片 44" src="chap18.files/image091.jpg"></span></p>

<p class=MsoNormal align=left style='text-align:left;text-indent:22.7pt'><span
style='font-family:华文楷体'>然后依次计算每个候选关联规则的置信度，如表<span lang=EN-US>18-8</span>所示，而我们设定的最小置信度阈值为<span
lang=EN-US>0.70</span>，所以我们能从该频繁<span lang=EN-US>3-</span>项集中得到<span
lang=EN-US>2</span>条强关联规则，分别是<span lang=EN-US>{I3, I5}</span></span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=12 height=21
src="chap18.files/image092.png"></span><span lang=EN-US style='font-family:
华文楷体'>{I6}</span><span style='font-family:华文楷体'>和<span lang=EN-US>{I3, I6}</span></span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=12 height=21
src="chap18.files/image092.png"></span><span lang=EN-US style='font-family:
华文楷体'>{I5}</span><span style='font-family:华文楷体'>。</span></p>

<p class=MsoNormal align=left style='text-align:left;text-indent:22.7pt'><span
style='font-family:华文楷体'>对每个频繁<span lang=EN-US>k-</span>项集（</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=33 height=21
src="chap18.files/image093.png"></span><span style='font-family:华文楷体'>）执行上述过程，就能得到全部强关联规则。而每个频繁<span
lang=EN-US>k-</span>项集能产生</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:3.0pt'><img width=39 height=21
src="chap18.files/image031.png"></span><span style='font-family:华文楷体'>个候选关联规则，不仅占用大量内存空间，也会导致计算过程耗时较长，下面，我们来介绍一种有效的剪枝方法，从而减少候选关联规则数量，提高效率。</span></p>

<p class=MsoNormal><b><span lang=EN-US style='font-size:12.0pt;font-family:
华文楷体'>18.3.2</span></b><b><span style='font-size:12.0pt;font-family:华文楷体'>候选关联规则的剪枝</span></b></p>

<p class=MsoNormal style='text-indent:22.7pt'><span style='font-family:华文楷体'>在生成频繁项集的过程中，我们利用支持度度量的反单调性，即先验原理，有效减少了候选项集的数量。那么在候选关联规则的剪枝中，能否利用置信度度量进行类似的剪枝呢？要考察这一点，我们首先要尝试证明置信度度量是否同样具有反单调性。假设存在一条规则</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=35 height=21
src="chap18.files/image007.png"></span><span style='font-family:华文楷体'>，其置信度为</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=12 height=21
src="chap18.files/image094.png"></span><span style='font-family:华文楷体'>，则令</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=33 height=21
src="chap18.files/image095.png"></span><span style='font-family:华文楷体'>，</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=33 height=21
src="chap18.files/image096.png"></span><span style='font-family:华文楷体'>，从而得到规则</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=33 height=21
src="chap18.files/image097.png"></span><span style='font-family:华文楷体'>，其置信度为</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=12 height=21
src="chap18.files/image098.png"></span><span style='font-family:华文楷体'>。若置信度度量满足反单调性，则</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=43 height=21
src="chap18.files/image099.png"></span><span style='font-family:华文楷体'>须恒成立。遗憾的是，</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=12 height=21
src="chap18.files/image098.png"></span><span style='font-family:华文楷体'>与</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=12 height=21
src="chap18.files/image094.png"></span><span style='font-family:华文楷体'>之间的大小关系是不确定的，大于、小于和等于都有可能。</span></p>

<p class=MsoNormal align=center style='margin-top:7.8pt;text-align:center;
text-indent:22.7pt'><b><span style='font-family:华文楷体'>表<span lang=EN-US>18-8 </span>置信度度量不满足反单调性的案例</span></b></p>

<p class=MsoNormal align=center style='text-align:center;text-indent:22.7pt'><span
lang=EN-US><img width=470 height=128 id="图片 12" src="chap18.files/image100.jpg"></span></p>

<p class=MsoNormal style='text-indent:22.7pt'><span style='font-family:华文楷体'>幸运的是，置信度度量满足定理<span
lang=EN-US>18.2</span>，能够帮助我们利用它进行剪枝，具体如下：</span></p>

<p class=MsoNormal style='text-indent:22.7pt'><b><span style='font-family:华文楷体'>定理
<span lang=EN-US>18.2&nbsp; </span></span></b><span style='font-family:华文楷体'>令</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=8 height=21
src="chap18.files/image101.png"></span><span style='font-family:华文楷体'>是一个项集，且</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=34 height=21
src="chap18.files/image102.png"></span><span style='font-family:华文楷体'>。如果规则</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=60 height=21
src="chap18.files/image022.png"></span><span style='font-family:华文楷体'>不满足置信度阈值，则形如</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=61 height=21
src="chap18.files/image103.png"></span><span style='font-family:华文楷体'>的规则也一定不满足置信度阈值，其中</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=35 height=21
src="chap18.files/image104.png"></span><span style='font-family:华文楷体'>。</span></p>

<p class=MsoNormal style='text-indent:22.7pt'><span style='font-family:华文楷体'>该定理很容易证明，由于</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=35 height=21
src="chap18.files/image104.png"></span><span style='font-family:华文楷体'>，所以</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=74 height=21
src="chap18.files/image105.png"></span><span style='font-family:华文楷体'>，而规则</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=61 height=21
src="chap18.files/image103.png"></span><span style='font-family:华文楷体'>的置信度和规则</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=60 height=21
src="chap18.files/image022.png"></span><span style='font-family:华文楷体'>的置信度分别是</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:13.0pt'><img width=22 height=42
src="chap18.files/image106.png"></span><span style='font-family:华文楷体'>和</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:13.0pt'><img width=22 height=42
src="chap18.files/image107.png"></span><span style='font-family:华文楷体'>，故前者的置信度不可能大于后者。</span></p>

<p class=MsoNormal style='text-indent:22.7pt'><span style='font-family:华文楷体'>那么下面我们就来介绍如何利用置信度度量的这个性质进行候选关联规则的剪枝。</span></p>

<p class=MsoNormal style='text-indent:22.7pt'><span style='font-family:华文楷体'>类似于<span
lang=EN-US>Apriori</span>算法，我们通过逐层迭代来产生关联规则，关联规则后件中的项数随层数递增。同样以频繁<span
lang=EN-US>3-</span>项集<span lang=EN-US>{I3, I5, I6}</span>为例，如图<span
lang=EN-US>18-8</span>所示，该频繁<span lang=EN-US>3-</span>项集能产生<span lang=EN-US>6</span>条候选关联规则，其中三条规则的后件数为<span
lang=EN-US>1</span>，另外三条的后件数为<span lang=EN-US>2</span>。</span></p>

<p class=MsoNormal align=center style='text-align:center;text-indent:22.7pt'><span
lang=EN-US><img width=447 height=192 id="图片 45" src="chap18.files/image108.jpg"></span></p>

<p class=MsoNormal align=center style='margin-bottom:7.8pt;text-align:center'><b><span
style='font-family:华文楷体'>图<span lang=EN-US>18-11&nbsp; </span>使用置信度度量对关联规则进行剪枝</span></b></p>

<p class=MsoNormal style='text-indent:21.0pt'><span style='font-family:华文楷体'>其中后件数为<span
lang=EN-US>1</span>的三条关联规则中，规则</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=83 height=21
src="chap18.files/image109.png"></span><span style='font-family:华文楷体'>的置信度不满足最小置信度阈值，则剪去该关联规则，由剩余的<span
lang=EN-US>2</span>条强关联规则生成新的候选规则，具体过程是合并这两条规则的后件，从而产生下一层的关联规则</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=83 height=21
src="chap18.files/image110.png"></span><span style='font-family:华文楷体'>。在图<span
lang=EN-US>18-8</span>中，我们绘出了全部的关联规则，实际上，当规则</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=83 height=21
src="chap18.files/image109.png"></span><span style='font-family:华文楷体'>被剪去时，就不需要再由其产生下一层关联规则，相当于直接剪掉了从该结点生成的全部子关联规则，即图<span
lang=EN-US>18-8</span>中虚线圈起来的部分，这样原本的<span lang=EN-US>6</span>条候选关联规则就剪去了<span
lang=EN-US>3</span>条。当<span lang=EN-US>k</span>值更大时，对于频繁<span lang=EN-US>k-</span>项集的剪枝效果会更明显，能有效减少候选关联规则的数目。</span></p>

<p class=MsoNormal style='text-indent:21.0pt'><span style='font-family:华文楷体'>现在，我们来概括一下由频繁项集生成关联规则的过程。首先，对每个频繁<span
lang=EN-US>k-</span>项集（</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=33 height=21
src="chap18.files/image093.png"></span><span style='font-family:华文楷体'>）按上述方式逐层构造关联规则，计算它们的置信度，若某条关联规则不满足最小置信度阈值，则在下一轮迭代中，不再考虑该关联规则，由剩余的强关联规则来产生下一层的候选关联规则，直到产生的规则中后件的项数等于<span
lang=EN-US>k-1</span>时即可停止迭代，此时我们就得到了全部的强关联规则。</span></p>

<p class=MsoNormal style='text-indent:21.0pt'><span style='font-family:华文楷体'>到此，我们的任务还没有结束。并非所有的强关联规则都是有趣的，甚至有些强关联规则是有误导的，下一节，我们将介绍更加客观实用的规则评估方法，以帮助我们进一步筛选到我们所需要的、有意义的强关联规则。</span></p>

<p class=MsoNormal><b><span lang=EN-US style='font-size:12.0pt;font-family:
华文楷体'>18.3.3</span></b><b><span style='font-size:12.0pt;font-family:华文楷体'>相关性评价指标</span></b></p>

<p class=MsoNormal style='text-indent:22.7pt'><span style='font-family:华文楷体'>对关联规则是否有趣的评估方法总体可以分为两类，第一类是基于数据驱动的<b>客观兴趣度度量</b>，第二类则是通过主观论据建立的<b>主观兴趣度度量</b>。由于主观兴趣度度量通常因用户而异，若要将其加入规则评估方法中，需要来自对应领域的专家经验与判断，比较困难，所以我们这一小节的重点是客观兴趣度度量，它能利用统计方法提供有效的评估手段，帮助我们去除无趣的关联规则。</span></p>

<p class=MsoNormal style='text-indent:22.7pt'><span style='font-family:华文楷体'>在频繁项集挖掘和关联规则生成的过程中，我们用到了支持度度量和置信度度量，这两者都是客观度量，通常称为<b>支持度<span
lang=EN-US>-</span>置信度框架</b>，它能帮助我们做出一些筛选，但是它同样具有不小的局限性，基于该框架，我们可能会疏忽一些潜在的有意义的关联模式，也可能得到一些有误导的强关联规则，下面我们举例说明。</span></p>

<p class=MsoNormal align=center style='margin-top:7.8pt;text-align:center;
text-indent:22.7pt'><b><span style='font-family:华文楷体'>表<span lang=EN-US>18-9 </span>关于喝绿茶与喝咖啡的千人统计</span></b></p>

<p class=MsoNormal align=center style='text-align:center;text-indent:22.7pt'><a><span
lang=EN-US><img width=420 height=133 id="图片 19" src="chap18.files/image111.jpg"></span></a><span
class=MsoCommentReference><span lang=EN-US><a class=msocomanchor id="_anchor_6"
onmouseover="msoCommentShow('_anchor_6','_com_6')"
onmouseout="msoCommentHide('_com_6')" href="#_msocom_6" language=JavaScript
name="_msoanchor_6">[l6]</a>&nbsp;</span></span></p>

<p class=MsoNormal style='text-indent:22.7pt'><span style='font-family:华文楷体'>假设最小支持度阈值和最小置信度阈值分别是<span
lang=EN-US>10%</span>和<span lang=EN-US>70%</span>。</span></p>

<p class=MsoNormal style='text-indent:22.7pt'><span style='font-family:华文楷体'>令<span
lang=EN-US>I1=</span>爱喝绿茶，<span lang=EN-US>I2=</span>爱喝咖啡。考察关联规则</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=66 height=21
src="chap18.files/image112.png"></span><span style='font-family:华文楷体'>，其支持度为<span
lang=EN-US>15%</span>，置信度为<span lang=EN-US>75%</span>，按照支持度<span lang=EN-US>-</span>置信度框架评估，则该规则是强关联规则。然而，该关联规则具有误导性。在全体测试人群中，爱喝咖啡的人占比达<span
lang=EN-US>80%</span>，而其中同时也爱喝茶的人只占<span lang=EN-US>75%</span>，即若一个人爱喝茶，则他爱喝咖啡的可能性反而从<span
lang=EN-US>80%</span>下降到了<span lang=EN-US>75%</span>，这是一个有误导性的强规则，所以，我们需要寻找更可信的评估度量方法。</span></p>

<p class=MsoNormal style='text-indent:22.7pt'><span style='font-family:华文楷体'>第一种方法是使用相关性度量对基础的支持度<span
lang=EN-US>-</span>置信度框架进行扩充，即在原来的度量基础上考虑关联规则的前件和后件之间的相关性，所以关联规则的表示形式将有所变化，具体如下：</span></p>

<p class=MsoNormal align=center style='text-align:center;text-indent:22.7pt'><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=35 height=21
src="chap18.files/image007.png"></span><span lang=EN-US style='font-family:
华文楷体'>&nbsp;[ support, confidence, correlation ]</span></p>

<p class=MsoNormal style='text-indent:22.7pt'><span style='font-family:华文楷体'>但相关性度量有多种方式，这一小节我们将介绍<b>提升度</b>和</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:3.0pt'><img width=18 height=21
src="chap18.files/image113.png"></span><span style='font-family:华文楷体'>两种相关性度量方式。</span></p>

<p class=MsoNormal style='text-indent:22.7pt'><span style='font-family:华文楷体'>首先介绍提升度。令</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=29 height=21
src="chap18.files/image114.png"></span><span style='font-family:华文楷体'>表示事件</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=8 height=21
src="chap18.files/image014.png"></span><span style='font-family:华文楷体'>发生的概率。假设有前件<span
lang=EN-US>A</span>和后件<span lang=EN-US>B</span>，若满足</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=147 height=21
src="chap18.files/image115.png"></span><span style='font-family:华文楷体'>，则前件<span
lang=EN-US>A</span>和后件<span lang=EN-US>B</span>是统计独立的，即<span lang=EN-US>A</span>的发生和<span
lang=EN-US>B</span>的发生是互不影响且没有联系的，将</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=73 height=21
src="chap18.files/image116.png"></span><span style='font-family:华文楷体'>的值记为</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=24 height=21
src="chap18.files/image117.png"></span><span style='font-family:华文楷体'>。若不满足，则称<span
lang=EN-US>A</span>与<span lang=EN-US>B</span>是依赖的或相关的，两者同时发生的概率即为</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=53 height=21
src="chap18.files/image118.png"></span><span style='font-family:华文楷体'>。<span
lang=EN-US>A</span>发生和<span lang=EN-US>B</span>发生之间的提升度就可以定义如下：</span></p>

<p class=MsoNormal align=center style='text-align:center;text-indent:22.7pt'><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif"'><img
width=218 height=42 src="chap18.files/image119.png"></span></p>

<p class=MsoNormal style='text-indent:22.7pt'><span style='font-family:华文楷体'>该定义很容易推广到两项以上的情况，如下：</span></p>

<p class=MsoNormal align=center style='text-align:center;text-indent:22.7pt'><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif"'><img
width=285 height=42 src="chap18.files/image120.png"></span></p>

<p class=MsoNormal style='text-indent:22.7pt'><span style='font-family:华文楷体'>下面对提升度进行简单的解释。</span></p>

<p class=MsoNormal style='text-indent:22.7pt'><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif"'><img
width=187 height=83 src="chap18.files/image121.png"></span></p>

<p class=MsoNormal style='text-indent:22.7pt'><span style='font-family:华文楷体'>负相关是指<span
lang=EN-US>A</span>的发生可能导致<span lang=EN-US>B</span>不发生，所以提升度小于<span lang=EN-US>1</span>的关联规则通常会被拒绝。让我们重新考察上述咖啡和绿茶的案例。关联规则</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=66 height=21
src="chap18.files/image112.png"></span><span style='font-family:华文楷体'>的提升度为</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:12.0pt'><img width=94 height=42
src="chap18.files/image122.png"></span><span style='font-family:华文楷体'>，说明前件和后件之间呈负相关，所以该关联规则会被拒绝。</span></p>

<p class=MsoNormal style='text-indent:22.7pt'><span style='font-family:华文楷体'>回顾置信度的计算公式，不难发现，置信度度量只考虑了</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=53 height=21
src="chap18.files/image118.png"></span><span style='font-family:华文楷体'>和</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=28 height=21
src="chap18.files/image123.png"></span><span style='font-family:华文楷体'>之间的偏差，而提升度则考虑的是</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=53 height=21
src="chap18.files/image118.png"></span><span style='font-family:华文楷体'>和</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=24 height=21
src="chap18.files/image117.png"></span><span style='font-family:华文楷体'>之间的偏差，所以置信度不能解释后件的支持度，从而会导致产生出有误导性的关联规则的情况。</span></p>

<p class=MsoNormal style='text-indent:22.7pt'><span style='font-family:华文楷体'>下面我们将介绍使用</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=14 height=21
src="chap18.files/image124.png"></span><span style='font-family:华文楷体'>分析来度量相关性。首先，对关联规则</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=35 height=21
src="chap18.files/image007.png"></span><span style='font-family:华文楷体'>，我们假设两者统计独立，从而计算出期望值，而原统计值则称为观测值，从而计算</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=14 height=21
src="chap18.files/image124.png"></span><span style='font-family:华文楷体'>值如下：</span></p>

<p class=MsoNormal align=center style='text-align:center;text-indent:22.7pt'><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif"'><img
width=172 height=62 src="chap18.files/image125.png"></span></p>

<p class=MsoNormal style='text-indent:22.7pt'><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=14 height=21
src="chap18.files/image124.png"></span><span style='font-family:华文楷体'>值能够反映理论值和实际观测值的差异程度，得到</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=14 height=21
src="chap18.files/image124.png"></span><span style='font-family:华文楷体'>值后，我们不能像提升度那样直接与<span
lang=EN-US>1</span>比较，从而得出结论，而是需要查询</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=14 height=21
src="chap18.files/image124.png"></span><span style='font-family:华文楷体'>分布的临界值表，然后再根据用户设定的显著性水平</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=8 height=21
src="chap18.files/image126.png"></span><span style='font-family:华文楷体'>（通常为<span
lang=EN-US>0.05</span>），判断是否拒绝该关联规则。在此我们不作详细描述，有兴趣的同学<a>可以参考<span lang=EN-US>…</span></a></span><span
class=MsoCommentReference><span lang=EN-US><a class=msocomanchor id="_anchor_7"
onmouseover="msoCommentShow('_anchor_7','_com_7')"
onmouseout="msoCommentHide('_com_7')" href="#_msocom_7" language=JavaScript
name="_msoanchor_7">[l7]</a>&nbsp;</span></span><span style='font-family:华文楷体'>。</span></p>

<p class=MsoNormal style='text-indent:22.7pt'><span style='font-family:华文楷体'>同样重新考察上述咖啡与绿茶的案例。如果喝绿茶与喝咖啡是统计独立的，那么按照表<span
lang=EN-US>18-9</span>中的数据，爱喝咖啡的期望人数占比为</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:12.0pt'><img width=79 height=42
src="chap18.files/image127.png"></span><span style='font-family:华文楷体'>，那么爱喝绿茶的人中还爱喝咖啡的人数的期望值就是</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=99 height=21
src="chap18.files/image128.png"></span><span style='font-family:华文楷体'>。同理，按照期望占比重新计算该表格数据后，得到对应的期望值表格如下：</span></p>

<p class=MsoNormal align=center style='margin-top:7.8pt;text-align:center;
text-indent:22.7pt'><b><span style='font-family:华文楷体'>表<span lang=EN-US>18-9 </span>关于喝绿茶与喝咖啡的千人统计</span></b></p>

<p class=MsoNormal align=center style='text-align:center;text-indent:22.7pt'><span
lang=EN-US><img width=384 height=126 id="图片 2" src="chap18.files/image129.jpg"></span></p>

<p class=MsoNormal style='text-indent:22.7pt'><span style='font-family:华文楷体'>然后按照</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=14 height=21
src="chap18.files/image124.png"></span><span style='font-family:华文楷体'>值计算公式，计算如下：</span></p>

<p class=MsoNormal style='text-indent:22.7pt'><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif"'><img
width=459 height=42 src="chap18.files/image130.png"></span></p>

<p class=MsoNormal style='text-indent:22.7pt'><span style='font-family:华文楷体'>查阅</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=14 height=21
src="chap18.files/image124.png"></span><span style='font-family:华文楷体'>分布的临界值表，两者以<span
lang=EN-US>95%</span>的概率不相关的临界值是<span lang=EN-US>3.84</span>，由于</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=14 height=21
src="chap18.files/image124.png"></span><span style='font-family:华文楷体'>值大于该临界值，所以爱喝绿茶和爱喝咖啡之间是有关联的，且（爱喝绿茶，爱喝咖啡）处的观测值<span
lang=EN-US>150</span>小于期望值<span lang=EN-US>160</span>，说明两者是负相关的，与使用提升度得到的分析结果相同。</span></p>

<p class=MsoNormal style='text-indent:22.7pt'><span style='font-family:华文楷体'>除此之外，还有其他的评估度量方式值得我们了解。下面我们将介绍四种具有零不变性的度量：全置信度、最大置信度、<span
lang=EN-US>Kulczynski</span>和余弦。</span></p>

<p class=MsoNormal style='text-indent:22.7pt'><span style='font-family:华文楷体'>首先介绍<b>全置信度</b>，两个项集<span
lang=EN-US>A</span>和<span lang=EN-US>B</span>的全置信度定义如下：</span></p>

<p class=MsoNormal align=center style='text-align:center;text-indent:22.7pt'><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif"'><img
width=272 height=42 src="chap18.files/image131.png"></span></p>

<p class=MsoNormal style='text-indent:22.7pt'><span style='font-family:华文楷体'>全置信度计算公式的分子是项集<span
lang=EN-US>A</span>和<span lang=EN-US>B</span>同时出现的支持度，分母则是项集中的最大支持度，由于支持度度量具有反单调性，所以</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=219 height=21
src="chap18.files/image132.png"></span><span style='font-family:华文楷体'>，即全置信度是项集<span
lang=EN-US>{A, B}</span>产生的关联规则</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=37 height=21
src="chap18.files/image133.png"></span><span style='font-family:华文楷体'>和</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=37 height=21
src="chap18.files/image134.png"></span><span style='font-family:华文楷体'>中的置信度下界，这也是全置信度的特点，即：</span></p>

<p class=MsoNormal align=center style='text-align:center;text-indent:22.7pt'><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif"'><img
width=272 height=42 src="chap18.files/image135.png"></span></p>

<p class=MsoNormal style='text-indent:22.7pt'><span style='font-family:华文楷体'>值得注意的是，虽然置信度度量不具有反单调性，但是全置信度度量是具有反单调性的，所以可以直接在前述的挖掘算法中用于剪枝策略。</span></p>

<p class=MsoNormal style='text-indent:22.7pt'><span style='font-family:华文楷体'>然后是<b>最大置信度</b>，两个项集<span
lang=EN-US>A</span>和<span lang=EN-US>B</span>的最大置信度定义如下：</span></p>

<p class=MsoNormal align=center style='text-align:center;text-indent:22.7pt'><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif"'><img
width=281 height=42 src="chap18.files/image136.png"></span></p>

<p class=MsoNormal style='text-indent:22.7pt'><span style='font-family:华文楷体'>与全置信度计算公式略有不同，最大置信度计算公式的分母是项集中的最小支持度，所以它的含义是项集<span
lang=EN-US>{A, B}</span>产生的关联规则</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=37 height=21
src="chap18.files/image133.png"></span><span style='font-family:华文楷体'>和</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=37 height=21
src="chap18.files/image134.png"></span><span style='font-family:华文楷体'>的最大置信度。</span></p>

<p class=MsoNormal style='text-indent:22.7pt'><span style='font-family:华文楷体'>下一个是<b><span
lang=EN-US>Kulczynski</span>（<span lang=EN-US>Kulc</span>）度量</b>，由波兰数学家<span
lang=EN-US>S. Kulczynski</span>于<span lang=EN-US>1927</span>年提出。项集<span
lang=EN-US>A</span>和<span lang=EN-US>B</span>的<span lang=EN-US>Kulc</span>度量定义如下：</span></p>

<p class=MsoNormal align=center style='text-align:center;text-indent:22.7pt'><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif"'><img
width=453 height=42 src="chap18.files/image137.png"></span></p>

<p class=MsoNormal style='text-indent:22.7pt'><span style='font-family:华文楷体'>由计算公式不难看出，<span
lang=EN-US>Kulc</span>度量是项集<span lang=EN-US>{A, B}</span>产生的关联规则</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=37 height=21
src="chap18.files/image133.png"></span><span style='font-family:华文楷体'>和</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=37 height=21
src="chap18.files/image134.png"></span><span style='font-family:华文楷体'>的各自置信度的平均值。</span></p>

<p class=MsoNormal style='text-indent:22.7pt'><span style='font-family:华文楷体'>最后是<b>余弦度量</b>，项集<span
lang=EN-US>A</span>和<span lang=EN-US>B</span>的余弦度量定义如下：</span></p>

<p class=MsoNormal align=center style='text-align:center;text-indent:22.7pt'><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif"'><img
width=321 height=42 src="chap18.files/image138.png"></span></p>

<p class=MsoNormal style='text-indent:22.7pt'><span style='font-family:华文楷体'>细心的同学可能注意到了余弦度量和提升度的计算公式十分相近，只是余弦在分母处多了取平方根的计算。所以，余弦度量也称为调和提升度度量，而通过取平方根，余弦度量消除了事务总个数的影响，而只会受到</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=9 height=21
src="chap18.files/image139.png"></span><span style='font-family:华文楷体'>、</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=9 height=21
src="chap18.files/image140.png"></span><span style='font-family:华文楷体'>、</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=33 height=21
src="chap18.files/image141.png"></span><span style='font-family:华文楷体'>的支持度的影响。</span></p>

<p class=MsoNormal style='text-indent:22.7pt'><span style='font-family:华文楷体'>实际上，上述前三种度量也具备余弦度量的这个性质，即度量值不受事务总个数的影响，此外，这四种度量的取值范围都是</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=31 height=21
src="chap18.files/image142.png"></span><span style='font-family:华文楷体'>，且含义都如下：</span></p>

<p class=MsoNormal style='text-indent:22.7pt'><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif"'><img
width=223 height=83 src="chap18.files/image143.png"></span></p>

<p class=MsoNormal style='text-indent:22.7pt'><span style='font-family:华文楷体'>至此，除了支持度度量和置信度度量，我们已经介绍了<span
lang=EN-US>6</span>种新的评估方法。那么这些方法孰优孰劣呢？下面我们将通过特殊的案例进行说明，并比较这<span lang=EN-US>6</span>种评估方法的性能。</span></p>

<p class=MsoNormal style='text-indent:22.7pt'><span style='font-family:华文楷体'>让我们依旧以喝咖啡和喝绿茶为例，爱喝咖啡的人群以</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=6 height=21
src="chap18.files/image144.png"></span><span style='font-family:华文楷体'>（<span
lang=EN-US>coffee</span>）表示，不爱喝咖啡的人群则以</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=7 height=21
src="chap18.files/image145.png"></span><span style='font-family:华文楷体'>表示，同理，爱喝茶和不爱喝茶的人群分别以</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=5 height=21
src="chap18.files/image075.png"></span><span style='font-family:华文楷体'>（<span
lang=EN-US>tea</span>）和</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=6 height=21
src="chap18.files/image146.png"></span><span style='font-family:华文楷体'>表示。而既爱喝咖啡，又爱喝绿茶的人群就可以用</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=11 height=21
src="chap18.files/image147.png"></span><span style='font-family:华文楷体'>表示，其他情况同理。</span></p>

<p class=MsoNormal style='text-indent:22.7pt'><span style='font-family:华文楷体'>假设我们调查得到一个数据集，其中</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=114 height=21
src="chap18.files/image148.png"></span><span style='font-family:华文楷体'>，</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=69 height=21
src="chap18.files/image149.png"></span><span style='font-family:华文楷体'>。此时可以计算得到如下表所示结果。</span></p>

<p class=MsoNormal align=center style='margin-top:7.8pt;text-align:center;
text-indent:22.7pt'><b><span style='font-family:华文楷体'>表<span lang=EN-US>18-10 </span>不同评估方法的度量值</span></b></p>

<p class=MsoNormal style='text-indent:22.7pt'><span lang=EN-US><img width=494
height=64 id="图片 20" src="chap18.files/image150.jpg"></span></p>

<p class=MsoNormal style='text-indent:22.7pt'><span style='font-family:华文楷体'>不难发现，对于该数据，提升度和</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=14 height=21
src="chap18.files/image124.png"></span><span style='font-family:华文楷体'>都认为爱喝茶和爱喝咖啡之间具有强正相关，而另外四种评估方法都认为爱喝茶和爱喝咖啡之间是中性关联。那么谁的判断比较正确呢？让我们详细分析一下。首先，观察该数据集，样本总数为<span
lang=EN-US>10300</span>，但是其中</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=12 height=21
src="chap18.files/image151.png"></span><span style='font-family:华文楷体'>的样本有<span
lang=EN-US>10000</span>，显著地大于另外三类样本数。而提升度和</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=14 height=21
src="chap18.files/image124.png"></span><span style='font-family:华文楷体'>都对</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=12 height=21
src="chap18.files/image151.png"></span><span style='font-family:华文楷体'>样本十分敏感，所以产生了不稳定的结果。在很多实际数据中，类似</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=12 height=21
src="chap18.files/image151.png"></span><span style='font-family:华文楷体'>这类不包含任何我们感兴趣的项的样本通常都远大于其他样本，所以我们期望的度量应该能不受此类样本影响，从而给出稳定且符合常理的结果。那为何全置信度、最大置信度、<span
lang=EN-US>Kulc</span>度量和余弦度量的结果都是<span lang=EN-US>0.50</span>呢？因为在这个数据集中，</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=114 height=21
src="chap18.files/image148.png"></span><span style='font-family:华文楷体'>，即</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:12.0pt'><img width=64 height=42
src="chap18.files/image152.png"></span><span style='font-family:华文楷体'>，这说明如果一个人喜欢喝绿茶，那他同时还喜欢喝咖啡的概率是<span
lang=EN-US>50%</span>，如果他喜欢喝咖啡，那他还喜欢喝绿茶的概率也是<span lang=EN-US>50%</span>，而这四种度量都没有受到</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=12 height=21
src="chap18.files/image151.png"></span><span style='font-family:华文楷体'>样本的影响，故正确地显示了两者呈中性关联。</span></p>

<p class=MsoNormal style='text-indent:22.7pt'><span style='font-family:华文楷体'>让我们更准确地阐述后四种度量都具备的这种实用的性质。如</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=12 height=21
src="chap18.files/image151.png"></span><span style='font-family:华文楷体'>这类样本，我们将其称为<b>零事务</b>，即不包含任何用户感兴趣的项集的事务，许多大型事务数据库中，零事务的个数可能远远超过其他事务的总和，而如果一种评估方法能不受零事务个数的影响，即度量值独立于零事务个数，那么我们称该评估方法具有<b>零不变性</b>。由于我们探索的是用户感兴趣的项集之间的关联规则，所以在大型数据集中，我们通常更倾向于使用具有零不变性的评估方法，相比于提升度和</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=14 height=21
src="chap18.files/image124.png"></span><span style='font-family:华文楷体'>这类不具有零不变性的度量，前者对识别出有意义的关联规则更有帮助。</span></p>

<p class=MsoNormal style='text-indent:22.7pt'><a><span style='font-family:华文楷体'>而这些零不变性度量之间，又是孰优孰劣呢？</span></a><span
class=MsoCommentReference><span lang=EN-US><a class=msocomanchor id="_anchor_8"
onmouseover="msoCommentShow('_anchor_8','_com_8')"
onmouseout="msoCommentHide('_com_8')" href="#_msocom_8" language=JavaScript
name="_msoanchor_8">[l8]</a>&nbsp;</span></span></p>

<p class=MsoNormal style='text-indent:22.7pt'><span lang=EN-US
style='font-family:华文楷体'>&nbsp;</span></p>

<p class=MsoNormal><b><span lang=EN-US style='font-size:14.0pt;font-family:
华文楷体'>18.4 </span></b><b><span style='font-size:14.0pt;font-family:华文楷体'>多维度量化关联规则挖掘</span></b></p>

<p class=MsoNormal style='text-indent:22.7pt'><span style='font-family:华文楷体'>前面我们所介绍的是单维度布尔型关联规则挖掘，而在实际应用中，我们获得的大都是更加复杂的数据，涉及的挖掘方法也更多样。在这一小节，我们将向你介绍多维度关联规则挖掘和量化关联规则挖掘的基本概念和常见方法，使你对高级模式挖掘产生基本的认识。</span></p>

<p class=MsoNormal style='text-indent:22.7pt'><span lang=EN-US
style='font-family:华文楷体'>&nbsp;</span></p>

<p class=MsoNormal><b><span lang=EN-US style='font-size:12.0pt;font-family:
华文楷体'>18.4.1</span></b><b><span style='font-size:12.0pt;font-family:华文楷体'>多维度关联规则挖掘
</span></b></p>

<p class=MsoNormal style='text-indent:22.7pt'><span style='font-family:华文楷体'>关于“什么是多维关联规则”这个问题，我们在<span
lang=EN-US>18.1.2</span>小节中已经作了介绍。简单来说，规则中涉及的谓词多于一个，便是多维关联规则。例如，若我们想表达如下关联关系“深圳的<span
lang=EN-US>35</span>岁以上的教师倾向于购买茶壶”，则可以书写为：</span></p>

<p class=MsoNormal style='text-indent:22.7pt'><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif"'><img
width=512 height=21 src="chap18.files/image153.png"></span></p>

<p class=MsoNormal style='text-indent:22.7pt'><span style='font-family:华文楷体'>该关联规则涉及<span
lang=EN-US>4</span>个谓词，这<span lang=EN-US>4</span>个谓词</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=194 height=21
src="chap18.files/image154.png"></span><span style='font-family:华文楷体'>则构成一个<span
lang=EN-US>4-</span>谓词集，更进一步地说，这<span lang=EN-US>4</span>个谓词都是不重复的，所以该关联规则是维间关联规则，即具有不重复谓词的多维关联规则。而包含重复谓词的多维关联规则被称为混合维关联规则，修改上例，关联关系“深圳的<span
lang=EN-US>35</span>岁以上的人群中购买了茶叶的倾向于购买茶壶”可表示如下：</span></p>

<p class=MsoNormal style='text-indent:22.7pt'><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif"'><img
width=447 height=21 src="chap18.files/image155.png"></span></p>

<p class=MsoNormal style='text-indent:22.7pt'><span style='font-family:华文楷体'>单维关联规则的挖掘对象是事务数据，而多维关联规则的挖掘对象则是更加复杂庞大的数据仓库或关系数据库等。在数据库中，一条记录的属性可能是标称的或量化的。标称属性的取值范围是有限多个可能值的集合，且值之间是无序的，如<span
lang=EN-US>occupation</span>、<span lang=EN-US>location</span>就是标称属性。量化属性的值则是数值的，且值之间存在隐序，如<span
lang=EN-US>age</span>、<span lang=EN-US>income</span>等属性。在多维关联规则挖掘中，我们搜寻的不再是频繁项集，而是频繁谓词集，频繁<span
lang=EN-US>k-</span>谓词集的集合同样以</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=14 height=21
src="chap18.files/image056.png"></span><span style='font-family:华文楷体'>表示。</span></p>

<p class=MsoNormal style='text-indent:22.7pt'><span style='font-family:华文楷体'>多维关联规则的挖掘方法可以根据它对量化属性的处理方式分为三种，下面我们将一一介绍，但不会涉及到方法的具体细节。</span></p>

<p class=MsoListParagraph style='margin-left:43.7pt;text-indent:-21.0pt'><b><span
lang=EN-US style='font-family:华文楷体'>(1)<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;
</span></span></b><b><span style='font-family:华文楷体'>使用量化属性的静态离散化挖掘多维关联规则</span></b></p>

<p class=MsoNormal style='margin-left:22.7pt;text-indent:21.0pt'><span
style='font-family:华文楷体'>即使用预定义的概念分组对量化属性离散化。在进行挖掘之前，我们首先使用自定义的分组替换掉原本的量化属性。比如，对于数值属性，我们可以通过预先划分的区间值，如</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=151 height=21
src="chap18.files/image156.png"></span><span style='font-family:华文楷体'>等，将原本的数值属性转换为相应的区间，每个区间包含区间标号，可以看作一个分组，这样，就能以处理标称属性的方式对量化属性进行处理了。这种离散化是静态的，必须在挖掘之前进行。</span></p>

<p class=MsoListParagraph style='margin-left:43.7pt;text-indent:-21.0pt'><b><span
lang=EN-US style='font-family:华文楷体'>(2)<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;
</span></span></b><b><span style='font-family:华文楷体'>挖掘量化关联规则</span></b></p>

<p class=MsoNormal style='margin-left:22.7pt;text-indent:21.0pt'><span
style='font-family:华文楷体'>即根据数据的分布情况，将量化属性离散化或聚类到“箱”。和第一种方法不同，该方法将数值属性的值处理为数量的形式，而非类别或区间。且这种离散化是动态的，在数据挖掘过程中可以进行自动调整，比如相邻的箱可能合并。自动调整的标准则是预定义的，比如最大化所得关联规则的提升度。<span
lang=EN-US>ARCS</span>（<span lang=EN-US>Association Rule Clustering System</span>）就应用了该方法，它将量化属性对映射到满足给定的分类条件的<span
lang=EN-US>2D</span>栅格上，然后使用聚类算法搜索栅格点，从而得到关联规则。</span></p>

<p class=MsoListParagraph style='margin-left:43.7pt;text-indent:-21.0pt'><b><span
lang=EN-US style='font-family:华文楷体'>(3)<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;
</span></span></b><b><span style='font-family:华文楷体'>挖掘基于距离的关联规则</span></b></p>

<p class=MsoNormal style='margin-left:22.7pt;text-indent:21.0pt'><span
style='font-family:华文楷体'>该方法同样是使用区间对量化属性离散化，但它不允许数据值的近似，这一方法考虑到了数据点之间的距离，因此得名，且应用在了两趟扫描算法中。即在第一趟扫描时，使用聚类算法寻找出簇，第二趟扫描搜索簇组，以得到基于距离的关联规则。</span></p>

<p class=MsoNormal><span lang=EN-US style='font-family:华文楷体'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></p>

<p class=MsoNormal style='text-indent:21.0pt'><span style='font-family:华文楷体'>需要注意的是，我们介绍的上述方法可以用于多维关联规则挖掘，但并不适合挖掘高维数据，即维度达到数百甚至数千的数据。如今虽然有一些方法可以用于挖掘高维数据，如基于行枚举的模式增长方法，以及挖掘巨型模式的模式融合方法，但是仍有很长的路要走，我们在此则不作详细介绍。</span></p>

<p class=MsoNormal><span lang=EN-US style='font-family:华文楷体'>&nbsp;</span></p>

<p class=MsoNormal><b><span lang=EN-US style='font-size:12.0pt;font-family:
华文楷体'>18.4.2</span></b><b><span style='font-size:12.0pt;font-family:华文楷体'>量化关联规则挖掘</span></b></p>

<p class=MsoNormal style='text-indent:22.7pt'><span style='font-family:华文楷体'>量化关联规则的定义在<span
lang=EN-US>18.1.2</span>小节中已经介绍过，即包含了量化的项或属性的规则。由于量化关联规则和多维关联规则之间本身是有交叉的，正如我们在<span
lang=EN-US>18.2</span>节中挖掘的单维布尔型关联规则，我们现在讨论的是挖掘多维量化关联规则，所以两者的挖掘方法不必完全区分。而如<span
lang=EN-US>18.4.1</span>节介绍的使用量化属性的静态离散化挖掘方法，我们先将量化属性离散化到多个区间，从而作为标称数据看待，但这种做法可能导致产生大量冗余的无意义的关联规则。为了改善这一缺点，我们接下来会介绍一些新的方法，帮助我们能更高效地发现有趣的关联规则。</span></p>

<p class=MsoNormal style='text-indent:22.7pt'><span style='font-family:华文楷体'>第一种方法是基于数据立方体进行挖掘。</span></p>

<p class=MsoNormal style='text-indent:22.7pt'><span style='font-family:华文楷体'>第二种方法是基于聚类进行挖掘。</span></p>

<p class=MsoNormal style='text-indent:22.7pt'><span style='font-family:华文楷体'>第三种方法则是基于统计学理论来发现能揭示异常行为的量化关联规则。</span></p>

<p class=MsoNormal style='text-indent:22.7pt'><span lang=EN-US
style='font-family:华文楷体'>&nbsp;</span></p>

<p class=MsoNormal style='text-indent:22.7pt'><span lang=EN-US
style='font-family:华文楷体'>&nbsp;</span></p>

<p class=MsoNormal style='text-indent:22.7pt'><span lang=EN-US
style='font-family:华文楷体'>&nbsp;</span></p>

<p class=MsoNormal><b><span lang=EN-US style='font-size:14.0pt;font-family:
华文楷体'>18.5 </span></b><b><span style='font-size:14.0pt;font-family:华文楷体'>时序关联规则挖掘</span></b></p>

<p class=MsoNormal style='text-indent:22.7pt'><span style='font-family:华文楷体'>在生活中，数据事件之间常常存在时间或空间上的序数关系。在之前讨论的关联规则挖掘中，我们没有考虑数据中可能携带的序列信息。以前面的购物篮数据为例，我们只考虑了顾客单次购买的商品之间的联系，而对于一位多次光临的顾客，其每次购买的清单之间也可能包含一些有意义的关联模式，值得我们探究。实际上，许多数据在时间维度上都会呈现出某种趋势，比较直观的如股票数据和心电图数据等，我们不能忽视时间信息，而应该对其善加利用，这一节我们就将介绍时序关联规则的挖掘过程。</span></p>

<p class=MsoNormal><b><span lang=EN-US style='font-size:12.0pt;font-family:
华文楷体'>18.5.1</span></b><b><span style='font-size:12.0pt;font-family:华文楷体'>时序模式的定义</span></b></p>

<p class=MsoNormal style='text-indent:22.7pt'><span style='font-family:华文楷体'>在之前介绍的关联规则的基础上，引入时间或空间维度，便是序列模式，而这一节我们主要介绍引入时间维度的数据挖掘，所以称为时序模式。接下来，我们首先需要了解一些基本概念，对序列信息有一个清晰的认识。</span></p>

<p class=MsoNormal style='text-indent:22.7pt'><span lang=EN-US
style='font-family:华文楷体'>18.1.3</span><span style='font-family:华文楷体'>节中的事务数据库中，每一行是一个事务，每个事务有一个<span
lang=EN-US>TID</span>号和对应的项集。而一个序列则是事务的有序列表，通常记为</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=112 height=21
src="chap18.files/image157.png"></span><span style='font-family:华文楷体'>，其中</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=10 height=21
src="chap18.files/image158.png"></span><span style='font-family:华文楷体'>表示一个事件集，这里的事件即相当于项。在讨论序列时，为了避免混淆，我们通常称事务为元素，称项为事件，即元素是事件的集合，序列是元素的有序列表。下面给出几个序列的例子。</span></p>

<p class=MsoNormal style='text-indent:22.7pt'><span style='font-family:华文楷体'>（<span
lang=EN-US>1</span>）、某顾客在附近超市一个月的购买清单记录：</span></p>

<p class=MsoNormal style='text-indent:22.7pt'><span lang=EN-US
style='font-family:华文楷体'>&lt;{</span><span style='font-family:华文楷体'>牛奶，面包<span
lang=EN-US>}{</span>矿泉水<span lang=EN-US>}{</span>薯片，方便面<span lang=EN-US>}{</span>衣架<span
lang=EN-US>}{</span>薯片<span lang=EN-US>}{</span>清洁球<span lang=EN-US>}&gt;</span></span></p>

<p class=MsoNormal style='text-indent:22.7pt'><span style='font-family:华文楷体'>（<span
lang=EN-US>2</span>）、某校计算机科学专业学生不同学年参与的课程序列：</span></p>

<p class=MsoNormal style='text-indent:22.7pt'><span lang=EN-US
style='font-family:华文楷体'>&lt;{</span><span style='font-family:华文楷体'>高等数学，线性代数，数据结构<span
lang=EN-US>}{</span>概率论，算法导论，离散数学<span lang=EN-US>}{</span>操作系统，数据库系统<span
lang=EN-US>}{</span>计算机体系结构，编译原理，软件工程<span lang=EN-US>}&gt;</span></span></p>

<p class=MsoNormal style='text-indent:22.7pt'><span style='font-family:华文楷体'>我们通常以序列的长度来描述一个序列，序列长度即序列中元素的个数，其中包含<span
lang=EN-US>k</span>个元素的序列称为<b><span lang=EN-US>k-</span>序列</b>。在上述两个序列中，序列（<span
lang=EN-US>1</span>）有<span lang=EN-US>6</span>个元素，<span lang=EN-US>7</span>个事件，是一个<span
lang=EN-US>6-</span>序列；序列（<span lang=EN-US>2</span>）则有<span lang=EN-US>4</span>个元素，<span
lang=EN-US>11</span>个事件，是一个<span lang=EN-US>4-</span>序列。在书写时，元素通常用<span
lang=EN-US>{}</span>包盖，而序列通常用<span lang=EN-US>&lt;&gt;</span>包盖。需要注意的是，我们不考虑同一个事件的数量，故一个序列的同一个元素中不会出现重复的事件，但一个序列的不同元素中可以出现相同的事件。如，某次购物中，一顾客在超市先购买了<span
lang=EN-US>1</span>盒牛奶，再购买了<span lang=EN-US>2</span>块面包，我们不会将其记为<span
lang=EN-US>{</span>牛奶，面包，面包<span lang=EN-US>}</span>，而是记为<span lang=EN-US>{</span>牛奶，面包<span
lang=EN-US>}</span>。</span></p>

<p class=MsoNormal style='text-indent:22.7pt'><span style='font-family:华文楷体'>此外，我们还需要定义序列之间的包含关系。与项集中的包含关系略有不同，序列之间的包含关系略微复杂一些，具体如下：</span></p>

<p class=MsoNormal style='text-indent:22.7pt'><span style='font-family:华文楷体'>对序列</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=114 height=21
src="chap18.files/image159.png"></span><span style='font-family:华文楷体'>和序列</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=118 height=21
src="chap18.files/image160.png"></span><span style='font-family:华文楷体'>，其中</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=38 height=21
src="chap18.files/image161.png"></span><span style='font-family:华文楷体'>，如果存在整数</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=156 height=21
src="chap18.files/image162.png"></span><span style='font-family:华文楷体'>，使得</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.5pt'><img width=42 height=21
src="chap18.files/image163.png"></span><span style='font-family:华文楷体'>，</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=72 height=21
src="chap18.files/image164.png"></span><span style='font-family:华文楷体'>，那么序列<span
lang=EN-US>T</span>就是序列<span lang=EN-US>S</span>的子序列。下面给出一些简单的示例。</span></p>

<p class=MsoNormal align=center style='text-align:center;text-indent:22.7pt'><span
lang=EN-US><img width=378 height=150 id="图片 34" src="chap18.files/image165.jpg"></span></p>

<p class=MsoNormal style='text-indent:22.7pt'><span lang=EN-US
style='font-family:华文楷体'>&nbsp;</span></p>

<p class=MsoNormal><b><span lang=EN-US style='font-size:12.0pt;font-family:
华文楷体'>18.5.2</span></b><b><span style='font-size:12.0pt;font-family:华文楷体'>时序模式的基本框架</span></b></p>

<p class=MsoNormal style='text-indent:22.7pt'><span style='font-family:华文楷体'>在时序数据中，我们要挖掘的是频繁序列。和挖掘频繁项集类似，我们首先需要定义一个最小支持度阈值（<span
lang=EN-US>minsup</span>）。对于一个序列来说，它的支持度是序列数据库中包含该序列的序列所占的比例，如果它的支持度大于设定的最小支持度阈值，就称其为频繁序列。</span></p>

<p class=MsoNormal align=center style='margin-top:7.8pt;text-align:center;
text-indent:22.7pt'><b><span style='font-family:华文楷体'>表<span lang=EN-US>18-11 </span>一个序列数据库示例</span></b></p>

<p class=MsoNormal align=center style='text-align:center;text-indent:22.7pt'><span
lang=EN-US><img width=452 height=185 id="图片 37" src="chap18.files/image166.jpg"></span></p>

<p class=MsoNormal style='text-indent:22.7pt'><span style='font-family:华文楷体'>在该序列数据库中，每一行是一个序列，每个序列包含多个事件集。假设最小支持度阈值为<span
lang=EN-US>50%</span>，暂且列出部分候选序列的支持度如上右图所示。对于序列<span lang=EN-US>&lt;{b}{c}&gt;</span>，它是<span
lang=EN-US>S001</span>、<span lang=EN-US>S003</span>、<span lang=EN-US>S004</span>的子序列，所以支持度为<span
lang=EN-US>60%</span>，需要注意的是，它并不是<span lang=EN-US>S002</span>的子序列，因为时序数据本身还包含时间信息，在<span
lang=EN-US>S002</span>中，元素<span lang=EN-US>{a, c}</span>出现在<span lang=EN-US>{b,
g}</span>之前，所以<span lang=EN-US>&lt;{c}{b}&gt;</span>是<span lang=EN-US>S002</span>的子序列，而<span
lang=EN-US>&lt;{b}{c}&gt;</span>则不是。对于序列<span lang=EN-US>&lt;{c, g}&gt;</span>，它是<span
lang=EN-US>S003</span>的子序列，而并不是<span lang=EN-US>S002</span>的子序列，同样是因为时间信息的冲突，<span
lang=EN-US>&lt;{c, g}&gt;</span>表示事件<span lang=EN-US>c</span>和事件<span
lang=EN-US>g</span>出现在同一元素中，即两者同时出现，而在<span lang=EN-US>S002</span>中，事件<span
lang=EN-US>c</span>则先于事件<span lang=EN-US>g</span>出现，故<span lang=EN-US>&lt;{c, g}&gt;</span>不是<span
lang=EN-US>S002</span>的子序列。</span></p>

<p class=MsoNormal style='text-indent:22.7pt'><span style='font-family:华文楷体'>下面，我们首先来尝试枚举法，即列出全部的候选序列，然后一一计算它们的支持度，与最小支持度阈值比较，从而搜索出全部的频繁序列。</span></p>

<p class=MsoNormal style='text-indent:22.7pt'><span style='font-family:华文楷体'>不过候选序列和候选项集的枚举有一些不同，具体如下。</span></p>

<p class=MsoNormal style='text-indent:22.7pt'><span style='font-family:华文楷体'>首先，在项集中不会出现重复的项，但是在序列中，一个事件可以重复出现多次。比如，对于项<span
lang=EN-US>a</span>和项<span lang=EN-US>b</span>，可以产生一个候选<span lang=EN-US>2-</span>项集<span
lang=EN-US>{a, b}</span>，但是却可以产生多个候选<span lang=EN-US>2-</span>序列，如<span
lang=EN-US>&lt;{a}{a, b}&gt;</span>，<span lang=EN-US>&lt;{b, a}{b}&gt;</span>，<span
lang=EN-US>&lt;{a}{a}&gt;</span>，<span lang=EN-US>&lt;{a}{b}&gt;</span>，<span
lang=EN-US>&lt;{a, b}{b, a}&gt;</span>等。</span></p>

<p class=MsoNormal style='text-indent:22.7pt'><span style='font-family:华文楷体'>其次，项集忽视了序列信息，而在序列中，事件出现的先后次序是很重要的。比如，<span
lang=EN-US>{a, b}</span>和<span lang=EN-US>{b, a}</span>表示的是相同的项集，但是<span
lang=EN-US>&lt;{a, b}&gt;</span>和<span lang=EN-US>&lt;{b, a}&gt;</span>却是两个不同的序列。</span></p>

<p class=MsoNormal style='text-indent:22.7pt'><span style='font-family:华文楷体'>由于这些不同，在使用枚举法时，候选序列的个数将十分庞大，其数量会随原始数据中事件数量的增加而呈现指数式增长，所以，想要使用枚举法来挖掘频繁序列，是十分困难的。我们希望你能了解使用枚举法挖掘频繁序列的基本过程，能够明白如何列举候选<span
lang=EN-US>k-</span>序列，并学会计算序列的支持度，但我们极力不推荐你使用枚举法，即使数据中的事件数量不多。</span></p>

<p class=MsoNormal style='text-indent:22.7pt'><span style='font-family:华文楷体'>下面，我们将介绍三种用于频繁序列挖掘的算法，它们能帮助我们避免繁杂的枚举，有效减少候选序列数量，从而加速挖掘。</span></p>

<p class=MsoNormal><span lang=EN-US style='font-family:华文楷体'>&nbsp;</span></p>

<p class=MsoNormal><b><span lang=EN-US style='font-size:12.0pt;font-family:
华文楷体'>18.5.3 </span></b><b><span style='font-size:12.0pt;font-family:华文楷体'>基于<span
lang=EN-US>Apriori</span>的算法</span></b></p>

<p class=MsoNormal style='text-indent:22.7pt'><span lang=EN-US
style='font-family:华文楷体'>Rakesh Agrawal</span><span style='font-family:华文楷体'>和<span
lang=EN-US>Ramakrishnan Srikant</span>于<span lang=EN-US>1995</span>年提出了两种基于<span
lang=EN-US>Apriori</span>的序列挖掘算法，分别是<span lang=EN-US>AprioriAll</span>和<span
lang=EN-US>AprioriSome</span>，下面我们将分别介绍并比较。</span></p>

<p class=MsoNormal style='text-indent:22.7pt'><span style='font-family:华文楷体'>首先，我们需要介绍一些基本概念。在本节中，我们称频繁<span
lang=EN-US>1-</span>序列中的项集为<span lang=EN-US>Large Itemset</span>，简写为<span
lang=EN-US>litemset</span>。频繁序列则被称为<span lang=EN-US>Large Sequence</span>，<span
lang=EN-US>Large Sequence</span>中的元素都是<span lang=EN-US>litemset</span>。此外，这一节介绍的两种算法的目的不是挖掘全部的频繁序列，而是挖掘全部的<span
lang=EN-US>maximal sequence</span>。那么什么是<span lang=EN-US>maximal sequence</span>呢？我们定义在频繁序列的集合中，如果一个序列不是集合内任何其他频繁序列的子序列，这个频繁序列就是<span
lang=EN-US>maximal sequence</span>。（后面例子理清楚了，再补上例子描述）</span></p>

<p class=MsoNormal style='text-indent:22.7pt'><span style='font-family:华文楷体'>下面我们来介绍算法的基本框架。<span
lang=EN-US>AprioriAll</span>算法和<span lang=EN-US>AprioriSome</span>算法都遵循这个框架执行。我们将序列挖掘分为<span
lang=EN-US>5</span>个阶段，具体如下。</span></p>

<p class=MsoNormal align=right style='text-align:right;text-indent:22.7pt'><span
lang=EN-US><img width=527 height=41 id="图片 10" src="chap18.files/image167.jpg"></span></p>

<p class=MsoNormal style='text-indent:22.7pt'><span style='font-family:华文楷体'>第一个阶段是<span
lang=EN-US>Sort Phase</span>。我们得到的原始数据库通常如（例子待补充）所示，我们需要将其转换为序列数据库，以表<span
lang=EN-US>18-12</span>为例，以顾客<span lang=EN-US>ID</span>为主键，以交易时间戳为次键，将原始数据库排序后，同一个顾客的全部事务便转换为一条序列，事务按照时间戳从小到大排列，如表<span
lang=EN-US>18-13</span>所示。</span></p>

<p class=MsoNormal align=center style='margin-top:7.8pt;text-align:center;
text-indent:22.7pt'><b><span style='font-family:华文楷体'>表<span lang=EN-US>18-12 </span>某商场用户购物数据库</span></b></p>

<p class=MsoNormal align=center style='text-align:center;text-indent:22.7pt'><span
lang=EN-US><img width=523 height=204 id="图片 46" src="chap18.files/image168.jpg"></span></p>

<p class=MsoNormal align=center style='text-align:center;text-indent:22.7pt'><b><span
lang=EN-US style='font-family:华文楷体'>&nbsp;</span></b></p>

<p class=MsoNormal align=center style='text-align:center;text-indent:22.7pt'><b><span
lang=EN-US style='font-family:华文楷体'>&nbsp;</span></b></p>

<p class=MsoNormal align=center style='margin-top:7.8pt;text-align:center;
text-indent:22.7pt'><b><span style='font-family:华文楷体'>表<span lang=EN-US>18-12 </span>序列数据库</span></b></p>

<p class=MsoNormal align=center style='text-align:center;text-indent:22.7pt'><span
lang=EN-US><img width=252 height=163 id="图片 48" src="chap18.files/image169.jpg"></span></p>

<p class=MsoNormal style='text-indent:22.7pt'><span style='font-family:华文楷体'>第二个阶段是<span
lang=EN-US>Litemset Phase</span>。在这个阶段，我们从上一步得到的序列数据库中，按照挖掘频繁项集的方法，设定最小支持度阈值，迭代寻找频繁<span
lang=EN-US>1-</span>项集，频繁<span lang=EN-US>2-</span>项集等，需要注意的是，在序列数据库中，如果一个项集在同一个序列的不同元素中出现，支持度计数只增加一次，具体过程如图<span
lang=EN-US>18-12</span>所示。</span></p>

<p class=MsoNormal style='text-indent:22.7pt'><span lang=EN-US><img width=509
height=221 id="图片 47" src="chap18.files/image170.jpg"></span></p>

<p class=MsoNormal align=center style='margin-bottom:7.8pt;text-align:center'><b><span
style='font-family:华文楷体'>图<span lang=EN-US>18-12&nbsp; </span>生成全部频繁项集</span></b></p>

<p class=MsoNormal style='text-indent:22.7pt'><span style='font-family:华文楷体'>这些频繁项集的集合就构成了<span
lang=EN-US>litemset</span>的集合，对于<span lang=EN-US>litemset</span>，我们通常会将它们映射到连续的整数或字母上，这样不管项集中项的个数，它们都平等地被看作一个实体，便于表示和比较。我们选择将<span
lang=EN-US>litemsets</span>映射到连续的小写字母上，如表<span lang=EN-US>18-14</span>所示。这里我们使用“（）”代替“<span
lang=EN-US>{}</span>”来表示项集，是为了在下一个阶段作区分。</span></p>

<p class=MsoNormal align=center style='margin-top:7.8pt;text-align:center;
text-indent:22.7pt'><b><span style='font-family:华文楷体'>表<span lang=EN-US>18-14 Large
Itemsets</span>及映射</span></b></p>

<p class=MsoNormal align=center style='margin-bottom:7.8pt;text-align:center'><span
lang=EN-US><img width=437 height=190 id="图片 49" src="chap18.files/image171.jpg"></span></p>

<p class=MsoNormal style='text-indent:22.7pt'><span style='font-family:华文楷体'>第三个阶段是<span
lang=EN-US>Transformation Phase</span>。由于频繁序列中只包含<span lang=EN-US>litemset</span>，所以在这一步中，我们要将之前得到的序列数据库作一些转换。如果一个元素中不包含任何<span
lang=EN-US>litemset</span>，就删除该元素；剩余的每个元素，都转换为这个元素所包含的全部<span lang=EN-US>litemset</span>的集合。而如果一个序列中不包含任何<span
lang=EN-US>litemset</span>，就删除该序列，以表<span lang=EN-US>18-12</span>数据为例，转换后的序列数据库如表<span
lang=EN-US>18-15</span>所示。需要注意的是，即使一个序列在这一步被删除，之后在计算支持度时，序列总数也不会改变，只是我们预先判断这个序列不会包含任何频繁序列，为之后的支持度计算步骤减少计算量。</span></p>

<p class=MsoNormal align=center style='margin-top:7.8pt;text-align:center;
text-indent:22.7pt'><b><span style='font-family:华文楷体'>表<span lang=EN-US>18-15 </span>转换后的序列数据库</span></b></p>

<p class=MsoNormal align=center style='text-align:center'><span lang=EN-US
style='font-family:华文楷体'>&nbsp;</span><span lang=EN-US><img width=537
height=142 id="图片 50" src="chap18.files/image172.jpg"></span></p>

<p class=MsoNormal style='text-indent:22.7pt'><span style='font-family:华文楷体'>第四个阶段是<span
lang=EN-US>Sequence Phase</span>。在这个阶段，我们要利用从第三阶段得到的序列数据库，应用<span lang=EN-US>AprioriAll</span>或<span
lang=EN-US>AprioriSome</span>算法，从中挖掘出全部的频繁序列（<span lang=EN-US>Large Sequences</span>）。具体算法我们之后再详细介绍。</span></p>

<p class=MsoNormal style='text-indent:22.7pt'><span style='font-family:华文楷体'>第五个阶段是<span
lang=EN-US>Maximal Phase</span>。这一阶段的作用是从全部的频繁序列中找出全部的<span lang=EN-US>maximal
sequence</span>。假设全部频繁序列中，最大的序列长度为<span lang=EN-US>n</span>。我们首先遍历每个<span
lang=EN-US>n-</span>序列，删除集合中该<span lang=EN-US>n-</span>序列的全部子序列，然后遍历集合中剩余的（<span
lang=EN-US>n-1</span>）<span lang=EN-US>-</span>序列，同样从集合中删除其全部子序列，按照这个步骤，<span
lang=EN-US>n</span>逐渐递减，当<span lang=EN-US>n</span>等于<span lang=EN-US>1</span>时，结束遍历，此时，集合中剩余的全部频繁序列都是<span
lang=EN-US>maximal sequence</span>。（考虑给简短的伪代码）</span></p>

<p class=MsoNormal style='text-indent:22.7pt'><span style='font-family:华文楷体'>现在让我们来详细描述<span
lang=EN-US>Sequence Phase</span>。这一阶段算法的基本思想和我们之前介绍的<span lang=EN-US>Apriori</span>算法类似，即自底向上，通过多轮迭代来产生全部的频繁序列。第一轮时，由于我们已经得到了<span
lang=EN-US>litemset</span>的集合，将它们略作转换，便是<span lang=EN-US>1-</span>频繁序列的集合，记为</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=13 height=21
src="chap18.files/image036.png"></span><span style='font-family:华文楷体'>。而后，从第二轮开始的每一轮，我们先通过上一轮得到的频繁序列集合，生成当前这轮的候选频繁序列，然后计算它们的支持度，与最小支持度阈值比较，得到本轮的频繁序列集合，然后就能继续下一轮迭代，当某轮的候选频繁序列集合或频繁序列集合为空集时，迭代结束，我们就得到了全部的频繁序列集合，进入下个阶段。</span></p>

<p class=MsoNormal style='text-indent:22.7pt'><span style='font-family:华文楷体'>考虑到我们的最终目的是挖掘出全部的<span
lang=EN-US>maximal sequence</span>，这一阶段便出现了两种思路，分别是<span lang=EN-US>count-all</span>和<span
lang=EN-US>count-some</span>。<span lang=EN-US>AprioriAll</span>就是<span
lang=EN-US>count-all</span>类型的算法，即统计全部序列的支持度，产生全部频繁序列后，在<span lang=EN-US>maximal
phase</span>再将其中的<span lang=EN-US>non-maximal sequence</span>剪枝。而<span
lang=EN-US>count-some</span>类型的算法<span lang=EN-US>AprioriSome</span>则是将<span
lang=EN-US>sequence phase</span>和<span lang=EN-US>maximal phase</span>合并，这类算法分为向前和向后两个阶段，目的是在挖掘过程中尽量避免统计<span
lang=EN-US>non-maximal sequence</span>，但代价是它可能会需要统计一些非频繁序列的支持度，这其中的平衡便决定了算法的性能。下面我们将依次介绍这两种算法。</span></p>

<p class=MsoNormal style='text-indent:22.7pt'><span lang=EN-US
style='font-family:华文楷体'>AprioriAll</span><span style='font-family:华文楷体'>算法和我们之前介绍的<span
lang=EN-US>Apriori</span>算法的基本流程一模一样，只是在生成候选序列和支持度计数两个过程的细节略有不同。假设我们现在得到了</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=27 height=21
src="chap18.files/image054.png"></span><span style='font-family:华文楷体'>，现在要产生候选序列集合</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=14 height=21
src="chap18.files/image055.png"></span><span style='font-family:华文楷体'>，其过程具体如下：（提供伪代码）（提供案例）</span></p>

<p class=MsoNormal style='text-indent:22.7pt'><span lang=EN-US
style='font-family:华文楷体'>&nbsp;</span></p>

<p class=MsoNormal style='text-indent:22.7pt'><span style='font-family:华文楷体'>需要注意的是，在序列中顺序很重要，所以<span
lang=EN-US>&lt;{a, b}&gt;</span>、<span lang=EN-US>&lt;{a, c}&gt;</span>能生成<span
lang=EN-US>&lt;{a, b, c}&gt;</span>和<span lang=EN-US>&lt;a, c, b&gt;</span>两个候选序列。</span></p>

<p class=MsoNormal style='text-indent:22.7pt'><span style='font-family:华文楷体'>对于支持度计数过程，我们可以像<span
lang=EN-US>Apriori</span>算法一样扫描整个序列数据库，然后得到每个候选序列的支持度计数，但是这需要多次扫描序列数据库，换个角度来说，对于序列数据库中的每个序列<span
lang=EN-US>s</span>，我们都需要检查各个候选序列<span lang=EN-US>c</span>是否被<span lang=EN-US>s</span>支持，十分费时。</span></p>

<p class=MsoNormal style='text-indent:22.7pt'><span style='font-family:华文楷体'>这里我们介绍一种新的计算支持度的方法，其目的是对于序列数据库中的每个序列<span
lang=EN-US>s</span>，可以不必检查每个候选序列<span lang=EN-US>c</span>，减少需要统计的候选序列的数量，从而实现加速。</span></p>

<p class=MsoNormal style='text-indent:22.7pt'><span style='font-family:华文楷体'>假设我们要统计</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=14 height=21
src="chap18.files/image055.png"></span><span style='font-family:华文楷体'>中全部序列的支持度，那么我们首先根据</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=14 height=21
src="chap18.files/image055.png"></span><span style='font-family:华文楷体'>来构建<span
lang=EN-US>hash</span>树，<span lang=EN-US>hash</span>树的节点分为叶结点和内部结点，叶结点中存储的是候选序列的集合，而内部结点中存储的则是<span
lang=EN-US>hash</span>表。我们定义根结点的深度为<span lang=EN-US>1</span>，深度为<span
lang=EN-US>d</span>的结点指向深度为<span lang=EN-US>d+1</span>的结点。构建<span lang=EN-US>hash</span>树时，我们依次读入候选序列，起初每个候选序列都放入叶结点，当叶结点的候选序列数达到我们设定的阈值时，该叶结点就需要分裂，假设该叶结点的深度为<span
lang=EN-US>k</span>，其中的候选序列就将其第<span lang=EN-US>k</span>个<span lang=EN-US>litemset</span>作为<span
lang=EN-US>hash</span>函数的输入，根据返回值散列到不同的叶结点中，原本的叶结点则变成内部结点，其中存储一个<span
lang=EN-US>hash</span>表。</span></p>

<p class=MsoNormal style='text-indent:22.7pt'><span style='font-family:华文楷体'>构建完<span
lang=EN-US>hash</span>树后，我们再依次读入序列数据库中的序列，统计它们需要检查哪些候选序列。假设我们当前读入序列<span
lang=EN-US>s</span>，在根结点时，我们将序列<span lang=EN-US>s</span>的每个<span lang=EN-US>litemset</span>依次作为<span
lang=EN-US>hash</span>函数的输入，得到返回值，然后根据返回值定位到下一层的结点。此时，会出现两种情况。如果我们到达的是叶结点，那么该叶结点中的序列就是序列<span
lang=EN-US>s</span>需要检查的候选序列；而如果我们现在到达的是内部结点，假设我们是通过散列序列<span lang=EN-US>s</span>的某个<span
lang=EN-US>litemset</span>（称为<span lang=EN-US>i</span>）到达该内部结点的，那么在下一次散列时，我们只需要考虑<span
lang=EN-US>s</span>中包含<span lang=EN-US>i</span>的元素的后一个元素中的<span lang=EN-US>litemset</span>，并依次对它们进行散列即可，而不需要散列<span
lang=EN-US>s</span>中的全部<span lang=EN-US>litemset</span>。将序列<span lang=EN-US>s</span>散列完成后，我们就得到了序列<span
lang=EN-US>s</span>所需要检查的候选序列集合</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=13 height=21
src="chap18.files/image173.png"></span><span style='font-family:华文楷体'>，然后再一一检查，统计支持度即可。以相同的步骤处理序列数据库中的每个序列后，我们就得到了全部候选序列的支持度计数。</span></p>

<p class=MsoNormal style='text-indent:22.7pt'><span style='font-family:华文楷体'>然后再根据候选序列的支持度计数，与最小支持度阈值比较，我们就能得到全部的频繁序列，再将这些频繁序列作为下一阶段<span
lang=EN-US>Maximal Phase</span>的输入即可。</span></p>

<p class=MsoNormal style='margin-left:21.0pt;text-indent:1.7pt'><span
lang=EN-US><img width=554 height=236 id="图片 52" src="chap18.files/image174.jpg"><img
width=554 height=239 id="图片 53" src="chap18.files/image175.jpg"></span></p>

<p class=MsoNormal align=center style='margin-bottom:7.8pt;text-align:center'><b><span
style='font-family:华文楷体'>图<span lang=EN-US>18-13&nbsp; AprioriAll</span>算法生成过程</span></b></p>

<p class=MsoNormal style='text-indent:22.7pt'><span style='font-family:华文楷体'>然后我们还需要进行<span
lang=EN-US>maximal phase</span>，由于频繁<span lang=EN-US>4-</span>序列只有<span
lang=EN-US>&lt;{a}{b}{c}{d}&gt;</span>，我们要从</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=14 height=21
src="chap18.files/image039.png"></span><span style='font-family:华文楷体'>、</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=13 height=21
src="chap18.files/image036.png"></span><span style='font-family:华文楷体'>和</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=14 height=21
src="chap18.files/image038.png"></span><span style='font-family:华文楷体'>中删除其全部子序列。此时</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=14 height=21
src="chap18.files/image039.png"></span><span style='font-family:华文楷体'>中只剩下<span
lang=EN-US>&lt;{a}{c}{e}&gt;</span>，我们再从</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=13 height=21
src="chap18.files/image036.png"></span><span style='font-family:华文楷体'>和</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=14 height=21
src="chap18.files/image038.png"></span><span style='font-family:华文楷体'>中删除其全部子序列。删除后，</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=14 height=21
src="chap18.files/image038.png"></span><span style='font-family:华文楷体'>中没有剩余序列，该阶段结束。最后我们得到全部的<span
lang=EN-US>maximal sequence</span>，具体为：<span lang=EN-US>&lt;{a}{b}{c}{d}&gt;</span>、<span
lang=EN-US>&lt;{a}{c}{e}&gt;</span>、<span lang=EN-US>&lt;{f}&gt;</span>、<span
lang=EN-US>&lt;{a, c}&gt;</span>、<span lang=EN-US>&lt;{a, f}&gt;</span>、<span
lang=EN-US>&lt;{c, f}&gt;</span>、<span lang=EN-US>&lt;{a, c, f}&gt;</span>。</span></p>

<p class=MsoNormal style='text-indent:22.7pt'><span style='font-family:华文楷体'>接着，我们来介绍<span
lang=EN-US>AprioriSome</span>算法。该算法分为两个阶段，首先是向前迭代阶段，这个阶段只挖掘特定长度的序列；然后是向后迭代阶段，这个阶段是挖掘出剩余的序列。比如，我们可能在向前迭代阶段挖掘了长度为<span
lang=EN-US>1</span>、<span lang=EN-US>2</span>、<span lang=EN-US>4</span>、<span
lang=EN-US>6</span>的频繁序列，然后在向后迭代阶段挖掘长度为<span lang=EN-US>3</span>和<span
lang=EN-US>5</span>的频繁序列。为了确定在向前迭代阶段中，下一轮所要挖掘的序列长度，我们定义了一个<span lang=EN-US>next</span>函数，该函数以本轮挖掘的序列长度为输入，并输出下一轮所要挖掘的序列长度。设输入参数为<span
lang=EN-US>k</span>，即本轮挖掘得到了长度为<span lang=EN-US>k</span>的频繁序列，我们令</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:13.0pt'><img width=61 height=42
src="chap18.files/image176.png"></span><span style='font-family:华文楷体'>，即在长度为<span
lang=EN-US>k</span>的候选序列中，频繁<span lang=EN-US>k-</span>序列所占的比例。而通常我们的直觉是，</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=24 height=21
src="chap18.files/image177.png"></span><span style='font-family:华文楷体'>越大，由</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=14 height=21
src="chap18.files/image056.png"></span><span style='font-family:华文楷体'>迭代产生的候选序列中非频繁序列越少，在非频繁序列上的统计开销就会少于在<span
lang=EN-US>non-maximal sequence</span>上的统计开销，就值得我们跳过更多的长度，所以我们给出<span
lang=EN-US>next</span>函数如下：</span></p>

<p class=MsoNormal align=center style='text-align:center;text-indent:22.7pt'><span
lang=EN-US><img width=256 height=149 id="图片 11" src="chap18.files/image178.jpg"></span></p>

<p class=MsoNormal style='text-indent:22.7pt'><span style='font-family:华文楷体'>设置<span
lang=EN-US>next</span>函数的作用就是在统计非频繁序列和统计<span lang=EN-US>non-maximal</span>序列的开销之间寻求一个最佳的平衡点。如果不论<span
lang=EN-US>k</span>是多少，</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=45 height=21
src="chap18.files/image179.png"></span><span style='font-family:华文楷体'>总是返回<span
lang=EN-US>k+1</span>，此时就是选择统计全部的<span lang=EN-US>non-maximal</span>序列，<span
lang=EN-US>AprioriSome</span>算法就等价于<span lang=EN-US>AprioriAll</span>算法。相反，如果</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=110 height=21
src="chap18.files/image180.png"></span><span style='font-family:华文楷体'>，即返回一个与输入相差很大的数，那么就相当于选择统计大量的非频繁序列，是另一种极限情况。由于我们可能跳过某几个长度的序列，所以在第<span
lang=EN-US>k</span>轮迭代时，我们不一定得到了</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=27 height=21
src="chap18.files/image054.png"></span><span style='font-family:华文楷体'>，此时就可以通过</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=28 height=21
src="chap18.files/image181.png"></span><span style='font-family:华文楷体'>来生成</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=14 height=21
src="chap18.files/image055.png"></span><span style='font-family:华文楷体'>，因为</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=73 height=21
src="chap18.files/image182.png"></span><span style='font-family:华文楷体'>，所以可以保证生成的</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=14 height=21
src="chap18.files/image055.png"></span><span style='font-family:华文楷体'>不遗漏任何频繁序列。<span
lang=EN-US>AprioriSome</span>算法生成候选序列的规则和<span lang=EN-US>AprioriAll</span>算法相同，<span
lang=EN-US>k</span>从<span lang=EN-US>2</span>开始逐渐递增，只有当<span lang=EN-US>k</span>和</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=45 height=21
src="chap18.files/image179.png"></span><span style='font-family:华文楷体'>的返回值相等时，才会计算当前</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=14 height=21
src="chap18.files/image055.png"></span><span style='font-family:华文楷体'>的支持度，从而得到</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=14 height=21
src="chap18.files/image056.png"></span><span style='font-family:华文楷体'>，否则，不需要对</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=14 height=21
src="chap18.files/image055.png"></span><span style='font-family:华文楷体'>进行支持度计数。</span></p>

<p class=MsoNormal style='text-indent:22.7pt'><span style='font-family:华文楷体'>当某一轮迭代生成的候选序列或频繁序列集合为空时，向前迭代阶段就终止，进入向后迭代阶段。假设我们已经挖掘了长度为<span
lang=EN-US>1</span>、<span lang=EN-US>2</span>、<span lang=EN-US>4</span>、<span
lang=EN-US>6</span>的频繁序列，此时转入向后迭代阶段，我们就要挖掘长度为<span lang=EN-US>5</span>和<span
lang=EN-US>3</span>的频繁序列，此时我们已经得到了</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=14 height=21
src="chap18.files/image183.png"></span><span style='font-family:华文楷体'>，由于我们的目标是<span
lang=EN-US>maximal sequence</span>，所以</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=14 height=21
src="chap18.files/image184.png"></span><span style='font-family:华文楷体'>中是</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=14 height=21
src="chap18.files/image183.png"></span><span style='font-family:华文楷体'>中某个序列的子集的序列都可以被剪枝，同理，</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=14 height=21
src="chap18.files/image089.png"></span><span style='font-family:华文楷体'>、</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=14 height=21
src="chap18.files/image045.png"></span><span style='font-family:华文楷体'>、</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=14 height=21
src="chap18.files/image038.png"></span><span style='font-family:华文楷体'>、</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=13 height=21
src="chap18.files/image036.png"></span><span style='font-family:华文楷体'>中的子序列也都直接被剪枝。</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=14 height=21
src="chap18.files/image183.png"></span><span style='font-family:华文楷体'>的子序列都被剪枝后，我们再根据</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=14 height=21
src="chap18.files/image185.png"></span><span style='font-family:华文楷体'>进行剪枝，即序列长度递减，不断剪枝，最后留下的就都是<span
lang=EN-US>maximal sequence</span>。</span></p>

<p class=MsoNormal style='text-indent:22.7pt'><span style='font-family:华文楷体'>下面我们给出<span
lang=EN-US>AprioriSome</span>的伪代码，具体如下。</span></p>

<p class=MsoNormal style='text-indent:22.7pt'><span lang=EN-US
style='font-family:华文楷体'>&nbsp;</span></p>

<p class=MsoNormal style='text-indent:22.7pt'><span lang=EN-US
style='font-family:华文楷体'>&nbsp;</span></p>

<p class=MsoNormal style='text-indent:22.7pt'><span lang=EN-US
style='font-family:华文楷体'>&nbsp;</span></p>

<p class=MsoNormal style='text-indent:22.7pt'><span lang=EN-US
style='font-family:华文楷体'>&nbsp;</span></p>

<p class=MsoNormal style='text-indent:22.7pt'><span lang=EN-US
style='font-family:华文楷体'>&nbsp;</span></p>

<p class=MsoNormal style='text-indent:22.7pt'><span lang=EN-US
style='font-family:华文楷体'>&nbsp;</span></p>

<p class=MsoNormal style='text-indent:22.7pt'><span lang=EN-US
style='font-family:华文楷体'>&nbsp;</span></p>

<p class=MsoNormal style='text-indent:22.7pt'><span lang=EN-US
style='font-family:华文楷体'>&nbsp;</span></p>

<p class=MsoNormal style='text-indent:22.7pt'><span lang=EN-US
style='font-family:华文楷体'>&nbsp;</span></p>

<p class=MsoNormal style='text-indent:22.7pt'><span style='font-family:华文楷体'>以表<span
lang=EN-US>18-15</span>中的数据为例，我们简单假设</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=78 height=21
src="chap18.files/image186.png"></span><span style='font-family:华文楷体'>，所以<span
lang=EN-US>AprioriSome</span>算法先生成</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=14 height=21
src="chap18.files/image035.png"></span><span style='font-family:华文楷体'>和</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=13 height=21
src="chap18.files/image036.png"></span><span style='font-family:华文楷体'>，然后生成</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=14 height=21
src="chap18.files/image037.png"></span><span style='font-family:华文楷体'>和</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=14 height=21
src="chap18.files/image038.png"></span><span style='font-family:华文楷体'>，这一部分过程和<span
lang=EN-US>AprioriAll</span>算法基本一致，如图所示：</span></p>

<p class=MsoNormal><span lang=EN-US><img width=548 height=232 id="图片 55"
src="chap18.files/image187.jpg"></span></p>

<p class=MsoNormal align=center style='margin-bottom:7.8pt;text-align:center'><b><span
style='font-family:华文楷体'>图<span lang=EN-US>18-14&nbsp; AprioriSome</span>算法生成</span></b><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=14 height=21
src="chap18.files/image188.png"></span><b><span style='font-family:华文楷体'>和</span></b><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=14 height=21
src="chap18.files/image189.png"></span></p>

<p class=MsoNormal style='text-indent:22.7pt'><span style='font-family:华文楷体'>接着会根据</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=14 height=21
src="chap18.files/image038.png"></span><span style='font-family:华文楷体'>生成</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=14 height=21
src="chap18.files/image045.png"></span><span style='font-family:华文楷体'>，并跳过</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=14 height=21
src="chap18.files/image039.png"></span><span style='font-family:华文楷体'>，直接生成</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=14 height=21
src="chap18.files/image049.png"></span><span style='font-family:华文楷体'>与</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=14 height=21
src="chap18.files/image089.png"></span><span style='font-family:华文楷体'>，具体如图<span
lang=EN-US>18-15</span>所示。我们在生成</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=14 height=21
src="chap18.files/image045.png"></span><span style='font-family:华文楷体'>时，只通过先验原理对其进行剪枝，由于不需要生成</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=14 height=21
src="chap18.files/image039.png"></span><span style='font-family:华文楷体'>，所以不用对</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=14 height=21
src="chap18.files/image045.png"></span><span style='font-family:华文楷体'>进行支持度计数。</span></p>

<p class=MsoNormal align=center style='text-align:center;text-indent:22.7pt'><span
lang=EN-US><img width=387 height=268 id="图片 57" src="chap18.files/image190.jpg"></span></p>

<p class=MsoNormal align=center style='margin-bottom:7.8pt;text-align:center'><b><span
style='font-family:华文楷体'>图<span lang=EN-US>18-15&nbsp; AprioriSome</span>算法生成</span></b><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=15 height=21
src="chap18.files/image191.png"></span><b><span style='font-family:华文楷体'>和</span></b><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=14 height=21
src="chap18.files/image192.png"></span></p>

<p class=MsoNormal style='text-indent:22.7pt'><span style='font-family:华文楷体'>由于</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=14 height=21
src="chap18.files/image089.png"></span><span style='font-family:华文楷体'>生成</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=14 height=21
src="chap18.files/image184.png"></span><span style='font-family:华文楷体'>时，得到空集，所以向前阶段结束，下面我们进行向后阶段。首先，检查</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=14 height=21
src="chap18.files/image089.png"></span><span style='font-family:华文楷体'>，由于只有一个序列，所以其必定是<span
lang=EN-US>maximal sequence</span>，无需删除。然后，我们从</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=14 height=21
src="chap18.files/image045.png"></span><span style='font-family:华文楷体'>、</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=13 height=21
src="chap18.files/image036.png"></span><span style='font-family:华文楷体'>和</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=14 height=21
src="chap18.files/image038.png"></span><span style='font-family:华文楷体'>中找到<span
lang=EN-US>&lt;{a}{b}{c}{d}&gt;</span>的子序列并删除，结果如图<span lang=EN-US>18-16</span>所示。然后再将</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=14 height=21
src="chap18.files/image045.png"></span><span style='font-family:华文楷体'>中剩余的序列进行支持度计数，根据最小支持度计数筛选得到<span
lang=EN-US>&lt;{a}{c}{e}&gt;</span>，再从</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=13 height=21
src="chap18.files/image036.png"></span><span style='font-family:华文楷体'>和</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=14 height=21
src="chap18.files/image038.png"></span><span style='font-family:华文楷体'>中删除该频繁<span
lang=EN-US>3-</span>序列的子序列，结果如图<span lang=EN-US>18-17</span>所示。由于频繁<span
lang=EN-US>2-</span>序列中没有<span lang=EN-US>maximal sequence</span>，所以我们已经得到了全部的<span
lang=EN-US>maximal sequence</span>，这与<span lang=EN-US>AprioriAll</span>算法得到的结果相同。</span></p>

<p class=MsoNormal align=center style='text-align:center;text-indent:22.7pt'><span
lang=EN-US><img width=440 height=267 id="图片 58" src="chap18.files/image193.jpg"></span></p>

<p class=MsoNormal align=center style='margin-bottom:7.8pt;text-align:center'><b><span
style='font-family:华文楷体'>图<span lang=EN-US>18-16&nbsp; AprioriSome</span>算法后退阶段（<span
lang=EN-US>1</span>）</span></b></p>

<p class=MsoNormal align=center style='text-align:center;text-indent:22.7pt'><span
lang=EN-US><img width=442 height=239 id="图片 59" src="chap18.files/image194.jpg"></span></p>

<p class=MsoNormal align=center style='margin-bottom:7.8pt;text-align:center'><b><span
style='font-family:华文楷体'>图<span lang=EN-US>18-17&nbsp; AprioriSome</span>算法后退阶段（<span
lang=EN-US>2</span>）</span></b></p>

<p class=MsoNormal style='text-indent:22.7pt'><span lang=EN-US
style='font-family:华文楷体'>&nbsp;</span></p>

<p class=MsoNormal style='text-indent:22.7pt'><span lang=EN-US
style='font-family:华文楷体'>&nbsp;</span></p>

<p class=MsoNormal><b><span lang=EN-US style='font-size:12.0pt;font-family:
华文楷体'>18.5.4 GSP</span></b><b><span style='font-size:12.0pt;font-family:华文楷体'>算法</span></b></p>

<p class=MsoNormal style='text-indent:22.7pt'><span style='font-family:华文楷体'>在实际应用中，我们常常需要对序列模式加上一些时限约束，以助于其更好地反映元素之间的关联。比如，给定如下购物序列：<span
lang=EN-US>&lt;{</span>洗衣机<span lang=EN-US>}{</span>方便面<span lang=EN-US>}{</span>啤酒<span
lang=EN-US>}&gt;</span>，其中洗衣机和方便面的购买时间相隔一年，由于时间间隔较长，我们很难认为一年前购买的洗衣机会对一年后购买的方便面有影响或联系，因此，我们需要再原先的序列模式定义之上，引入时限约束，从而定义新的序列模式。<span
lang=EN-US>GSP</span>算法便是针对这种新的序列模式所提出的挖掘算法。</span></p>

<p class=MsoNormal style='text-indent:22.7pt'><span style='font-family:华文楷体'>下面我们首先来介绍<span
lang=EN-US>GSP</span>算法中对序列模式的约束。</span></p>

<p class=MsoListParagraph style='margin-left:43.7pt;text-indent:-21.0pt'><b><span
lang=EN-US style='font-family:华文楷体'>(1)<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;
</span></span></b><b><span style='font-family:华文楷体'>最大间隔和最小间隔约束</span></b></p>

<p class=MsoNormal style='text-indent:22.7pt'><span style='font-family:华文楷体'>这是通过约束序列中两个连续元素之间的时间差来限制序列模式。若设定最大时间差（<span
lang=EN-US>maxgap</span>）为<span lang=EN-US>3</span>，则当前元素中的事件和前一个元素中的事件的间隔不能超过<span
lang=EN-US>3</span>，而设定最小时间差（<span lang=EN-US>mingap</span>）为<span lang=EN-US>0</span>，则意味着当前元素中的事件必须在前一个元素中的事件之后立即出现。下面我们设定<span
lang=EN-US>maxgap=4</span>，<span lang=EN-US>mingap=2</span>，给出子序列是否满足最大间隔和最小间隔约束的案例。</span></p>

<p class=MsoNormal align=center style='text-align:center;text-indent:22.7pt'><span
lang=EN-US><img width=417 height=148 id="图片 14" src="chap18.files/image195.jpg"></span></p>

<p class=MsoNormal style='text-indent:22.7pt'><span style='font-family:华文楷体'>需要注意的是，由于加入了时限约束，在进行支持度计数时，我们还需要检查候选序列是否满足时限约束。此外，先验原理可能不再成立。假设序列数据库中某条序列为<span
lang=EN-US>&lt;{a}{b}{c}&gt;</span>，当没有时限约束时，序列<span lang=EN-US>&lt;{a}{c}&gt;</span>和<span
lang=EN-US>&lt;{a}{b}{c}&gt;</span>都被该序列支持，此时加入时限约束<span lang=EN-US>maxgap=1</span>，<span
lang=EN-US>mingap=0</span>，那么序列<span lang=EN-US>&lt;{a}{c}&gt;</span>就不再被支持，而序列<span
lang=EN-US>&lt;{a}{b}{c}&gt;</span>依旧被支持，这就可能导致序列<span lang=EN-US>&lt;{a}{b}{c}&gt;</span>的支持度超过其子序列的支持度，与先验原理相悖。之后我们会来解决这个问题。</span></p>

<p class=MsoListParagraph style='margin-left:43.7pt;text-indent:-21.0pt'><b><span
lang=EN-US style='font-family:华文楷体'>(2)<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;
</span></span></b><b><span style='font-family:华文楷体'>窗口大小约束</span></b></p>

<p class=MsoListParagraph><span style='font-family:华文楷体'>我们定义一个窗口大小阈值（<span
lang=EN-US>window size</span>），通常简写为<span lang=EN-US>ws</span>。它用于指定一个序列中的任意元素中的事件最早和最晚出现的最大允许时间差。比如，当窗口大小为<span
lang=EN-US>0</span>时，同一元素中的全部事件必须同时出现，而当窗口大小为<span lang=EN-US>1</span>时，子序列中某个元素里的多个事件可以在原数据库序列中的两个相邻元素内出现。下面我们设定<span
lang=EN-US>ws=2</span>，给出如下案例。</span></p>

<p class=MsoListParagraph align=center style='text-align:center'><span
lang=EN-US><img width=402 height=158 id="图片 15" src="chap18.files/image196.jpg"></span></p>

<p class=MsoListParagraph><span style='font-family:华文楷体'>需要注意的是，如果在<span
lang=EN-US>ws=2</span>的基础上，我们再加入<span lang=EN-US>maxgap=3</span>的限制，那么表格中第四行的子序列<span
lang=EN-US>&lt;{a, b, c}{e, f, g}&gt;</span>就不再被<span lang=EN-US>s</span>支持，因为其最大时间差为事件<span
lang=EN-US>a</span>和<span lang=EN-US>g</span>的事件差<span lang=EN-US>5</span>，不满足<span
lang=EN-US>maxgap</span>的限制。</span></p>

<p class=MsoListParagraph><span style='font-family:华文楷体'>最大间隔和最小间隔约束是加大了对频繁序列的限制，而窗口大小约束则是在一定程度上放松了对频繁序列的判定，能帮助我们避免错过一些有趣的序列模式。</span></p>

<p class=MsoListParagraph style='margin-left:43.7pt;text-indent:-21.0pt'><b><span
lang=EN-US style='font-family:华文楷体'>(3)<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;
</span></span></b><b><span style='font-family:华文楷体'>分类标准约束</span></b></p>

<p class=MsoListParagraph><span style='font-family:华文楷体'>分类标准约束是加入了对事件之间纵向关系的考量。比如，事件<span
lang=EN-US>a</span>是事件<span lang=EN-US>b</span>的上层事件，且事件<span lang=EN-US>b</span>属于元素<span
lang=EN-US>e</span>，那么事件<span lang=EN-US>a</span>也属于元素<span lang=EN-US>e</span>。不过，在之后的讨论中，我们不会考虑分类标准约束，而只考虑前面的两种时限约束。</span></p>

<p class=MsoListParagraph><span style='font-family:华文楷体'>介绍完了对序列模式的约束，下面我们开始介绍<span
lang=EN-US>GSP</span>算法。</span></p>

<p class=MsoListParagraph><span style='font-family:华文楷体'>首先，我们需要重新定义<span
lang=EN-US>k-</span>序列。之前，我们定义包含<span lang=EN-US>k</span>个元素的序列为<span
lang=EN-US>k-</span>序列，而在<span lang=EN-US>GSP</span>算法中，我们定义包含<span lang=EN-US>k</span>个事件的序列为<span
lang=EN-US>k-</span>序列，对于序列<span lang=EN-US>&lt;{a, b}{c}&gt;</span>，按之前的定义，它是<span
lang=EN-US>2-</span>序列，而现在它是<span lang=EN-US>3-</span>序列。而对于序列<span lang=EN-US>&lt;{a,
b}{a, c}&gt;</span>，按之前的定义，它是<span lang=EN-US>2-</span>序列，现在它则是<span
lang=EN-US>4-</span>序列。即同一个事件出现在不同的元素中时，需要重复计数。关于这么定义的理由，我们会在之后阐述。</span></p>

<p class=MsoListParagraph><span style='font-family:华文楷体'>由于引入最大间隔和最小间隔约束后，先验原理不再满足，为了解决这一问题，我们现在给出邻接子序列的定义，从而改进先验原理。</span></p>

<p class=MsoListParagraph><b><span style='font-family:华文楷体'>定义<span lang=EN-US>18.4
</span>邻接子序列 </span></b><span style='font-family:华文楷体'>给定一个序列</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=102 height=21
src="chap18.files/image197.png"></span><span style='font-family:华文楷体'>和一个子序列<span
lang=EN-US>c</span>，如果下列条件之一成立，那么就称<span lang=EN-US>c</span>为<span lang=EN-US>s</span>的邻接子序列（<span
lang=EN-US>contiguous subsequence</span>）。</span></p>

<p class=MsoListParagraph style='margin-left:39.0pt;text-indent:-18.0pt'><span
lang=EN-US style='font-family:华文楷体'>1．<span style='font:7.0pt "Times New Roman"'>&nbsp;
</span></span><span lang=EN-US style='font-family:华文楷体'>c</span><span
style='font-family:华文楷体'>是从<span lang=EN-US>s</span>中的</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=12 height=21
src="chap18.files/image198.png"></span><span style='font-family:华文楷体'>或</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=13 height=21
src="chap18.files/image199.png"></span><span style='font-family:华文楷体'>中删除一个事件后得到的。</span></p>

<p class=MsoListParagraph style='margin-left:39.0pt;text-indent:-18.0pt'><span
lang=EN-US style='font-family:华文楷体'>2．<span style='font:7.0pt "Times New Roman"'>&nbsp;
</span></span><span lang=EN-US style='font-family:华文楷体'>c</span><span
style='font-family:华文楷体'>是从<span lang=EN-US>s</span>中至少包含两个事件的元素里删除一个事件后得到的。</span></p>

<p class=MsoListParagraph style='margin-left:39.0pt;text-indent:-18.0pt'><span
lang=EN-US style='font-family:华文楷体'>3．<span style='font:7.0pt "Times New Roman"'>&nbsp;
</span></span><span lang=EN-US style='font-family:华文楷体'>c</span><span
style='font-family:华文楷体'>是<span lang=EN-US>t</span>的邻接子序列，而<span lang=EN-US>t</span>是<span
lang=EN-US>s</span>的邻接子序列。</span></p>

<p class=MsoListParagraph><span style='font-family:华文楷体'>下面我们给出一个案例，帮助更好地理解邻接子序列的概念。</span></p>

<p class=MsoListParagraph align=center style='text-align:center'><span
lang=EN-US><img width=452 height=224 id="图片 16" src="chap18.files/image200.jpg"></span></p>

<p class=MsoListParagraph><span style='font-family:华文楷体'>利用邻接子序列，我们可以得到如下形式的先验原理：如果一个<span
lang=EN-US>k-</span>序列是频繁的，则它的所有邻接</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=43 height=21
src="chap18.files/image201.png"></span><span lang=EN-US style='font-family:
华文楷体'>-</span><span style='font-family:华文楷体'>子序列一定是频繁的。</span></p>

<p class=MsoListParagraph><span style='font-family:华文楷体'>如果一个序列<span
lang=EN-US>s</span>支持序列模式<span lang=EN-US>t</span>，那么当没有最大间隔约束时，序列<span
lang=EN-US>s</span>也一定会支持<span lang=EN-US>t</span>的所有子序列；而若有最大间隔约束，序列<span
lang=EN-US>s</span>则一定会支持<span lang=EN-US>t</span>的所有邻接子序列。所以上述先验原理是成立的。</span></p>

<p class=MsoListParagraph><span lang=EN-US style='font-family:华文楷体'>GSP</span><span
style='font-family:华文楷体'>算法的整体框架和<span lang=EN-US>Apriori</span>算法类似，第一轮扫描原始序列数据库，得到全部<span
lang=EN-US>1-</span>序列的支持度，再根据设定的最小支持度阈值筛选出频繁<span lang=EN-US>1-</span>序列。之后每轮将迭代地产生新的候选<span
lang=EN-US>k-</span>序列，然后利用先验原理剪枝，接着对剩余候选序列进行支持度计数，得到每轮的频繁<span lang=EN-US>k-</span>序列。但是，<span
lang=EN-US>GSP</span>算法的候选生成过程和支持度计数过程与<span lang=EN-US>Apriori</span>算法不同，下面我们将进行详细描述。</span></p>

<p class=MsoListParagraph><span style='font-family:华文楷体'>首先是候选生成过程。这个过程分为两个阶段，具体如下：</span></p>

<p class=MsoNormal><span lang=EN-US style='font-family:华文楷体'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span
style='font-family:华文楷体'>第一步是连接阶段，即通过连接频繁</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=43 height=21
src="chap18.files/image202.png"></span><span lang=EN-US style='font-family:
华文楷体'>-</span><span style='font-family:华文楷体'>序列来生成候选<span lang=EN-US>k-</span>序列。假设有两个<span
lang=EN-US>k-</span>序列</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=12 height=21
src="chap18.files/image198.png"></span><span style='font-family:华文楷体'>和</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=12 height=21
src="chap18.files/image203.png"></span><span style='font-family:华文楷体'>，如果从</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=12 height=21
src="chap18.files/image198.png"></span><span style='font-family:华文楷体'>中去掉第一个事件得到的子序列与从</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=12 height=21
src="chap18.files/image203.png"></span><span style='font-family:华文楷体'>中去掉最后一个事件得到的子序列相同，那么</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=12 height=21
src="chap18.files/image198.png"></span><span style='font-family:华文楷体'>和</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=12 height=21
src="chap18.files/image203.png"></span><span style='font-family:华文楷体'>是可以合并的。在可以合并的情况下，如果</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=12 height=21
src="chap18.files/image203.png"></span><span style='font-family:华文楷体'>的最后一个元素只有一个事件，那么将</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=12 height=21
src="chap18.files/image203.png"></span><span style='font-family:华文楷体'>的最后一个元素添加到</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=12 height=21
src="chap18.files/image198.png"></span><span style='font-family:华文楷体'>的末尾，就得到一个候选<span
lang=EN-US>k-</span>序列；而如果</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=12 height=21
src="chap18.files/image203.png"></span><span style='font-family:华文楷体'>的最后一个元素有多个事件，则将</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=12 height=21
src="chap18.files/image203.png"></span><span style='font-family:华文楷体'>的最后一个事件添加到</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=12 height=21
src="chap18.files/image198.png"></span><span style='font-family:华文楷体'>的最后一个元素的末尾，同样得到一个候选<span
lang=EN-US>k-</span>序列。需要注意的是，如果令</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=12 height=21
src="chap18.files/image198.png"></span><span lang=EN-US style='font-family:
华文楷体'>=&lt;{a}&gt;</span><span style='font-family:华文楷体'>，</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=12 height=21
src="chap18.files/image203.png"></span><span lang=EN-US style='font-family:
华文楷体'>=&lt;{b}&gt;</span><span style='font-family:华文楷体'>，它们之间连接可以得到<span
lang=EN-US>2</span>个候选<span lang=EN-US>2-</span>序列，即<span lang=EN-US>&lt;{a,
b}&gt;</span>、<span lang=EN-US>&lt;{a}{b}&gt;</span>。不难发现，</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=12 height=21
src="chap18.files/image198.png"></span><span style='font-family:华文楷体'>和</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=12 height=21
src="chap18.files/image203.png"></span><span style='font-family:华文楷体'>都是它们连接得到的候选序列的邻接子序列。</span></p>

<p class=MsoNormal><span lang=EN-US style='font-family:华文楷体'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span
style='font-family:华文楷体'>第二步是剪枝阶段，即利用先验原理对候选序列进行剪枝。当有<span lang=EN-US>maxgap</span>时限约束时，如果一个候选序列的任何一个邻接子序列不满足最小支持度，就将其剪去。如果没有<span
lang=EN-US>maxgap</span>时限约束，我们需要检查候选序列的全部子序列，如果其中任何一个子序列不满足最小支持度，就将该候选序列剪去。可以看到，利用邻接子序列定义的先验原理，可以在一定程度上帮助我们减少需要检查的子序列的数量，从而加速剪枝。</span></p>

<p class=MsoListParagraph><span style='font-family:华文楷体'>接着是支持度计数过程。这一过程和<span
lang=EN-US>AprioriAll</span>算法中的支持度计数过程相似。首先利用<span lang=EN-US>hash</span>树结构存储候选序列，然后利用<span
lang=EN-US>hash</span>树来减少序列数据库中每个序列需要检查的候选序列数量，再一一检查筛选后的候选序列是否被支持。在<span
lang=EN-US>GSP</span>算法中，支持度计数过程的前两步和<span lang=EN-US>AprioriAll</span>算法完全一样，不同之处是它提出了一种高效的方法，用于检查一个特定的候选序列是否被某个序列支持。下面我们将作详细介绍。</span></p>

<p class=MsoListParagraph><span style='font-family:华文楷体'>假设<span lang=EN-US>s</span>是序列数据库中的一个序列，<span
lang=EN-US>c</span>是一条候选序列，我们的目的是快速检查<span lang=EN-US>s</span>是否支持<span
lang=EN-US>c</span>，即检查<span lang=EN-US>c</span>是否为<span lang=EN-US>s</span>的子序列。为了实现这一点，给出算法如下，它也分为向前迭代阶段和向后迭代阶段，但是和<span
lang=EN-US>AprioriSome</span>中的完全不同。</span></p>

<p class=MsoListParagraph><span style='font-family:华文楷体'>在向前阶段，我们在<span
lang=EN-US>s</span>中寻找<span lang=EN-US>c</span>的相邻元素的出现，并检查它们之间的时间差是否满足时间约束，如果满足，则按顺序继续寻找<span
lang=EN-US>c</span>的下一个元素；如果不满足，就转入向后阶段。</span></p>

<p class=MsoListParagraph><span style='font-family:华文楷体'>假设在寻找过程中，</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=11 height=21
src="chap18.files/image204.png"></span><span style='font-family:华文楷体'>（出现时间为<span
lang=EN-US>t</span>）和其前一个元素</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=24 height=21
src="chap18.files/image205.png"></span><span style='font-family:华文楷体'>的出现时间不满足时间约束，从而转入了向后阶段。在向后阶段中，我们将</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=24 height=21
src="chap18.files/image205.png"></span><span style='font-family:华文楷体'>删去，在</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=68 height=21
src="chap18.files/image206.png"></span><span style='font-family:华文楷体'>的时间点之后继续寻找新的</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=24 height=21
src="chap18.files/image205.png"></span><span style='font-family:华文楷体'>。接着可能出现以下三种情况，需要分别处理。</span></p>

<p class=MsoListParagraph><span style='font-family:华文楷体'>若找到后，两者的时间差满足时间约束，我们还不能马上转回向前阶段。由于</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=24 height=21
src="chap18.files/image205.png"></span><span style='font-family:华文楷体'>的出现时间改变了，我们还需要检查</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=24 height=21
src="chap18.files/image205.png"></span><span style='font-family:华文楷体'>和</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=24 height=21
src="chap18.files/image207.png"></span><span style='font-family:华文楷体'>的时间差是否依旧满足时间约束，若不满足，则还需要如调整</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=24 height=21
src="chap18.files/image205.png"></span><span style='font-family:华文楷体'>一样尝试调整</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=24 height=21
src="chap18.files/image207.png"></span><span style='font-family:华文楷体'>，直到当前全部元素之间的时间差都满足时间约束，才能转入向前阶段。</span></p>

<p class=MsoListParagraph><span style='font-family:华文楷体'>若没找到新的</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=24 height=21
src="chap18.files/image205.png"></span><span style='font-family:华文楷体'>，则说明<span
lang=EN-US>s</span>不支持<span lang=EN-US>c</span>，迭代结束。</span></p>

<p class=MsoListParagraph><span style='font-family:华文楷体'>若找到后，但需要不断向前调整元素，最后如果导致<span
lang=EN-US>c</span>中的第一个元素</span><span lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";position:
relative;top:4.0pt'><img width=12 height=21 src="chap18.files/image094.png"></span><span
style='font-family:华文楷体'>也需要重新寻找新的出现位置时，我们如果能找到新的</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=12 height=21
src="chap18.files/image094.png"></span><span style='font-family:华文楷体'>，就立即转回向前阶段，否则说明<span
lang=EN-US>s</span>不支持<span lang=EN-US>c</span>，迭代结束。</span></p>

<p class=MsoListParagraph><span style='font-family:华文楷体'>每次从向后阶段转回向前阶段时，假设向后阶段中最后一个需要调整出现位置的元素是</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.5pt'><img width=10 height=21
src="chap18.files/image208.png"></span><span style='font-family:华文楷体'>，回到向前阶段时，我们就需要在<span
lang=EN-US>s</span>中从</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.5pt'><img width=24 height=21
src="chap18.files/image209.png"></span><span style='font-family:华文楷体'>继续寻找。</span></p>

<p class=MsoListParagraph><span style='font-family:华文楷体'>向前阶段和向后阶段是交替进行的，如果在<span
lang=EN-US>s</span>中找到了<span lang=EN-US>c</span>的全部元素，且都满足时间约束，那么就说明<span
lang=EN-US>s</span>支持<span lang=EN-US>c</span>。下面我们结合一个具体案例进行说明。</span></p>

<p class=MsoListParagraph><span style='font-family:华文楷体'>以图<span lang=EN-US>18-13</span>（<span
lang=EN-US>1</span>）中数据为序列数据库中的一条序列数据<span lang=EN-US>s</span>，设<span
lang=EN-US>maxgap=30</span>，<span lang=EN-US>mingap=5</span>，<span lang=EN-US>window-size=0</span>，我们要检查的候选序列<span
lang=EN-US>p</span>为<span lang=EN-US>&lt;{a, b}{c}{d}&gt;</span>。我们首先在<span
lang=EN-US>s</span>中找到<span lang=EN-US>p</span>中第一个元素<span lang=EN-US>{a, b}</span>的出现时间为<span
lang=EN-US>10</span>，然后找到<span lang=EN-US>p</span>中第二个元素<span lang=EN-US>{c}</span>的出现时间为<span
lang=EN-US>45</span>，两者的时间差为<span lang=EN-US>35</span>，大于<span lang=EN-US>maxgap</span>，所以转入向后阶段。删去<span
lang=EN-US>{a, b}</span>，在时间点<span lang=EN-US>15</span>（即</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.5pt'><img width=92 height=21
src="chap18.files/image210.png"></span><span style='font-family:华文楷体'>）之后继续寻找新的<span
lang=EN-US>{a, b}</span>出现时间。我们找到新的<span lang=EN-US>{a, b}</span>出现时间为<span
lang=EN-US>50</span>，由于<span lang=EN-US>{a, b}</span>是<span lang=EN-US>p</span>中第一个元素，不用考虑调整<span
lang=EN-US>{a, b}</span>出现时间后，其与之前元素的时间约束是否还满足的问题。然后转回向前阶段，从时间<span lang=EN-US>55</span>（</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.5pt'><img width=90 height=21
src="chap18.files/image211.png"></span><span style='font-family:华文楷体'>）之后重新寻找<span
lang=EN-US>{a, b}</span>的下一个元素，即<span lang=EN-US>{c}</span>。<span lang=EN-US>{c}</span>的下一个出现时间是<span
lang=EN-US>65</span>，由于<span lang=EN-US>65-50=15</span>，满足时间约束。接着我们从时间<span
lang=EN-US>70</span>（</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.5pt'><img width=84 height=21
src="chap18.files/image212.png"></span><span style='font-family:华文楷体'>）开始继续寻找下一个元素<span
lang=EN-US>{d}</span>，<span lang=EN-US>{d}</span>的出现时间是<span lang=EN-US>90</span>，由于<span
lang=EN-US>90-65=25</span>，满足时间约束，且<span lang=EN-US>p</span>中的全部元素都已找到，所以迭代结束，得出结论序列<span
lang=EN-US>s</span>支持候选序列<span lang=EN-US>p</span>。</span></p>

<p class=MsoListParagraph><span style='font-family:华文楷体'>在上面的流程中，我们没有详细描述“在序列中找到某个元素的出现时间”这一过程，事实上，如果我们每次都通过遍历序列来寻找给定元素的出现时间的话，效率将严重下降。而若将数据序列<span
lang=EN-US>s</span>的表示方法作如图<span lang=EN-US>18-13</span>（<span lang=EN-US>2</span>）所示变换，就能这一过程更加高效。</span></p>

<p class=MsoListParagraph align=center style='text-align:center'><span
lang=EN-US><img width=406 height=274 id="图片 18" src="chap18.files/image213.jpg"></span></p>

<p class=MsoNormal align=center style='margin-bottom:7.8pt;text-align:center'><b><span
lang=EN-US style='font-family:华文楷体'>&nbsp;&nbsp;&nbsp;&nbsp; </span></b><b><span
style='font-family:华文楷体'>图<span lang=EN-US>18-13&nbsp; </span>（<span
lang=EN-US>1</span>）为序列数据，右为序列数据转换后的表示</span></b></p>

<p class=MsoListParagraph><span style='font-family:华文楷体'>创建一个字典，其中键是序列<span
lang=EN-US>s</span>中的事件名称，值则是该事件在序列<span lang=EN-US>s</span>中的出现时间，具体如图<span
lang=EN-US>18-13</span>（<span lang=EN-US>2</span>）所示。要找到事件<span lang=EN-US>q</span>在时间节点<span
lang=EN-US>t</span>之后的第一次出现时间，我们只需要遍历字典中<span lang=EN-US>q</span>对应的值，然后找到比<span
lang=EN-US>t</span>大的第一个值即可。创建这个字典的时间复杂度是</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=57 height=21
src="chap18.files/image214.png"></span><span style='font-family:华文楷体'>，其中<span
lang=EN-US>n</span>是整个序列数据库中事件的个数，<span lang=EN-US>m</span>则是序列<span
lang=EN-US>s</span>中事件的个数。</span></p>

<p class=MsoListParagraph><span style='font-family:华文楷体'>对于包含多个事件的元素，设元素中最早和最晚的事件的出现时间分别为<span
lang=EN-US>start-time</span>（<span lang=EN-US>st</span>）和<span lang=EN-US>end-time</span>（<span
lang=EN-US>et</span>），如果两者之差大于设定的<span lang=EN-US>window-size</span>（<span
lang=EN-US>ws</span>），我们需要从</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=68 height=21
src="chap18.files/image215.png"></span><span style='font-family:华文楷体'>开始，重复上述搜索过程；否则就结束搜索。</span></p>

<p class=MsoListParagraph><span style='font-family:华文楷体'>仍旧以图<span lang=EN-US>18-13</span>（<span
lang=EN-US>1</span>）中所示，设<span lang=EN-US>window-size=7</span>，如果我们需要搜索<span
lang=EN-US>t=20</span>之后元素<span lang=EN-US>{b, f}</span>的第一次出现时间，则过程如下。首先，根据图<span
lang=EN-US>18-13</span>（<span lang=EN-US>2</span>），我们找到<span lang=EN-US>b</span>第一次出现时间是<span
lang=EN-US>50</span>，而<span lang=EN-US>f</span>的第一次出现时间是<span lang=EN-US>25</span>，故</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=165 height=21
src="chap18.files/image216.png"></span><span style='font-family:华文楷体'>，然后设置</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=160 height=21
src="chap18.files/image217.png"></span><span style='font-family:华文楷体'>，从时间点<span
lang=EN-US>t</span>往后重新搜索。我们找到<span lang=EN-US>b</span>的出现时间仍是<span lang=EN-US>50</span>，而<span
lang=EN-US>f</span>的出现时间为<span lang=EN-US>95</span>，此时</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=99 height=21
src="chap18.files/image218.png"></span><span style='font-family:华文楷体'>，再设置</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=102 height=21
src="chap18.files/image219.png"></span><span style='font-family:华文楷体'>，重新搜索。这次，我们找到<span
lang=EN-US>b</span>的出现时间是<span lang=EN-US>90</span>，<span lang=EN-US>f</span>的出现时间仍为<span
lang=EN-US>95</span>，此时</span><span
lang=EN-US style='font-size:10.5pt;font-family:"Calibri","sans-serif";
position:relative;top:4.0pt'><img width=91 height=21
src="chap18.files/image220.png"></span><span style='font-family:华文楷体'>，搜索结束。</span></p>

<p class=MsoListParagraph><span style='font-family:华文楷体'>最后让我们总结一下<span
lang=EN-US>GSP</span>算法。它加入了<span lang=EN-US>maxgap</span>、<span lang=EN-US>mingap</span>和<span
lang=EN-US>window-size</span>等时限约束，以期不会忽视一些有趣的序列模式。<span lang=EN-US>GSP</span>算法的总体流程和<span
lang=EN-US>Apriori</span>类算法一致，主要分为两个步骤，一是候选序列生成，二是候选序列支持度计数。在候选序列生成中，<span
lang=EN-US>GSP</span>算法定义了邻接子序列，重新定义了连接阶段和剪枝阶段，最后输出候选序列。在支持度计数过程中，<span
lang=EN-US>GSP</span>算法通过<span lang=EN-US>hash</span>树数据结构减少了数据库中单个序列需要检查的候选序列数量，并通过变换数据库中序列的表示方式，达到高效查询单个候选序列是否被数据库中序列支持的目的。</span></p>

<p class=MsoNormal><b><span lang=EN-US style='font-size:12.0pt;font-family:
华文楷体'>18.5.5 PrefixSpan</span></b><b><span style='font-size:12.0pt;font-family:
华文楷体'>算法</span></b></p>

<p class=MsoNormal style='text-indent:22.7pt'><span lang=EN-US
style='font-family:华文楷体'>&nbsp;</span></p>

<p class=MsoNormal><b><span lang=EN-US style='font-size:12.0pt;font-family:
华文楷体'>18.5.6</span></b><b><span style='font-size:12.0pt;font-family:华文楷体'>算法优缺点</span></b></p>

<p class=MsoNormal style='text-indent:22.7pt'><span lang=EN-US
style='font-family:华文楷体'>&nbsp;</span></p>

<p class=MsoNormal style='text-indent:22.7pt'><span lang=EN-US
style='font-family:华文楷体'>&nbsp;</span></p>

<p class=MsoNormal><b><span lang=EN-US style='font-size:14.0pt;font-family:
华文楷体;background:yellow'>18.6 </span></b><b><span style='font-size:14.0pt;
font-family:华文楷体;background:yellow'>关联规则挖掘的其它研究问题</span></b></p>

<p class=MsoNormal style='text-indent:22.7pt'><span lang=EN-US
style='font-family:华文楷体'>&nbsp;</span></p>

<p class=MsoNormal style='text-indent:22.7pt'><span lang=EN-US
style='font-family:华文楷体'>&nbsp;</span></p>

<p class=MsoNormal style='text-indent:22.7pt'><span lang=EN-US
style='font-family:华文楷体'>&nbsp;</span></p>

<p class=MsoNormal style='text-indent:22.7pt'><span lang=EN-US
style='font-family:华文楷体'>&nbsp;</span></p>

<p class=MsoNormal style='text-indent:22.7pt'><span lang=EN-US><img width=303
height=254 id="图片 23" src="chap18.files/image221.jpg">&nbsp;<img width=189
height=289 id="图片 24" src="chap18.files/image222.jpg"></span></p>

<p class=MsoNormal style='text-indent:22.7pt'><span lang=EN-US><img width=334
height=160 id="图片 25" src="chap18.files/image223.jpg"></span></p>

<p class=MsoNormal style='text-indent:22.7pt'><span lang=EN-US><img width=180
height=111 id="图片 32" src="chap18.files/image224.jpg"></span></p>

<p class=MsoNormal style='text-indent:22.7pt'><span lang=EN-US><img width=320
height=474 id="图片 26" src="chap18.files/image225.jpg"></span></p>

<p class=MsoNormal style='text-indent:22.7pt'><span lang=EN-US
style='font-family:华文楷体'>&nbsp;</span></p>

<p class=MsoNormal style='text-indent:22.7pt'><span lang=EN-US
style='font-family:华文楷体'>&nbsp;</span></p>

<p class=MsoNormal style='text-indent:22.7pt'><span lang=EN-US
style='font-family:华文楷体'>&nbsp;</span></p>

<p class=MsoNormal style='text-indent:22.7pt'><span lang=EN-US
style='font-family:华文楷体'>&nbsp;</span></p>

</div>

<div><br clear=all>

<hr align=left size=1 width="33%">

<div id=ftn1>

<p class=MsoFootnoteText><a href="#_ftnref1" name="_ftn1" title=""><span
class=MsoFootnoteReference><span lang=EN-US><span class=MsoFootnoteReference><span
lang=EN-US style='font-size:9.0pt;font-family:等线'>[1]</span></span></span></span></a><span
lang=EN-US> </span>按照多维数据库使用的术语，通常将规则中的不同谓词称作维。</p>

</div>

</div>

<div>

<hr class=msocomoff align=left size=1 width="33%">

<div>

<div id="_com_1" class=msocomtxt language=JavaScript
onmouseover="msoCommentShow('_anchor_1','_com_1')"
onmouseout="msoCommentHide('_com_1')"><a name="_msocom_1"></a>

<p class=MsoCommentText><span class=MsoCommentReference><span lang=EN-US>&nbsp;<a
href="#_msoanchor_1" class=msocomoff>[l1]</a></span></span>概念定义部分与书本语句有重复</p>

</div>

</div>

<div>

<div id="_com_2" class=msocomtxt language=JavaScript
onmouseover="msoCommentShow('_anchor_2','_com_2')"
onmouseout="msoCommentHide('_com_2')"><a name="_msocom_2"></a>

<p class=MsoCommentText><span class=MsoCommentReference><span lang=EN-US>&nbsp;<a
href="#_msoanchor_2" class=msocomoff>[l2]</a></span></span>和书本有相似</p>

</div>

</div>

<div>

<div id="_com_3" class=msocomtxt language=JavaScript
onmouseover="msoCommentShow('_anchor_3','_com_3')"
onmouseout="msoCommentHide('_com_3')"><a name="_msocom_3"></a>

<p class=MsoCommentText><span class=MsoCommentReference><span lang=EN-US>&nbsp;<a
href="#_msoanchor_3" class=msocomoff>[l3]</a></span></span>和书本有相似</p>

</div>

</div>

<div>

<div id="_com_4" class=msocomtxt language=JavaScript
onmouseover="msoCommentShow('_anchor_4','_com_4')"
onmouseout="msoCommentHide('_com_4')"><a name="_msocom_4"></a>

<p class=MsoCommentText><span class=MsoCommentReference><span lang=EN-US>&nbsp;<a
href="#_msoanchor_4" class=msocomoff>[l4]</a></span></span>在<span lang=EN-US>18.2.4</span>里比较</p>

</div>

</div>

<div>

<div id="_com_5" class=msocomtxt language=JavaScript
onmouseover="msoCommentShow('_anchor_5','_com_5')"
onmouseout="msoCommentHide('_com_5')"><a name="_msocom_5"></a>

<p class=MsoCommentText><span class=MsoCommentReference><span lang=EN-US>&nbsp;<a
href="#_msoanchor_5" class=msocomoff>[l5]</a></span></span>不太明白，资料较少</p>

</div>

</div>

<div>

<div id="_com_6" class=msocomtxt language=JavaScript
onmouseover="msoCommentShow('_anchor_6','_com_6')"
onmouseout="msoCommentHide('_com_6')"><a name="_msocom_6"></a>

<p class=MsoCommentText><span class=MsoCommentReference><span lang=EN-US>&nbsp;<a
href="#_msoanchor_6" class=msocomoff>[l6]</a></span></span>例子考虑替换，有重复</p>

</div>

</div>

<div>

<div id="_com_7" class=msocomtxt language=JavaScript
onmouseover="msoCommentShow('_anchor_7','_com_7')"
onmouseout="msoCommentHide('_com_7')"><a name="_msocom_7"></a>

<p class=MsoCommentText><span class=MsoCommentReference><span lang=EN-US>&nbsp;<a
href="#_msoanchor_7" class=msocomoff>[l7]</a></span></span>参考文献</p>

</div>

</div>

<div>

<div id="_com_8" class=msocomtxt language=JavaScript
onmouseover="msoCommentShow('_anchor_8','_com_8')"
onmouseout="msoCommentHide('_com_8')"><a name="_msocom_8"></a>

<p class=MsoCommentText><span class=MsoCommentReference><span lang=EN-US>&nbsp;<a
href="#_msoanchor_8" class=msocomoff>[l8]</a></span></span>看情况，待补充，不平衡比等信息</p>

</div>

</div>

</div>

</body>

</html>
